{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  KafkaJSMetadataNotLoaded\n} = require('../errors');\nconst {\n  staleMetadata\n} = require('../protocol/error');\nconst groupMessagesPerPartition = require('./groupMessagesPerPartition');\nconst createTopicData = require('./createTopicData');\nconst responseSerializer = require('./responseSerializer');\nconst {\n  keys\n} = Object;\n\n/**\n * @param {Object} options\n * @param {import(\"../../types\").Logger} options.logger\n * @param {import(\"../../types\").Cluster} options.cluster\n * @param {ReturnType<import(\"../../types\").ICustomPartitioner>} options.partitioner\n * @param {import(\"./eosManager\").EosManager} options.eosManager\n * @param {import(\"../retry\").Retrier} options.retrier\n */\nmodule.exports = ({\n  logger,\n  cluster,\n  partitioner,\n  eosManager,\n  retrier\n}) => {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* ({\n      acks,\n      timeout,\n      compression,\n      topicMessages\n    }) {\n      /** @type {Map<import(\"../../types\").Broker, any[]>} */\n      const responsePerBroker = new Map();\n\n      /** @param {Map<import(\"../../types\").Broker, any[]>} responsePerBroker */\n      const createProducerRequests = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (responsePerBroker) {\n          const topicMetadata = new Map();\n          yield cluster.refreshMetadataIfNecessary();\n          for (const {\n            topic,\n            messages\n          } of topicMessages) {\n            const partitionMetadata = cluster.findTopicPartitionMetadata(topic);\n            if (partitionMetadata.length === 0) {\n              logger.debug('Producing to topic without metadata', {\n                topic,\n                targetTopics: Array.from(cluster.targetTopics)\n              });\n              throw new KafkaJSMetadataNotLoaded('Producing to topic without metadata');\n            }\n            const messagesPerPartition = groupMessagesPerPartition({\n              topic,\n              partitionMetadata,\n              messages,\n              partitioner\n            });\n            const partitions = keys(messagesPerPartition);\n            const partitionsPerLeader = cluster.findLeaderForPartitions(topic, partitions);\n            const leaders = keys(partitionsPerLeader);\n            topicMetadata.set(topic, {\n              partitionsPerLeader,\n              messagesPerPartition\n            });\n            for (const nodeId of leaders) {\n              const broker = yield cluster.findBroker({\n                nodeId\n              });\n              if (!responsePerBroker.has(broker)) {\n                responsePerBroker.set(broker, null);\n              }\n            }\n          }\n          const brokers = Array.from(responsePerBroker.keys());\n          const brokersWithoutResponse = brokers.filter(broker => !responsePerBroker.get(broker));\n          return brokersWithoutResponse.map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (broker) {\n              const entries = Array.from(topicMetadata.entries());\n              const topicDataForBroker = entries.filter(([_, {\n                partitionsPerLeader\n              }]) => !!partitionsPerLeader[broker.nodeId]).map(([topic, {\n                partitionsPerLeader,\n                messagesPerPartition,\n                sequencePerPartition\n              }]) => ({\n                topic,\n                partitions: partitionsPerLeader[broker.nodeId],\n                messagesPerPartition\n              }));\n              const topicData = createTopicData(topicDataForBroker);\n              yield eosManager.acquireBrokerLock(broker);\n              try {\n                if (eosManager.isTransactional()) {\n                  yield eosManager.addPartitionsToTransaction(topicData);\n                }\n                topicData.forEach(({\n                  topic,\n                  partitions\n                }) => {\n                  partitions.forEach(entry => {\n                    entry['firstSequence'] = eosManager.getSequence(topic, entry.partition);\n                    eosManager.updateSequence(topic, entry.partition, entry.messages.length);\n                  });\n                });\n                let response;\n                try {\n                  response = yield broker.produce({\n                    transactionalId: eosManager.isTransactional() ? eosManager.getTransactionalId() : undefined,\n                    producerId: eosManager.getProducerId(),\n                    producerEpoch: eosManager.getProducerEpoch(),\n                    acks,\n                    timeout,\n                    compression,\n                    topicData\n                  });\n                } catch (e) {\n                  topicData.forEach(({\n                    topic,\n                    partitions\n                  }) => {\n                    partitions.forEach(entry => {\n                      eosManager.updateSequence(topic, entry.partition, -entry.messages.length);\n                    });\n                  });\n                  throw e;\n                }\n                const expectResponse = acks !== 0;\n                const formattedResponse = expectResponse ? responseSerializer(response) : [];\n                responsePerBroker.set(broker, formattedResponse);\n              } catch (e) {\n                responsePerBroker.delete(broker);\n                throw e;\n              } finally {\n                yield eosManager.releaseBrokerLock(broker);\n              }\n            });\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n        });\n        return function createProducerRequests(_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      return retrier( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          const topics = topicMessages.map(({\n            topic\n          }) => topic);\n          yield cluster.addMultipleTargetTopics(topics);\n          try {\n            const requests = yield createProducerRequests(responsePerBroker);\n            yield Promise.all(requests);\n            return Array.from(responsePerBroker.values()).flat();\n          } catch (e) {\n            if (e.name === 'KafkaJSConnectionClosedError') {\n              cluster.removeBroker({\n                host: e.host,\n                port: e.port\n              });\n            }\n            if (!cluster.isConnected()) {\n              logger.debug(`Cluster has disconnected, reconnecting: ${e.message}`, {\n                retryCount,\n                retryTime\n              });\n              yield cluster.connect();\n              yield cluster.refreshMetadata();\n              throw e;\n            }\n\n            // This is necessary in case the metadata is stale and the number of partitions\n            // for this topic has increased in the meantime\n            if (staleMetadata(e) || e.name === 'KafkaJSMetadataNotLoaded' || e.name === 'KafkaJSConnectionError' || e.name === 'KafkaJSConnectionClosedError' || e.name === 'KafkaJSProtocolError' && e.retriable) {\n              logger.error(`Failed to send messages: ${e.message}`, {\n                retryCount,\n                retryTime\n              });\n              yield cluster.refreshMetadata();\n              throw e;\n            }\n            logger.error(`${e.message}`, {\n              retryCount,\n              retryTime\n            });\n            if (e.retriable) throw e;\n            bail(e);\n          }\n        });\n        return function (_x4, _x5, _x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"names":["KafkaJSMetadataNotLoaded","require","staleMetadata","groupMessagesPerPartition","createTopicData","responseSerializer","keys","Object","module","exports","logger","cluster","partitioner","eosManager","retrier","acks","timeout","compression","topicMessages","responsePerBroker","Map","createProducerRequests","topicMetadata","refreshMetadataIfNecessary","topic","messages","partitionMetadata","findTopicPartitionMetadata","length","debug","targetTopics","Array","from","messagesPerPartition","partitions","partitionsPerLeader","findLeaderForPartitions","leaders","set","nodeId","broker","findBroker","has","brokers","brokersWithoutResponse","filter","get","map","entries","topicDataForBroker","_","sequencePerPartition","topicData","acquireBrokerLock","isTransactional","addPartitionsToTransaction","forEach","entry","getSequence","partition","updateSequence","response","produce","transactionalId","getTransactionalId","undefined","producerId","getProducerId","producerEpoch","getProducerEpoch","e","expectResponse","formattedResponse","delete","releaseBrokerLock","bail","retryCount","retryTime","topics","addMultipleTargetTopics","requests","Promise","all","values","flat","name","removeBroker","host","port","isConnected","message","connect","refreshMetadata","retriable","error"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/producer/sendMessages.js"],"sourcesContent":["const { KafkaJSMetadataNotLoaded } = require('../errors')\nconst { staleMetadata } = require('../protocol/error')\nconst groupMessagesPerPartition = require('./groupMessagesPerPartition')\nconst createTopicData = require('./createTopicData')\nconst responseSerializer = require('./responseSerializer')\n\nconst { keys } = Object\n\n/**\n * @param {Object} options\n * @param {import(\"../../types\").Logger} options.logger\n * @param {import(\"../../types\").Cluster} options.cluster\n * @param {ReturnType<import(\"../../types\").ICustomPartitioner>} options.partitioner\n * @param {import(\"./eosManager\").EosManager} options.eosManager\n * @param {import(\"../retry\").Retrier} options.retrier\n */\nmodule.exports = ({ logger, cluster, partitioner, eosManager, retrier }) => {\n  return async ({ acks, timeout, compression, topicMessages }) => {\n    /** @type {Map<import(\"../../types\").Broker, any[]>} */\n    const responsePerBroker = new Map()\n\n    /** @param {Map<import(\"../../types\").Broker, any[]>} responsePerBroker */\n    const createProducerRequests = async responsePerBroker => {\n      const topicMetadata = new Map()\n\n      await cluster.refreshMetadataIfNecessary()\n\n      for (const { topic, messages } of topicMessages) {\n        const partitionMetadata = cluster.findTopicPartitionMetadata(topic)\n\n        if (partitionMetadata.length === 0) {\n          logger.debug('Producing to topic without metadata', {\n            topic,\n            targetTopics: Array.from(cluster.targetTopics),\n          })\n\n          throw new KafkaJSMetadataNotLoaded('Producing to topic without metadata')\n        }\n\n        const messagesPerPartition = groupMessagesPerPartition({\n          topic,\n          partitionMetadata,\n          messages,\n          partitioner,\n        })\n\n        const partitions = keys(messagesPerPartition)\n        const partitionsPerLeader = cluster.findLeaderForPartitions(topic, partitions)\n        const leaders = keys(partitionsPerLeader)\n\n        topicMetadata.set(topic, {\n          partitionsPerLeader,\n          messagesPerPartition,\n        })\n\n        for (const nodeId of leaders) {\n          const broker = await cluster.findBroker({ nodeId })\n          if (!responsePerBroker.has(broker)) {\n            responsePerBroker.set(broker, null)\n          }\n        }\n      }\n\n      const brokers = Array.from(responsePerBroker.keys())\n      const brokersWithoutResponse = brokers.filter(broker => !responsePerBroker.get(broker))\n\n      return brokersWithoutResponse.map(async broker => {\n        const entries = Array.from(topicMetadata.entries())\n        const topicDataForBroker = entries\n          .filter(([_, { partitionsPerLeader }]) => !!partitionsPerLeader[broker.nodeId])\n          .map(([topic, { partitionsPerLeader, messagesPerPartition, sequencePerPartition }]) => ({\n            topic,\n            partitions: partitionsPerLeader[broker.nodeId],\n            messagesPerPartition,\n          }))\n\n        const topicData = createTopicData(topicDataForBroker)\n\n        await eosManager.acquireBrokerLock(broker)\n        try {\n          if (eosManager.isTransactional()) {\n            await eosManager.addPartitionsToTransaction(topicData)\n          }\n\n          topicData.forEach(({ topic, partitions }) => {\n            partitions.forEach(entry => {\n              entry['firstSequence'] = eosManager.getSequence(topic, entry.partition)\n              eosManager.updateSequence(topic, entry.partition, entry.messages.length)\n            })\n          })\n\n          let response\n          try {\n            response = await broker.produce({\n              transactionalId: eosManager.isTransactional()\n                ? eosManager.getTransactionalId()\n                : undefined,\n              producerId: eosManager.getProducerId(),\n              producerEpoch: eosManager.getProducerEpoch(),\n              acks,\n              timeout,\n              compression,\n              topicData,\n            })\n          } catch (e) {\n            topicData.forEach(({ topic, partitions }) => {\n              partitions.forEach(entry => {\n                eosManager.updateSequence(topic, entry.partition, -entry.messages.length)\n              })\n            })\n            throw e\n          }\n\n          const expectResponse = acks !== 0\n          const formattedResponse = expectResponse ? responseSerializer(response) : []\n\n          responsePerBroker.set(broker, formattedResponse)\n        } catch (e) {\n          responsePerBroker.delete(broker)\n          throw e\n        } finally {\n          await eosManager.releaseBrokerLock(broker)\n        }\n      })\n    }\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      const topics = topicMessages.map(({ topic }) => topic)\n      await cluster.addMultipleTargetTopics(topics)\n\n      try {\n        const requests = await createProducerRequests(responsePerBroker)\n        await Promise.all(requests)\n        return Array.from(responsePerBroker.values()).flat()\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionClosedError') {\n          cluster.removeBroker({ host: e.host, port: e.port })\n        }\n\n        if (!cluster.isConnected()) {\n          logger.debug(`Cluster has disconnected, reconnecting: ${e.message}`, {\n            retryCount,\n            retryTime,\n          })\n          await cluster.connect()\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        // This is necessary in case the metadata is stale and the number of partitions\n        // for this topic has increased in the meantime\n        if (\n          staleMetadata(e) ||\n          e.name === 'KafkaJSMetadataNotLoaded' ||\n          e.name === 'KafkaJSConnectionError' ||\n          e.name === 'KafkaJSConnectionClosedError' ||\n          (e.name === 'KafkaJSProtocolError' && e.retriable)\n        ) {\n          logger.error(`Failed to send messages: ${e.message}`, { retryCount, retryTime })\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        logger.error(`${e.message}`, { retryCount, retryTime })\n        if (e.retriable) throw e\n        bail(e)\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}