{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Decoder = require('../../../decoder');\nconst MessageSetDecoder = require('../../../messageSet/decoder');\nconst RecordBatchDecoder = require('../../../recordBatch/v0/decoder');\nconst {\n  MAGIC_BYTE\n} = require('../../../recordBatch/v0');\n\n// the magic offset is at the same offset for all current message formats, but the 4 bytes\n// between the size and the magic is dependent on the version.\nconst MAGIC_OFFSET = 16;\nconst RECORD_BATCH_OVERHEAD = 49;\nconst decodeMessages = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (decoder) {\n    const messagesSize = decoder.readInt32();\n    if (messagesSize <= 0 || !decoder.canReadBytes(messagesSize)) {\n      return [];\n    }\n    const messagesBuffer = decoder.readBytes(messagesSize);\n    const messagesDecoder = new Decoder(messagesBuffer);\n    const magicByte = messagesBuffer.slice(MAGIC_OFFSET).readInt8(0);\n    if (magicByte === MAGIC_BYTE) {\n      const records = [];\n      while (messagesDecoder.canReadBytes(RECORD_BATCH_OVERHEAD)) {\n        try {\n          const recordBatch = yield RecordBatchDecoder(messagesDecoder);\n          records.push(...recordBatch.records);\n        } catch (e) {\n          // The tail of the record batches can have incomplete records\n          // due to how maxBytes works. See https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-FetchAPI\n          if (e.name === 'KafkaJSPartialMessageError') {\n            break;\n          }\n          throw e;\n        }\n      }\n      return records;\n    }\n    return MessageSetDecoder(messagesDecoder, messagesSize);\n  });\n  return function decodeMessages(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = decodeMessages;","map":{"version":3,"names":["Decoder","require","MessageSetDecoder","RecordBatchDecoder","MAGIC_BYTE","MAGIC_OFFSET","RECORD_BATCH_OVERHEAD","decodeMessages","decoder","messagesSize","readInt32","canReadBytes","messagesBuffer","readBytes","messagesDecoder","magicByte","slice","readInt8","records","recordBatch","push","e","name","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/requests/fetch/v4/decodeMessages.js"],"sourcesContent":["const Decoder = require('../../../decoder')\nconst MessageSetDecoder = require('../../../messageSet/decoder')\nconst RecordBatchDecoder = require('../../../recordBatch/v0/decoder')\nconst { MAGIC_BYTE } = require('../../../recordBatch/v0')\n\n// the magic offset is at the same offset for all current message formats, but the 4 bytes\n// between the size and the magic is dependent on the version.\nconst MAGIC_OFFSET = 16\nconst RECORD_BATCH_OVERHEAD = 49\n\nconst decodeMessages = async decoder => {\n  const messagesSize = decoder.readInt32()\n\n  if (messagesSize <= 0 || !decoder.canReadBytes(messagesSize)) {\n    return []\n  }\n\n  const messagesBuffer = decoder.readBytes(messagesSize)\n  const messagesDecoder = new Decoder(messagesBuffer)\n  const magicByte = messagesBuffer.slice(MAGIC_OFFSET).readInt8(0)\n\n  if (magicByte === MAGIC_BYTE) {\n    const records = []\n\n    while (messagesDecoder.canReadBytes(RECORD_BATCH_OVERHEAD)) {\n      try {\n        const recordBatch = await RecordBatchDecoder(messagesDecoder)\n        records.push(...recordBatch.records)\n      } catch (e) {\n        // The tail of the record batches can have incomplete records\n        // due to how maxBytes works. See https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-FetchAPI\n        if (e.name === 'KafkaJSPartialMessageError') {\n          break\n        }\n\n        throw e\n      }\n    }\n\n    return records\n  }\n\n  return MessageSetDecoder(messagesDecoder, messagesSize)\n}\n\nmodule.exports = decodeMessages\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,6BAA6B,CAAC;AAChE,MAAME,kBAAkB,GAAGF,OAAO,CAAC,iCAAiC,CAAC;AACrE,MAAM;EAAEG;AAAW,CAAC,GAAGH,OAAO,CAAC,yBAAyB,CAAC;;AAEzD;AACA;AACA,MAAMI,YAAY,GAAG,EAAE;AACvB,MAAMC,qBAAqB,GAAG,EAAE;AAEhC,MAAMC,cAAc;EAAA,6BAAG,WAAMC,OAAO,EAAI;IACtC,MAAMC,YAAY,GAAGD,OAAO,CAACE,SAAS,EAAE;IAExC,IAAID,YAAY,IAAI,CAAC,IAAI,CAACD,OAAO,CAACG,YAAY,CAACF,YAAY,CAAC,EAAE;MAC5D,OAAO,EAAE;IACX;IAEA,MAAMG,cAAc,GAAGJ,OAAO,CAACK,SAAS,CAACJ,YAAY,CAAC;IACtD,MAAMK,eAAe,GAAG,IAAId,OAAO,CAACY,cAAc,CAAC;IACnD,MAAMG,SAAS,GAAGH,cAAc,CAACI,KAAK,CAACX,YAAY,CAAC,CAACY,QAAQ,CAAC,CAAC,CAAC;IAEhE,IAAIF,SAAS,KAAKX,UAAU,EAAE;MAC5B,MAAMc,OAAO,GAAG,EAAE;MAElB,OAAOJ,eAAe,CAACH,YAAY,CAACL,qBAAqB,CAAC,EAAE;QAC1D,IAAI;UACF,MAAMa,WAAW,SAAShB,kBAAkB,CAACW,eAAe,CAAC;UAC7DI,OAAO,CAACE,IAAI,CAAC,GAAGD,WAAW,CAACD,OAAO,CAAC;QACtC,CAAC,CAAC,OAAOG,CAAC,EAAE;UACV;UACA;UACA,IAAIA,CAAC,CAACC,IAAI,KAAK,4BAA4B,EAAE;YAC3C;UACF;UAEA,MAAMD,CAAC;QACT;MACF;MAEA,OAAOH,OAAO;IAChB;IAEA,OAAOhB,iBAAiB,CAACY,eAAe,EAAEL,YAAY,CAAC;EACzD,CAAC;EAAA,gBAjCKF,cAAc;IAAA;EAAA;AAAA,GAiCnB;AAEDgB,MAAM,CAACC,OAAO,GAAGjB,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}