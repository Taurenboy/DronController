{"ast":null,"code":"const Long = require('../utils/long');\nconst INT8_SIZE = 1;\nconst INT16_SIZE = 2;\nconst INT32_SIZE = 4;\nconst INT64_SIZE = 8;\nconst DOUBLE_SIZE = 8;\nconst MOST_SIGNIFICANT_BIT = 0x80; // 128\nconst OTHER_BITS = 0x7f; // 127\nconst UNSIGNED_INT32_MAX_NUMBER = 0xffffff80;\nconst UNSIGNED_INT64_MAX_NUMBER = 0xffffffffffffff80n;\nmodule.exports = class Encoder {\n  static encodeZigZag(value) {\n    return value << 1 ^ value >> 31;\n  }\n  static encodeZigZag64(value) {\n    const longValue = Long.fromValue(value);\n    return longValue.shiftLeft(1).xor(longValue.shiftRight(63));\n  }\n  static sizeOfVarInt(value) {\n    let encodedValue = this.encodeZigZag(value);\n    let bytes = 1;\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      bytes += 1;\n      encodedValue >>>= 7;\n    }\n    return bytes;\n  }\n  static sizeOfVarLong(value) {\n    let longValue = Encoder.encodeZigZag64(value);\n    let bytes = 1;\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      bytes += 1;\n      longValue = longValue.shiftRightUnsigned(7);\n    }\n    return bytes;\n  }\n  static sizeOfVarIntBytes(value) {\n    const size = value == null ? -1 : Buffer.byteLength(value);\n    if (size < 0) {\n      return Encoder.sizeOfVarInt(-1);\n    }\n    return Encoder.sizeOfVarInt(size) + size;\n  }\n  static nextPowerOfTwo(value) {\n    return 1 << 31 - Math.clz32(value) + 1;\n  }\n\n  /**\n   * Construct a new encoder with the given initial size\n   *\n   * @param {number} [initialSize] initial size\n   */\n  constructor(initialSize = 511) {\n    this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize));\n    this.offset = 0;\n  }\n\n  /**\n   * @param {Buffer} buffer\n   */\n  writeBufferInternal(buffer) {\n    const bufferLength = buffer.length;\n    this.ensureAvailable(bufferLength);\n    buffer.copy(this.buf, this.offset, 0);\n    this.offset += bufferLength;\n  }\n  ensureAvailable(length) {\n    if (this.offset + length > this.buf.length) {\n      const newLength = Encoder.nextPowerOfTwo(this.offset + length);\n      const newBuffer = Buffer.alloc(newLength);\n      this.buf.copy(newBuffer, 0, 0, this.offset);\n      this.buf = newBuffer;\n    }\n  }\n  get buffer() {\n    return this.buf.slice(0, this.offset);\n  }\n  writeInt8(value) {\n    this.ensureAvailable(INT8_SIZE);\n    this.buf.writeInt8(value, this.offset);\n    this.offset += INT8_SIZE;\n    return this;\n  }\n  writeInt16(value) {\n    this.ensureAvailable(INT16_SIZE);\n    this.buf.writeInt16BE(value, this.offset);\n    this.offset += INT16_SIZE;\n    return this;\n  }\n  writeInt32(value) {\n    this.ensureAvailable(INT32_SIZE);\n    this.buf.writeInt32BE(value, this.offset);\n    this.offset += INT32_SIZE;\n    return this;\n  }\n  writeUInt32(value) {\n    this.ensureAvailable(INT32_SIZE);\n    this.buf.writeUInt32BE(value, this.offset);\n    this.offset += INT32_SIZE;\n    return this;\n  }\n  writeInt64(value) {\n    this.ensureAvailable(INT64_SIZE);\n    const longValue = Long.fromValue(value);\n    this.buf.writeInt32BE(longValue.getHighBits(), this.offset);\n    this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE);\n    this.offset += INT64_SIZE;\n    return this;\n  }\n  writeDouble(value) {\n    this.ensureAvailable(DOUBLE_SIZE);\n    this.buf.writeDoubleBE(value, this.offset);\n    this.offset += DOUBLE_SIZE;\n    return this;\n  }\n  writeBoolean(value) {\n    value ? this.writeInt8(1) : this.writeInt8(0);\n    return this;\n  }\n  writeString(value) {\n    if (value == null) {\n      this.writeInt16(-1);\n      return this;\n    }\n    const byteLength = Buffer.byteLength(value, 'utf8');\n    this.ensureAvailable(INT16_SIZE + byteLength);\n    this.writeInt16(byteLength);\n    this.buf.write(value, this.offset, byteLength, 'utf8');\n    this.offset += byteLength;\n    return this;\n  }\n  writeVarIntString(value) {\n    if (value == null) {\n      this.writeVarInt(-1);\n      return this;\n    }\n    const byteLength = Buffer.byteLength(value, 'utf8');\n    this.writeVarInt(byteLength);\n    this.ensureAvailable(byteLength);\n    this.buf.write(value, this.offset, byteLength, 'utf8');\n    this.offset += byteLength;\n    return this;\n  }\n  writeUVarIntString(value) {\n    if (value == null) {\n      this.writeUVarInt(0);\n      return this;\n    }\n    const byteLength = Buffer.byteLength(value, 'utf8');\n    this.writeUVarInt(byteLength + 1);\n    this.ensureAvailable(byteLength);\n    this.buf.write(value, this.offset, byteLength, 'utf8');\n    this.offset += byteLength;\n    return this;\n  }\n  writeBytes(value) {\n    if (value == null) {\n      this.writeInt32(-1);\n      return this;\n    }\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.ensureAvailable(INT32_SIZE + value.length);\n      this.writeInt32(value.length);\n      this.writeBufferInternal(value);\n    } else {\n      const valueToWrite = String(value);\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8');\n      this.ensureAvailable(INT32_SIZE + byteLength);\n      this.writeInt32(byteLength);\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8');\n      this.offset += byteLength;\n    }\n    return this;\n  }\n  writeVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(-1);\n      return this;\n    }\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeVarInt(value.length);\n      this.writeBufferInternal(value);\n    } else {\n      const valueToWrite = String(value);\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8');\n      this.writeVarInt(byteLength);\n      this.ensureAvailable(byteLength);\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8');\n      this.offset += byteLength;\n    }\n    return this;\n  }\n  writeUVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(0);\n      return this;\n    }\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeUVarInt(value.length + 1);\n      this.writeBufferInternal(value);\n    } else {\n      const valueToWrite = String(value);\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8');\n      this.writeUVarInt(byteLength + 1);\n      this.ensureAvailable(byteLength);\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8');\n      this.offset += byteLength;\n    }\n    return this;\n  }\n  writeEncoder(value) {\n    if (value == null || !Buffer.isBuffer(value.buf)) {\n      throw new Error('value should be an instance of Encoder');\n    }\n    this.writeBufferInternal(value.buffer);\n    return this;\n  }\n  writeEncoderArray(value) {\n    if (!Array.isArray(value) || value.some(v => v == null || !Buffer.isBuffer(v.buf))) {\n      throw new Error('all values should be an instance of Encoder[]');\n    }\n    value.forEach(v => {\n      this.writeBufferInternal(v.buffer);\n    });\n    return this;\n  }\n  writeBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n      throw new Error('value should be an instance of Buffer');\n    }\n    this.writeBufferInternal(value);\n    return this;\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   */\n  writeNullableArray(array, type) {\n    // A null value is encoded with length of -1 and there are no following bytes\n    // On the context of this library, empty array and null are the same thing\n    const length = array.length !== 0 ? array.length : -1;\n    this.writeArray(array, type, length);\n    return this;\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   * @param {number} [length]\n   */\n  writeArray(array, type, length) {\n    const arrayLength = length == null ? array.length : length;\n    this.writeInt32(arrayLength);\n    if (type !== undefined) {\n      switch (type) {\n        case 'int32':\n        case 'number':\n          array.forEach(value => this.writeInt32(value));\n          break;\n        case 'string':\n          array.forEach(value => this.writeString(value));\n          break;\n        case 'object':\n          this.writeEncoderArray(array);\n          break;\n      }\n    } else {\n      array.forEach(value => {\n        switch (typeof value) {\n          case 'number':\n            this.writeInt32(value);\n            break;\n          case 'string':\n            this.writeString(value);\n            break;\n          case 'object':\n            this.writeEncoder(value);\n            break;\n        }\n      });\n    }\n    return this;\n  }\n  writeVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeVarInt(array.length);\n      this.writeEncoderArray(array);\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object');\n      this.writeVarInt(objectArray.length);\n      this.writeEncoderArray(objectArray);\n    }\n    return this;\n  }\n  writeUVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeUVarInt(array.length + 1);\n      this.writeEncoderArray(array);\n    } else if (array === null) {\n      this.writeUVarInt(0);\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object');\n      this.writeUVarInt(objectArray.length + 1);\n      this.writeEncoderArray(objectArray);\n    }\n    return this;\n  }\n\n  // Based on:\n  // https://en.wikipedia.org/wiki/LEB128 Using LEB128 format similar to VLQ.\n  // https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/util/Varint.java#L106\n  writeVarInt(value) {\n    return this.writeUVarInt(Encoder.encodeZigZag(value));\n  }\n  writeUVarInt(value) {\n    const byteArray = [];\n    while ((value & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      byteArray.push(value & OTHER_BITS | MOST_SIGNIFICANT_BIT);\n      value >>>= 7;\n    }\n    byteArray.push(value & OTHER_BITS);\n    this.writeBufferInternal(Buffer.from(byteArray));\n    return this;\n  }\n  writeVarLong(value) {\n    const byteArray = [];\n    let longValue = Encoder.encodeZigZag64(value);\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      byteArray.push(longValue.and(OTHER_BITS).or(MOST_SIGNIFICANT_BIT).toInt());\n      longValue = longValue.shiftRightUnsigned(7);\n    }\n    byteArray.push(longValue.toInt());\n    this.writeBufferInternal(Buffer.from(byteArray));\n    return this;\n  }\n  size() {\n    // We can use the offset here directly, because we anyways will not re-encode the buffer when writing\n    return this.offset;\n  }\n  toJSON() {\n    return this.buffer.toJSON();\n  }\n};","map":{"version":3,"names":["Long","require","INT8_SIZE","INT16_SIZE","INT32_SIZE","INT64_SIZE","DOUBLE_SIZE","MOST_SIGNIFICANT_BIT","OTHER_BITS","UNSIGNED_INT32_MAX_NUMBER","UNSIGNED_INT64_MAX_NUMBER","module","exports","Encoder","encodeZigZag","value","encodeZigZag64","longValue","fromValue","shiftLeft","xor","shiftRight","sizeOfVarInt","encodedValue","bytes","sizeOfVarLong","and","notEquals","fromInt","shiftRightUnsigned","sizeOfVarIntBytes","size","Buffer","byteLength","nextPowerOfTwo","Math","clz32","constructor","initialSize","buf","alloc","offset","writeBufferInternal","buffer","bufferLength","length","ensureAvailable","copy","newLength","newBuffer","slice","writeInt8","writeInt16","writeInt16BE","writeInt32","writeInt32BE","writeUInt32","writeUInt32BE","writeInt64","getHighBits","getLowBits","writeDouble","writeDoubleBE","writeBoolean","writeString","write","writeVarIntString","writeVarInt","writeUVarIntString","writeUVarInt","writeBytes","isBuffer","valueToWrite","String","writeVarIntBytes","writeUVarIntBytes","writeEncoder","Error","writeEncoderArray","Array","isArray","some","v","forEach","writeBuffer","writeNullableArray","array","type","writeArray","arrayLength","undefined","writeVarIntArray","objectArray","filter","writeUVarIntArray","byteArray","push","from","writeVarLong","or","toInt","toJSON"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/encoder.js"],"sourcesContent":["const Long = require('../utils/long')\n\nconst INT8_SIZE = 1\nconst INT16_SIZE = 2\nconst INT32_SIZE = 4\nconst INT64_SIZE = 8\nconst DOUBLE_SIZE = 8\n\nconst MOST_SIGNIFICANT_BIT = 0x80 // 128\nconst OTHER_BITS = 0x7f // 127\nconst UNSIGNED_INT32_MAX_NUMBER = 0xffffff80\nconst UNSIGNED_INT64_MAX_NUMBER = 0xffffffffffffff80n\n\nmodule.exports = class Encoder {\n  static encodeZigZag(value) {\n    return (value << 1) ^ (value >> 31)\n  }\n\n  static encodeZigZag64(value) {\n    const longValue = Long.fromValue(value)\n    return longValue.shiftLeft(1).xor(longValue.shiftRight(63))\n  }\n\n  static sizeOfVarInt(value) {\n    let encodedValue = this.encodeZigZag(value)\n    let bytes = 1\n\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      bytes += 1\n      encodedValue >>>= 7\n    }\n\n    return bytes\n  }\n\n  static sizeOfVarLong(value) {\n    let longValue = Encoder.encodeZigZag64(value)\n    let bytes = 1\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      bytes += 1\n      longValue = longValue.shiftRightUnsigned(7)\n    }\n\n    return bytes\n  }\n\n  static sizeOfVarIntBytes(value) {\n    const size = value == null ? -1 : Buffer.byteLength(value)\n\n    if (size < 0) {\n      return Encoder.sizeOfVarInt(-1)\n    }\n\n    return Encoder.sizeOfVarInt(size) + size\n  }\n\n  static nextPowerOfTwo(value) {\n    return 1 << (31 - Math.clz32(value) + 1)\n  }\n\n  /**\n   * Construct a new encoder with the given initial size\n   *\n   * @param {number} [initialSize] initial size\n   */\n  constructor(initialSize = 511) {\n    this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize))\n    this.offset = 0\n  }\n\n  /**\n   * @param {Buffer} buffer\n   */\n  writeBufferInternal(buffer) {\n    const bufferLength = buffer.length\n    this.ensureAvailable(bufferLength)\n    buffer.copy(this.buf, this.offset, 0)\n    this.offset += bufferLength\n  }\n\n  ensureAvailable(length) {\n    if (this.offset + length > this.buf.length) {\n      const newLength = Encoder.nextPowerOfTwo(this.offset + length)\n      const newBuffer = Buffer.alloc(newLength)\n      this.buf.copy(newBuffer, 0, 0, this.offset)\n      this.buf = newBuffer\n    }\n  }\n\n  get buffer() {\n    return this.buf.slice(0, this.offset)\n  }\n\n  writeInt8(value) {\n    this.ensureAvailable(INT8_SIZE)\n    this.buf.writeInt8(value, this.offset)\n    this.offset += INT8_SIZE\n    return this\n  }\n\n  writeInt16(value) {\n    this.ensureAvailable(INT16_SIZE)\n    this.buf.writeInt16BE(value, this.offset)\n    this.offset += INT16_SIZE\n    return this\n  }\n\n  writeInt32(value) {\n    this.ensureAvailable(INT32_SIZE)\n    this.buf.writeInt32BE(value, this.offset)\n    this.offset += INT32_SIZE\n    return this\n  }\n\n  writeUInt32(value) {\n    this.ensureAvailable(INT32_SIZE)\n    this.buf.writeUInt32BE(value, this.offset)\n    this.offset += INT32_SIZE\n    return this\n  }\n\n  writeInt64(value) {\n    this.ensureAvailable(INT64_SIZE)\n    const longValue = Long.fromValue(value)\n    this.buf.writeInt32BE(longValue.getHighBits(), this.offset)\n    this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE)\n    this.offset += INT64_SIZE\n    return this\n  }\n\n  writeDouble(value) {\n    this.ensureAvailable(DOUBLE_SIZE)\n    this.buf.writeDoubleBE(value, this.offset)\n    this.offset += DOUBLE_SIZE\n    return this\n  }\n\n  writeBoolean(value) {\n    value ? this.writeInt8(1) : this.writeInt8(0)\n    return this\n  }\n\n  writeString(value) {\n    if (value == null) {\n      this.writeInt16(-1)\n      return this\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8')\n    this.ensureAvailable(INT16_SIZE + byteLength)\n    this.writeInt16(byteLength)\n    this.buf.write(value, this.offset, byteLength, 'utf8')\n    this.offset += byteLength\n    return this\n  }\n\n  writeVarIntString(value) {\n    if (value == null) {\n      this.writeVarInt(-1)\n      return this\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8')\n    this.writeVarInt(byteLength)\n    this.ensureAvailable(byteLength)\n    this.buf.write(value, this.offset, byteLength, 'utf8')\n    this.offset += byteLength\n    return this\n  }\n\n  writeUVarIntString(value) {\n    if (value == null) {\n      this.writeUVarInt(0)\n      return this\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8')\n    this.writeUVarInt(byteLength + 1)\n    this.ensureAvailable(byteLength)\n    this.buf.write(value, this.offset, byteLength, 'utf8')\n    this.offset += byteLength\n    return this\n  }\n\n  writeBytes(value) {\n    if (value == null) {\n      this.writeInt32(-1)\n      return this\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.ensureAvailable(INT32_SIZE + value.length)\n      this.writeInt32(value.length)\n      this.writeBufferInternal(value)\n    } else {\n      const valueToWrite = String(value)\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8')\n      this.ensureAvailable(INT32_SIZE + byteLength)\n      this.writeInt32(byteLength)\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8')\n      this.offset += byteLength\n    }\n\n    return this\n  }\n\n  writeVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(-1)\n      return this\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeVarInt(value.length)\n      this.writeBufferInternal(value)\n    } else {\n      const valueToWrite = String(value)\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8')\n      this.writeVarInt(byteLength)\n      this.ensureAvailable(byteLength)\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8')\n      this.offset += byteLength\n    }\n\n    return this\n  }\n\n  writeUVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(0)\n      return this\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeUVarInt(value.length + 1)\n      this.writeBufferInternal(value)\n    } else {\n      const valueToWrite = String(value)\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8')\n      this.writeUVarInt(byteLength + 1)\n      this.ensureAvailable(byteLength)\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8')\n      this.offset += byteLength\n    }\n\n    return this\n  }\n\n  writeEncoder(value) {\n    if (value == null || !Buffer.isBuffer(value.buf)) {\n      throw new Error('value should be an instance of Encoder')\n    }\n\n    this.writeBufferInternal(value.buffer)\n    return this\n  }\n\n  writeEncoderArray(value) {\n    if (!Array.isArray(value) || value.some(v => v == null || !Buffer.isBuffer(v.buf))) {\n      throw new Error('all values should be an instance of Encoder[]')\n    }\n\n    value.forEach(v => {\n      this.writeBufferInternal(v.buffer)\n    })\n    return this\n  }\n\n  writeBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n      throw new Error('value should be an instance of Buffer')\n    }\n\n    this.writeBufferInternal(value)\n    return this\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   */\n  writeNullableArray(array, type) {\n    // A null value is encoded with length of -1 and there are no following bytes\n    // On the context of this library, empty array and null are the same thing\n    const length = array.length !== 0 ? array.length : -1\n    this.writeArray(array, type, length)\n    return this\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   * @param {number} [length]\n   */\n  writeArray(array, type, length) {\n    const arrayLength = length == null ? array.length : length\n    this.writeInt32(arrayLength)\n    if (type !== undefined) {\n      switch (type) {\n        case 'int32':\n        case 'number':\n          array.forEach(value => this.writeInt32(value))\n          break\n        case 'string':\n          array.forEach(value => this.writeString(value))\n          break\n        case 'object':\n          this.writeEncoderArray(array)\n          break\n      }\n    } else {\n      array.forEach(value => {\n        switch (typeof value) {\n          case 'number':\n            this.writeInt32(value)\n            break\n          case 'string':\n            this.writeString(value)\n            break\n          case 'object':\n            this.writeEncoder(value)\n            break\n        }\n      })\n    }\n    return this\n  }\n\n  writeVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeVarInt(array.length)\n      this.writeEncoderArray(array)\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object')\n      this.writeVarInt(objectArray.length)\n      this.writeEncoderArray(objectArray)\n    }\n    return this\n  }\n\n  writeUVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeUVarInt(array.length + 1)\n      this.writeEncoderArray(array)\n    } else if (array === null) {\n      this.writeUVarInt(0)\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object')\n      this.writeUVarInt(objectArray.length + 1)\n      this.writeEncoderArray(objectArray)\n    }\n    return this\n  }\n\n  // Based on:\n  // https://en.wikipedia.org/wiki/LEB128 Using LEB128 format similar to VLQ.\n  // https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/util/Varint.java#L106\n  writeVarInt(value) {\n    return this.writeUVarInt(Encoder.encodeZigZag(value))\n  }\n\n  writeUVarInt(value) {\n    const byteArray = []\n    while ((value & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      byteArray.push((value & OTHER_BITS) | MOST_SIGNIFICANT_BIT)\n      value >>>= 7\n    }\n    byteArray.push(value & OTHER_BITS)\n    this.writeBufferInternal(Buffer.from(byteArray))\n    return this\n  }\n\n  writeVarLong(value) {\n    const byteArray = []\n    let longValue = Encoder.encodeZigZag64(value)\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      byteArray.push(\n        longValue\n          .and(OTHER_BITS)\n          .or(MOST_SIGNIFICANT_BIT)\n          .toInt()\n      )\n      longValue = longValue.shiftRightUnsigned(7)\n    }\n\n    byteArray.push(longValue.toInt())\n\n    this.writeBufferInternal(Buffer.from(byteArray))\n    return this\n  }\n\n  size() {\n    // We can use the offset here directly, because we anyways will not re-encode the buffer when writing\n    return this.offset\n  }\n\n  toJSON() {\n    return this.buffer.toJSON()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}