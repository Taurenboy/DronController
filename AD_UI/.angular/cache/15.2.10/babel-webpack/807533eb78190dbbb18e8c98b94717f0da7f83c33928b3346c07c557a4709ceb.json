{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst createSocket = require('./socket');\nconst createRequest = require('../protocol/request');\nconst Decoder = require('../protocol/decoder');\nconst {\n  KafkaJSConnectionError,\n  KafkaJSConnectionClosedError\n} = require('../errors');\nconst {\n  INT_32_MAX_VALUE\n} = require('../constants');\nconst getEnv = require('../env');\nconst RequestQueue = require('./requestQueue');\nconst {\n  CONNECTION_STATUS,\n  CONNECTED_STATUS\n} = require('./connectionStatus');\nconst sharedPromiseTo = require('../utils/sharedPromiseTo');\nconst Long = require('../utils/long');\nconst SASLAuthenticator = require('../broker/saslAuthenticator');\nconst apiKeys = require('../protocol/requests/apiKeys');\nconst requestInfo = ({\n  apiName,\n  apiKey,\n  apiVersion\n}) => `${apiName}(key: ${apiKey}, version: ${apiVersion})`;\n\n/**\n * @param request - request from protocol\n * @returns {boolean}\n */\nconst isAuthenticatedRequest = request => {\n  return ![apiKeys.ApiVersions, apiKeys.SaslHandshake, apiKeys.SaslAuthenticate].includes(request.apiKey);\n};\nconst PRIVATE = {\n  SHOULD_REAUTHENTICATE: Symbol('private:Connection:shouldReauthenticate'),\n  AUTHENTICATE: Symbol('private:Connection:authenticate')\n};\nmodule.exports = class Connection {\n  /**\n   * @param {Object} options\n   * @param {string} options.host\n   * @param {number} options.port\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").ISocketFactory} options.socketFactory\n   * @param {string} [options.clientId='kafkajs']\n   * @param {number} options.requestTimeout The maximum amount of time the client will wait for the response of a request,\n   *                                in milliseconds\n   * @param {string} [options.rack=null]\n   * @param {Object} [options.ssl=null] Options for the TLS Secure Context. It accepts all options,\n   *                            usually \"cert\", \"key\" and \"ca\". More information at\n   *                            https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n   * @param {Object} [options.sasl=null] Attributes used for SASL authentication. Options based on the\n   *                             key \"mechanism\". Connection is not actively using the SASL attributes\n   *                             but acting as a data object for this information\n   * @param {number} [options.reauthenticationThreshold=10000]\n   * @param {number} options.connectionTimeout The connection timeout, in milliseconds\n   * @param {boolean} [options.enforceRequestTimeout]\n   * @param {number} [options.maxInFlightRequests=null] The maximum number of unacknowledged requests on a connection before\n   *                                            enqueuing\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    host,\n    port,\n    logger,\n    socketFactory,\n    requestTimeout,\n    reauthenticationThreshold = 10000,\n    rack = null,\n    ssl = null,\n    sasl = null,\n    clientId = 'kafkajs',\n    connectionTimeout,\n    enforceRequestTimeout = true,\n    maxInFlightRequests = null,\n    instrumentationEmitter = null\n  }) {\n    var _this = this;\n    this.host = host;\n    this.port = port;\n    this.rack = rack;\n    this.clientId = clientId;\n    this.broker = `${this.host}:${this.port}`;\n    this.logger = logger.namespace('Connection');\n    this.socketFactory = socketFactory;\n    this.ssl = ssl;\n    this.sasl = sasl;\n    this.requestTimeout = requestTimeout;\n    this.connectionTimeout = connectionTimeout;\n    this.reauthenticationThreshold = reauthenticationThreshold;\n    this.bytesBuffered = 0;\n    this.bytesNeeded = Decoder.int32Size();\n    this.chunks = [];\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;\n    this.correlationId = 0;\n    this.requestQueue = new RequestQueue({\n      instrumentationEmitter,\n      maxInFlightRequests,\n      requestTimeout,\n      enforceRequestTimeout,\n      clientId,\n      broker: this.broker,\n      logger: logger.namespace('RequestQueue'),\n      isConnected: () => this.isConnected()\n    });\n    this.versions = null;\n    this.authHandlers = null;\n    this.authExpectResponse = false;\n    const log = level => (message, extra = {}) => {\n      const logFn = this.logger[level];\n      logFn(message, {\n        broker: this.broker,\n        clientId,\n        ...extra\n      });\n    };\n    this.logDebug = log('debug');\n    this.logError = log('error');\n    const env = getEnv();\n    this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === '1';\n    this.shouldLogFetchBuffer = this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === '1';\n    this.authenticatedAt = null;\n    this.sessionLifetime = Long.ZERO;\n    this.supportAuthenticationProtocol = null;\n\n    /**\n     * @private\n     * @returns {Promise}\n     */\n    this[PRIVATE.AUTHENTICATE] = sharedPromiseTo( /*#__PURE__*/_asyncToGenerator(function* () {\n      if (_this.sasl && !_this.isAuthenticated()) {\n        const authenticator = new SASLAuthenticator(_this, _this.logger, _this.versions, _this.supportAuthenticationProtocol);\n        yield authenticator.authenticate();\n        _this.authenticatedAt = process.hrtime();\n        _this.sessionLifetime = Long.fromValue(authenticator.sessionLifetime);\n      }\n    }));\n  }\n  getSupportAuthenticationProtocol() {\n    return this.supportAuthenticationProtocol;\n  }\n  setSupportAuthenticationProtocol(isSupported) {\n    this.supportAuthenticationProtocol = isSupported;\n  }\n  setVersions(versions) {\n    this.versions = versions;\n  }\n  isConnected() {\n    return CONNECTED_STATUS.includes(this.connectionStatus);\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  connect() {\n    var _this2 = this;\n    return new Promise((resolve, reject) => {\n      if (this.isConnected()) {\n        return resolve(true);\n      }\n      this.authenticatedAt = null;\n      let timeoutId;\n      const onConnect = () => {\n        clearTimeout(timeoutId);\n        this.connectionStatus = CONNECTION_STATUS.CONNECTED;\n        this.requestQueue.scheduleRequestTimeoutCheck();\n        resolve(true);\n      };\n      const onData = data => {\n        this.processData(data);\n      };\n      const onEnd = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          clearTimeout(timeoutId);\n          const wasConnected = _this2.isConnected();\n          if (_this2.authHandlers) {\n            _this2.authHandlers.onError();\n          } else if (wasConnected) {\n            _this2.logDebug('Kafka server has closed connection');\n            _this2.rejectRequests(new KafkaJSConnectionClosedError('Closed connection', {\n              host: _this2.host,\n              port: _this2.port\n            }));\n          }\n          yield _this2.disconnect();\n        });\n        return function onEnd() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const onError = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (e) {\n          clearTimeout(timeoutId);\n          const error = new KafkaJSConnectionError(`Connection error: ${e.message}`, {\n            broker: `${_this2.host}:${_this2.port}`,\n            code: e.code\n          });\n          _this2.logError(error.message, {\n            stack: e.stack\n          });\n          _this2.rejectRequests(error);\n          yield _this2.disconnect();\n          reject(error);\n        });\n        return function onError(_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      const onTimeout = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          const error = new KafkaJSConnectionError('Connection timeout', {\n            broker: `${_this2.host}:${_this2.port}`\n          });\n          _this2.logError(error.message);\n          _this2.rejectRequests(error);\n          yield _this2.disconnect();\n          reject(error);\n        });\n        return function onTimeout() {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      this.logDebug(`Connecting`, {\n        ssl: !!this.ssl,\n        sasl: !!this.sasl\n      });\n      try {\n        timeoutId = setTimeout(onTimeout, this.connectionTimeout);\n        this.socket = createSocket({\n          socketFactory: this.socketFactory,\n          host: this.host,\n          port: this.port,\n          ssl: this.ssl,\n          onConnect,\n          onData,\n          onEnd,\n          onError,\n          onTimeout\n        });\n      } catch (e) {\n        clearTimeout(timeoutId);\n        reject(new KafkaJSConnectionError(`Failed to connect: ${e.message}`, {\n          broker: `${this.host}:${this.port}`\n        }));\n      }\n    });\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  disconnect() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.authenticatedAt = null;\n      _this3.connectionStatus = CONNECTION_STATUS.DISCONNECTING;\n      _this3.logDebug('disconnecting...');\n      yield _this3.requestQueue.waitForPendingRequests();\n      _this3.requestQueue.destroy();\n      if (_this3.socket) {\n        _this3.socket.end();\n        _this3.socket.unref();\n      }\n      _this3.connectionStatus = CONNECTION_STATUS.DISCONNECTED;\n      _this3.logDebug('disconnected');\n      return true;\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isAuthenticated() {\n    return this.authenticatedAt != null && !this[PRIVATE.SHOULD_REAUTHENTICATE]();\n  }\n\n  /***\n   * @private\n   */\n  [PRIVATE.SHOULD_REAUTHENTICATE]() {\n    if (this.sessionLifetime.equals(Long.ZERO)) {\n      return false;\n    }\n    if (this.authenticatedAt == null) {\n      return true;\n    }\n    const [secondsSince, remainingNanosSince] = process.hrtime(this.authenticatedAt);\n    const millisSince = Long.fromValue(secondsSince).multiply(1000).add(Long.fromValue(remainingNanosSince).divide(1000000));\n    const reauthenticateAt = millisSince.add(this.reauthenticationThreshold);\n    return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime);\n  }\n\n  /** @public */\n  authenticate() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4[PRIVATE.AUTHENTICATE]();\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  sendAuthRequest({\n    request,\n    response\n  }) {\n    var _this5 = this;\n    this.authExpectResponse = !!response;\n\n    /**\n     * TODO: rewrite removing the async promise executor\n     */\n\n    /* eslint-disable no-async-promise-executor */\n    return new Promise( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (resolve, reject) {\n        _this5.authHandlers = {\n          onSuccess: rawData => {\n            _this5.authHandlers = null;\n            _this5.authExpectResponse = false;\n            response.decode(rawData).then(data => response.parse(data)).then(resolve).catch(reject);\n          },\n          onError: () => {\n            _this5.authHandlers = null;\n            _this5.authExpectResponse = false;\n            reject(new KafkaJSConnectionError('Connection closed by the server', {\n              broker: `${_this5.host}:${_this5.port}`\n            }));\n          }\n        };\n        try {\n          const requestPayload = yield request.encode();\n          _this5.failIfNotConnected();\n          _this5.socket.write(requestPayload, 'binary');\n        } catch (e) {\n          reject(e);\n        }\n      });\n      return function (_x2, _x3) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n  }\n\n  /**\n   * @public\n   * @param {object} protocol\n   * @param {object} protocol.request It is defined by the protocol and consists of an object with \"apiKey\",\n   *                         \"apiVersion\", \"apiName\" and an \"encode\" function. The encode function\n   *                         must return an instance of Encoder\n   *\n   * @param {object} protocol.response It is defined by the protocol and consists of an object with two functions:\n   *                          \"decode\" and \"parse\"\n   *\n   * @param {number} [protocol.requestTimeout=null] Override for the default requestTimeout\n   * @param {boolean} [protocol.logResponseError=true] Whether to log errors\n   * @returns {Promise<data>} where data is the return of \"response#parse\"\n   */\n  send({\n    request,\n    response,\n    requestTimeout = null,\n    logResponseError = true\n  }) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this6.isAuthenticated() && isAuthenticatedRequest(request)) {\n        yield _this6[PRIVATE.AUTHENTICATE]();\n      }\n      _this6.failIfNotConnected();\n      const expectResponse = !request.expectResponse || request.expectResponse();\n      const sendRequest = /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* () {\n          const {\n            clientId\n          } = _this6;\n          const correlationId = _this6.nextCorrelationId();\n          const requestPayload = yield createRequest({\n            request,\n            correlationId,\n            clientId\n          });\n          const {\n            apiKey,\n            apiName,\n            apiVersion\n          } = request;\n          _this6.logDebug(`Request ${requestInfo(request)}`, {\n            correlationId,\n            expectResponse,\n            size: Buffer.byteLength(requestPayload.buffer)\n          });\n          return new Promise((resolve, reject) => {\n            try {\n              _this6.failIfNotConnected();\n              const entry = {\n                apiKey,\n                apiName,\n                apiVersion,\n                correlationId,\n                resolve,\n                reject\n              };\n              _this6.requestQueue.push({\n                entry,\n                expectResponse,\n                requestTimeout,\n                sendRequest: () => {\n                  _this6.socket.write(requestPayload.buffer, 'binary');\n                }\n              });\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n        return function sendRequest() {\n          return _ref6.apply(this, arguments);\n        };\n      }();\n      const {\n        correlationId,\n        size,\n        entry,\n        payload\n      } = yield sendRequest();\n      if (!expectResponse) {\n        return;\n      }\n      try {\n        const payloadDecoded = yield response.decode(payload);\n\n        /**\n         * @see KIP-219\n         * If the response indicates that the client-side needs to throttle, do that.\n         */\n        _this6.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime);\n        const data = yield response.parse(payloadDecoded);\n        const isFetchApi = entry.apiName === 'Fetch';\n        _this6.logDebug(`Response ${requestInfo(entry)}`, {\n          correlationId,\n          size,\n          data: isFetchApi && !_this6.shouldLogFetchBuffer ? '[filtered]' : data\n        });\n        return data;\n      } catch (e) {\n        if (logResponseError) {\n          _this6.logError(`Response ${requestInfo(entry)}`, {\n            error: e.message,\n            correlationId,\n            size\n          });\n        }\n        const isBuffer = Buffer.isBuffer(payload);\n        _this6.logDebug(`Response ${requestInfo(entry)}`, {\n          error: e.message,\n          correlationId,\n          payload: isBuffer && !_this6.shouldLogBuffers ? {\n            type: 'Buffer',\n            data: '[filtered]'\n          } : payload\n        });\n        throw e;\n      }\n    })();\n  }\n\n  /**\n   * @private\n   */\n  failIfNotConnected() {\n    if (!this.isConnected()) {\n      throw new KafkaJSConnectionError('Not connected', {\n        broker: `${this.host}:${this.port}`\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  nextCorrelationId() {\n    if (this.correlationId >= INT_32_MAX_VALUE) {\n      this.correlationId = 0;\n    }\n    return this.correlationId++;\n  }\n\n  /**\n   * @private\n   */\n  processData(rawData) {\n    if (this.authHandlers && !this.authExpectResponse) {\n      return this.authHandlers.onSuccess(rawData);\n    }\n\n    // Accumulate the new chunk\n    this.chunks.push(rawData);\n    this.bytesBuffered += Buffer.byteLength(rawData);\n\n    // Process data if there are enough bytes to read the expected response size,\n    // otherwise keep buffering\n    while (this.bytesNeeded <= this.bytesBuffered) {\n      const buffer = this.chunks.length > 1 ? Buffer.concat(this.chunks) : this.chunks[0];\n      const decoder = new Decoder(buffer);\n      const expectedResponseSize = decoder.readInt32();\n\n      // Return early if not enough bytes to read the full response\n      if (!decoder.canReadBytes(expectedResponseSize)) {\n        this.chunks = [buffer];\n        this.bytesBuffered = Buffer.byteLength(buffer);\n        this.bytesNeeded = Decoder.int32Size() + expectedResponseSize;\n        return;\n      }\n      const response = new Decoder(decoder.readBytes(expectedResponseSize));\n\n      // Reset the buffered chunks as the rest of the bytes\n      const remainderBuffer = decoder.readAll();\n      this.chunks = [remainderBuffer];\n      this.bytesBuffered = Buffer.byteLength(remainderBuffer);\n      this.bytesNeeded = Decoder.int32Size();\n      if (this.authHandlers) {\n        const rawResponseSize = Decoder.int32Size() + expectedResponseSize;\n        const rawResponseBuffer = buffer.slice(0, rawResponseSize);\n        return this.authHandlers.onSuccess(rawResponseBuffer);\n      }\n      const correlationId = response.readInt32();\n      const payload = response.readAll();\n      this.requestQueue.fulfillRequest({\n        size: expectedResponseSize,\n        correlationId,\n        payload\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  rejectRequests(error) {\n    this.requestQueue.rejectAll(error);\n  }\n};","map":{"version":3,"names":["createSocket","require","createRequest","Decoder","KafkaJSConnectionError","KafkaJSConnectionClosedError","INT_32_MAX_VALUE","getEnv","RequestQueue","CONNECTION_STATUS","CONNECTED_STATUS","sharedPromiseTo","Long","SASLAuthenticator","apiKeys","requestInfo","apiName","apiKey","apiVersion","isAuthenticatedRequest","request","ApiVersions","SaslHandshake","SaslAuthenticate","includes","PRIVATE","SHOULD_REAUTHENTICATE","Symbol","AUTHENTICATE","module","exports","Connection","constructor","host","port","logger","socketFactory","requestTimeout","reauthenticationThreshold","rack","ssl","sasl","clientId","connectionTimeout","enforceRequestTimeout","maxInFlightRequests","instrumentationEmitter","broker","namespace","bytesBuffered","bytesNeeded","int32Size","chunks","connectionStatus","DISCONNECTED","correlationId","requestQueue","isConnected","versions","authHandlers","authExpectResponse","log","level","message","extra","logFn","logDebug","logError","env","shouldLogBuffers","KAFKAJS_DEBUG_PROTOCOL_BUFFERS","shouldLogFetchBuffer","KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS","authenticatedAt","sessionLifetime","ZERO","supportAuthenticationProtocol","isAuthenticated","authenticator","authenticate","process","hrtime","fromValue","getSupportAuthenticationProtocol","setSupportAuthenticationProtocol","isSupported","setVersions","connect","Promise","resolve","reject","timeoutId","onConnect","clearTimeout","CONNECTED","scheduleRequestTimeoutCheck","onData","data","processData","onEnd","wasConnected","onError","rejectRequests","disconnect","e","error","code","stack","onTimeout","setTimeout","socket","DISCONNECTING","waitForPendingRequests","destroy","end","unref","equals","secondsSince","remainingNanosSince","millisSince","multiply","add","divide","reauthenticateAt","greaterThanOrEqual","sendAuthRequest","response","onSuccess","rawData","decode","then","parse","catch","requestPayload","encode","failIfNotConnected","write","send","logResponseError","expectResponse","sendRequest","nextCorrelationId","size","Buffer","byteLength","buffer","entry","push","payload","payloadDecoded","maybeThrottle","clientSideThrottleTime","isFetchApi","isBuffer","type","length","concat","decoder","expectedResponseSize","readInt32","canReadBytes","readBytes","remainderBuffer","readAll","rawResponseSize","rawResponseBuffer","slice","fulfillRequest","rejectAll"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/network/connection.js"],"sourcesContent":["const createSocket = require('./socket')\nconst createRequest = require('../protocol/request')\nconst Decoder = require('../protocol/decoder')\nconst { KafkaJSConnectionError, KafkaJSConnectionClosedError } = require('../errors')\nconst { INT_32_MAX_VALUE } = require('../constants')\nconst getEnv = require('../env')\nconst RequestQueue = require('./requestQueue')\nconst { CONNECTION_STATUS, CONNECTED_STATUS } = require('./connectionStatus')\nconst sharedPromiseTo = require('../utils/sharedPromiseTo')\nconst Long = require('../utils/long')\nconst SASLAuthenticator = require('../broker/saslAuthenticator')\nconst apiKeys = require('../protocol/requests/apiKeys')\n\nconst requestInfo = ({ apiName, apiKey, apiVersion }) =>\n  `${apiName}(key: ${apiKey}, version: ${apiVersion})`\n\n/**\n * @param request - request from protocol\n * @returns {boolean}\n */\nconst isAuthenticatedRequest = request => {\n  return ![apiKeys.ApiVersions, apiKeys.SaslHandshake, apiKeys.SaslAuthenticate].includes(\n    request.apiKey\n  )\n}\n\nconst PRIVATE = {\n  SHOULD_REAUTHENTICATE: Symbol('private:Connection:shouldReauthenticate'),\n  AUTHENTICATE: Symbol('private:Connection:authenticate'),\n}\n\nmodule.exports = class Connection {\n  /**\n   * @param {Object} options\n   * @param {string} options.host\n   * @param {number} options.port\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").ISocketFactory} options.socketFactory\n   * @param {string} [options.clientId='kafkajs']\n   * @param {number} options.requestTimeout The maximum amount of time the client will wait for the response of a request,\n   *                                in milliseconds\n   * @param {string} [options.rack=null]\n   * @param {Object} [options.ssl=null] Options for the TLS Secure Context. It accepts all options,\n   *                            usually \"cert\", \"key\" and \"ca\". More information at\n   *                            https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n   * @param {Object} [options.sasl=null] Attributes used for SASL authentication. Options based on the\n   *                             key \"mechanism\". Connection is not actively using the SASL attributes\n   *                             but acting as a data object for this information\n   * @param {number} [options.reauthenticationThreshold=10000]\n   * @param {number} options.connectionTimeout The connection timeout, in milliseconds\n   * @param {boolean} [options.enforceRequestTimeout]\n   * @param {number} [options.maxInFlightRequests=null] The maximum number of unacknowledged requests on a connection before\n   *                                            enqueuing\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    host,\n    port,\n    logger,\n    socketFactory,\n    requestTimeout,\n    reauthenticationThreshold = 10000,\n    rack = null,\n    ssl = null,\n    sasl = null,\n    clientId = 'kafkajs',\n    connectionTimeout,\n    enforceRequestTimeout = true,\n    maxInFlightRequests = null,\n    instrumentationEmitter = null,\n  }) {\n    this.host = host\n    this.port = port\n    this.rack = rack\n    this.clientId = clientId\n    this.broker = `${this.host}:${this.port}`\n    this.logger = logger.namespace('Connection')\n\n    this.socketFactory = socketFactory\n    this.ssl = ssl\n    this.sasl = sasl\n\n    this.requestTimeout = requestTimeout\n    this.connectionTimeout = connectionTimeout\n    this.reauthenticationThreshold = reauthenticationThreshold\n\n    this.bytesBuffered = 0\n    this.bytesNeeded = Decoder.int32Size()\n    this.chunks = []\n\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED\n    this.correlationId = 0\n    this.requestQueue = new RequestQueue({\n      instrumentationEmitter,\n      maxInFlightRequests,\n      requestTimeout,\n      enforceRequestTimeout,\n      clientId,\n      broker: this.broker,\n      logger: logger.namespace('RequestQueue'),\n      isConnected: () => this.isConnected(),\n    })\n\n    this.versions = null\n\n    this.authHandlers = null\n    this.authExpectResponse = false\n\n    const log = level => (message, extra = {}) => {\n      const logFn = this.logger[level]\n      logFn(message, { broker: this.broker, clientId, ...extra })\n    }\n\n    this.logDebug = log('debug')\n    this.logError = log('error')\n\n    const env = getEnv()\n    this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === '1'\n    this.shouldLogFetchBuffer =\n      this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === '1'\n\n    this.authenticatedAt = null\n    this.sessionLifetime = Long.ZERO\n    this.supportAuthenticationProtocol = null\n\n    /**\n     * @private\n     * @returns {Promise}\n     */\n    this[PRIVATE.AUTHENTICATE] = sharedPromiseTo(async () => {\n      if (this.sasl && !this.isAuthenticated()) {\n        const authenticator = new SASLAuthenticator(\n          this,\n          this.logger,\n          this.versions,\n          this.supportAuthenticationProtocol\n        )\n\n        await authenticator.authenticate()\n        this.authenticatedAt = process.hrtime()\n        this.sessionLifetime = Long.fromValue(authenticator.sessionLifetime)\n      }\n    })\n  }\n\n  getSupportAuthenticationProtocol() {\n    return this.supportAuthenticationProtocol\n  }\n\n  setSupportAuthenticationProtocol(isSupported) {\n    this.supportAuthenticationProtocol = isSupported\n  }\n\n  setVersions(versions) {\n    this.versions = versions\n  }\n\n  isConnected() {\n    return CONNECTED_STATUS.includes(this.connectionStatus)\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.isConnected()) {\n        return resolve(true)\n      }\n\n      this.authenticatedAt = null\n\n      let timeoutId\n\n      const onConnect = () => {\n        clearTimeout(timeoutId)\n        this.connectionStatus = CONNECTION_STATUS.CONNECTED\n        this.requestQueue.scheduleRequestTimeoutCheck()\n        resolve(true)\n      }\n\n      const onData = data => {\n        this.processData(data)\n      }\n\n      const onEnd = async () => {\n        clearTimeout(timeoutId)\n\n        const wasConnected = this.isConnected()\n\n        if (this.authHandlers) {\n          this.authHandlers.onError()\n        } else if (wasConnected) {\n          this.logDebug('Kafka server has closed connection')\n          this.rejectRequests(\n            new KafkaJSConnectionClosedError('Closed connection', {\n              host: this.host,\n              port: this.port,\n            })\n          )\n        }\n\n        await this.disconnect()\n      }\n\n      const onError = async e => {\n        clearTimeout(timeoutId)\n\n        const error = new KafkaJSConnectionError(`Connection error: ${e.message}`, {\n          broker: `${this.host}:${this.port}`,\n          code: e.code,\n        })\n\n        this.logError(error.message, { stack: e.stack })\n        this.rejectRequests(error)\n        await this.disconnect()\n\n        reject(error)\n      }\n\n      const onTimeout = async () => {\n        const error = new KafkaJSConnectionError('Connection timeout', {\n          broker: `${this.host}:${this.port}`,\n        })\n\n        this.logError(error.message)\n        this.rejectRequests(error)\n        await this.disconnect()\n        reject(error)\n      }\n\n      this.logDebug(`Connecting`, {\n        ssl: !!this.ssl,\n        sasl: !!this.sasl,\n      })\n\n      try {\n        timeoutId = setTimeout(onTimeout, this.connectionTimeout)\n        this.socket = createSocket({\n          socketFactory: this.socketFactory,\n          host: this.host,\n          port: this.port,\n          ssl: this.ssl,\n          onConnect,\n          onData,\n          onEnd,\n          onError,\n          onTimeout,\n        })\n      } catch (e) {\n        clearTimeout(timeoutId)\n        reject(\n          new KafkaJSConnectionError(`Failed to connect: ${e.message}`, {\n            broker: `${this.host}:${this.port}`,\n          })\n        )\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    this.authenticatedAt = null\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTING\n    this.logDebug('disconnecting...')\n\n    await this.requestQueue.waitForPendingRequests()\n    this.requestQueue.destroy()\n\n    if (this.socket) {\n      this.socket.end()\n      this.socket.unref()\n    }\n\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED\n    this.logDebug('disconnected')\n    return true\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isAuthenticated() {\n    return this.authenticatedAt != null && !this[PRIVATE.SHOULD_REAUTHENTICATE]()\n  }\n\n  /***\n   * @private\n   */\n  [PRIVATE.SHOULD_REAUTHENTICATE]() {\n    if (this.sessionLifetime.equals(Long.ZERO)) {\n      return false\n    }\n\n    if (this.authenticatedAt == null) {\n      return true\n    }\n\n    const [secondsSince, remainingNanosSince] = process.hrtime(this.authenticatedAt)\n    const millisSince = Long.fromValue(secondsSince)\n      .multiply(1000)\n      .add(Long.fromValue(remainingNanosSince).divide(1000000))\n\n    const reauthenticateAt = millisSince.add(this.reauthenticationThreshold)\n    return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime)\n  }\n\n  /** @public */\n  async authenticate() {\n    await this[PRIVATE.AUTHENTICATE]()\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  sendAuthRequest({ request, response }) {\n    this.authExpectResponse = !!response\n\n    /**\n     * TODO: rewrite removing the async promise executor\n     */\n\n    /* eslint-disable no-async-promise-executor */\n    return new Promise(async (resolve, reject) => {\n      this.authHandlers = {\n        onSuccess: rawData => {\n          this.authHandlers = null\n          this.authExpectResponse = false\n\n          response\n            .decode(rawData)\n            .then(data => response.parse(data))\n            .then(resolve)\n            .catch(reject)\n        },\n        onError: () => {\n          this.authHandlers = null\n          this.authExpectResponse = false\n\n          reject(\n            new KafkaJSConnectionError('Connection closed by the server', {\n              broker: `${this.host}:${this.port}`,\n            })\n          )\n        },\n      }\n\n      try {\n        const requestPayload = await request.encode()\n\n        this.failIfNotConnected()\n        this.socket.write(requestPayload, 'binary')\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {object} protocol\n   * @param {object} protocol.request It is defined by the protocol and consists of an object with \"apiKey\",\n   *                         \"apiVersion\", \"apiName\" and an \"encode\" function. The encode function\n   *                         must return an instance of Encoder\n   *\n   * @param {object} protocol.response It is defined by the protocol and consists of an object with two functions:\n   *                          \"decode\" and \"parse\"\n   *\n   * @param {number} [protocol.requestTimeout=null] Override for the default requestTimeout\n   * @param {boolean} [protocol.logResponseError=true] Whether to log errors\n   * @returns {Promise<data>} where data is the return of \"response#parse\"\n   */\n  async send({ request, response, requestTimeout = null, logResponseError = true }) {\n    if (!this.isAuthenticated() && isAuthenticatedRequest(request)) {\n      await this[PRIVATE.AUTHENTICATE]()\n    }\n\n    this.failIfNotConnected()\n\n    const expectResponse = !request.expectResponse || request.expectResponse()\n    const sendRequest = async () => {\n      const { clientId } = this\n      const correlationId = this.nextCorrelationId()\n\n      const requestPayload = await createRequest({ request, correlationId, clientId })\n      const { apiKey, apiName, apiVersion } = request\n      this.logDebug(`Request ${requestInfo(request)}`, {\n        correlationId,\n        expectResponse,\n        size: Buffer.byteLength(requestPayload.buffer),\n      })\n\n      return new Promise((resolve, reject) => {\n        try {\n          this.failIfNotConnected()\n          const entry = { apiKey, apiName, apiVersion, correlationId, resolve, reject }\n\n          this.requestQueue.push({\n            entry,\n            expectResponse,\n            requestTimeout,\n            sendRequest: () => {\n              this.socket.write(requestPayload.buffer, 'binary')\n            },\n          })\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }\n\n    const { correlationId, size, entry, payload } = await sendRequest()\n\n    if (!expectResponse) {\n      return\n    }\n\n    try {\n      const payloadDecoded = await response.decode(payload)\n\n      /**\n       * @see KIP-219\n       * If the response indicates that the client-side needs to throttle, do that.\n       */\n      this.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime)\n\n      const data = await response.parse(payloadDecoded)\n      const isFetchApi = entry.apiName === 'Fetch'\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        correlationId,\n        size,\n        data: isFetchApi && !this.shouldLogFetchBuffer ? '[filtered]' : data,\n      })\n\n      return data\n    } catch (e) {\n      if (logResponseError) {\n        this.logError(`Response ${requestInfo(entry)}`, {\n          error: e.message,\n          correlationId,\n          size,\n        })\n      }\n\n      const isBuffer = Buffer.isBuffer(payload)\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        error: e.message,\n        correlationId,\n        payload:\n          isBuffer && !this.shouldLogBuffers ? { type: 'Buffer', data: '[filtered]' } : payload,\n      })\n\n      throw e\n    }\n  }\n\n  /**\n   * @private\n   */\n  failIfNotConnected() {\n    if (!this.isConnected()) {\n      throw new KafkaJSConnectionError('Not connected', {\n        broker: `${this.host}:${this.port}`,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  nextCorrelationId() {\n    if (this.correlationId >= INT_32_MAX_VALUE) {\n      this.correlationId = 0\n    }\n\n    return this.correlationId++\n  }\n\n  /**\n   * @private\n   */\n  processData(rawData) {\n    if (this.authHandlers && !this.authExpectResponse) {\n      return this.authHandlers.onSuccess(rawData)\n    }\n\n    // Accumulate the new chunk\n    this.chunks.push(rawData)\n    this.bytesBuffered += Buffer.byteLength(rawData)\n\n    // Process data if there are enough bytes to read the expected response size,\n    // otherwise keep buffering\n    while (this.bytesNeeded <= this.bytesBuffered) {\n      const buffer = this.chunks.length > 1 ? Buffer.concat(this.chunks) : this.chunks[0]\n      const decoder = new Decoder(buffer)\n      const expectedResponseSize = decoder.readInt32()\n\n      // Return early if not enough bytes to read the full response\n      if (!decoder.canReadBytes(expectedResponseSize)) {\n        this.chunks = [buffer]\n        this.bytesBuffered = Buffer.byteLength(buffer)\n        this.bytesNeeded = Decoder.int32Size() + expectedResponseSize\n        return\n      }\n\n      const response = new Decoder(decoder.readBytes(expectedResponseSize))\n\n      // Reset the buffered chunks as the rest of the bytes\n      const remainderBuffer = decoder.readAll()\n      this.chunks = [remainderBuffer]\n      this.bytesBuffered = Buffer.byteLength(remainderBuffer)\n      this.bytesNeeded = Decoder.int32Size()\n\n      if (this.authHandlers) {\n        const rawResponseSize = Decoder.int32Size() + expectedResponseSize\n        const rawResponseBuffer = buffer.slice(0, rawResponseSize)\n        return this.authHandlers.onSuccess(rawResponseBuffer)\n      }\n\n      const correlationId = response.readInt32()\n      const payload = response.readAll()\n\n      this.requestQueue.fulfillRequest({\n        size: expectedResponseSize,\n        correlationId,\n        payload,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  rejectRequests(error) {\n    this.requestQueue.rejectAll(error)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}