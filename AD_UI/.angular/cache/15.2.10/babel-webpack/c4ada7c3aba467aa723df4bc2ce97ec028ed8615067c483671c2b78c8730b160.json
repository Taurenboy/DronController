{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Broker = require('../broker');\nconst createRetry = require('../retry');\nconst shuffle = require('../utils/shuffle');\nconst arrayDiff = require('../utils/arrayDiff');\nconst {\n  KafkaJSBrokerNotFound,\n  KafkaJSProtocolError\n} = require('../errors');\nconst {\n  keys,\n  assign,\n  values\n} = Object;\nconst hasBrokerBeenReplaced = (broker, {\n  host,\n  port,\n  rack\n}) => broker.connectionPool.host !== host || broker.connectionPool.port !== port || broker.connectionPool.rack !== rack;\nmodule.exports = class BrokerPool {\n  /**\n   * @param {object} options\n   * @param {import(\"./connectionPoolBuilder\").ConnectionPoolBuilder} options.connectionPoolBuilder\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").RetryOptions} [options.retry]\n   * @param {boolean} [options.allowAutoTopicCreation]\n   * @param {number} [options.authenticationTimeout]\n   * @param {number} [options.metadataMaxAge]\n   */\n  constructor({\n    connectionPoolBuilder,\n    logger,\n    retry,\n    allowAutoTopicCreation,\n    authenticationTimeout,\n    metadataMaxAge\n  }) {\n    this.rootLogger = logger;\n    this.connectionPoolBuilder = connectionPoolBuilder;\n    this.metadataMaxAge = metadataMaxAge || 0;\n    this.logger = logger.namespace('BrokerPool');\n    this.retrier = createRetry(assign({}, retry));\n    this.createBroker = options => new Broker({\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      ...options\n    });\n    this.brokers = {};\n    /** @type {Broker | undefined} */\n    this.seedBroker = undefined;\n    /** @type {import(\"../../types\").BrokerMetadata | null} */\n    this.metadata = null;\n    this.metadataExpireAt = null;\n    this.versions = null;\n  }\n\n  /**\n   * @public\n   * @returns {Boolean}\n   */\n  hasConnectedBrokers() {\n    const brokers = values(this.brokers);\n    return !!brokers.find(broker => broker.isConnected()) || (this.seedBroker ? this.seedBroker.isConnected() : false);\n  }\n  createSeedBroker() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.seedBroker) {\n        yield _this.seedBroker.disconnect();\n      }\n      const connectionPool = yield _this.connectionPoolBuilder.build();\n      _this.seedBroker = _this.createBroker({\n        connectionPool,\n        logger: _this.rootLogger\n      });\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  connect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.hasConnectedBrokers()) {\n        return;\n      }\n      if (!_this2.seedBroker) {\n        yield _this2.createSeedBroker();\n      }\n      return _this2.retrier( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield _this2.seedBroker.connect();\n            _this2.versions = _this2.seedBroker.versions;\n          } catch (e) {\n            if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n              // Connection builder will always rotate the seed broker\n              yield _this2.createSeedBroker();\n              _this2.logger.error(`Failed to connect to seed broker, trying another broker from the list: ${e.message}`, {\n                retryCount,\n                retryTime\n              });\n            } else {\n              _this2.logger.error(e.message, {\n                retryCount,\n                retryTime\n              });\n            }\n            if (e.retriable) throw e;\n            bail(e);\n          }\n        });\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  disconnect() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.seedBroker && (yield _this3.seedBroker.disconnect());\n      yield Promise.all(values(_this3.brokers).map(broker => broker.disconnect()));\n      _this3.brokers = {};\n      _this3.metadata = null;\n      _this3.versions = null;\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} destination\n   * @param {string} destination.host\n   * @param {number} destination.port\n   */\n  removeBroker({\n    host,\n    port\n  }) {\n    const removedBroker = values(this.brokers).find(broker => broker.connectionPool.host === host && broker.connectionPool.port === port);\n    if (removedBroker) {\n      delete this.brokers[removedBroker.nodeId];\n      this.metadataExpireAt = null;\n      if (this.seedBroker.nodeId === removedBroker.nodeId) {\n        this.seedBroker = shuffle(values(this.brokers))[0];\n      }\n    }\n  }\n\n  /**\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  refreshMetadata(topics) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const broker = yield _this4.findConnectedBroker();\n      const {\n        host: seedHost,\n        port: seedPort\n      } = _this4.seedBroker.connectionPool;\n      return _this4.retrier( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            _this4.metadata = yield broker.metadata(topics);\n            _this4.metadataExpireAt = Date.now() + _this4.metadataMaxAge;\n            const replacedBrokers = [];\n            _this4.brokers = yield _this4.metadata.brokers.reduce( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator(function* (resultPromise, {\n                nodeId,\n                host,\n                port,\n                rack\n              }) {\n                const result = yield resultPromise;\n                if (result[nodeId]) {\n                  if (!hasBrokerBeenReplaced(result[nodeId], {\n                    host,\n                    port,\n                    rack\n                  })) {\n                    return result;\n                  }\n                  replacedBrokers.push(result[nodeId]);\n                }\n                if (host === seedHost && port === seedPort) {\n                  _this4.seedBroker.nodeId = nodeId;\n                  _this4.seedBroker.connectionPool.rack = rack;\n                  return assign(result, {\n                    [nodeId]: _this4.seedBroker\n                  });\n                }\n                return assign(result, {\n                  [nodeId]: _this4.createBroker({\n                    logger: _this4.rootLogger,\n                    versions: _this4.versions,\n                    connectionPool: yield _this4.connectionPoolBuilder.build({\n                      host,\n                      port,\n                      rack\n                    }),\n                    nodeId\n                  })\n                });\n              });\n              return function (_x7, _x8) {\n                return _ref3.apply(this, arguments);\n              };\n            }(), _this4.brokers);\n            const freshBrokerIds = _this4.metadata.brokers.map(({\n              nodeId\n            }) => `${nodeId}`).sort();\n            const currentBrokerIds = keys(_this4.brokers).sort();\n            const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds);\n            const brokerDisconnects = unusedBrokerIds.map(nodeId => {\n              const broker = _this4.brokers[nodeId];\n              return broker.disconnect().then(() => {\n                delete _this4.brokers[nodeId];\n              });\n            });\n            const replacedBrokersDisconnects = replacedBrokers.map(broker => broker.disconnect());\n            yield Promise.all([...brokerDisconnects, ...replacedBrokersDisconnects]);\n          } catch (e) {\n            if (e.type === 'LEADER_NOT_AVAILABLE') {\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x4, _x5, _x6) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  /**\n   * Only refreshes metadata if the data is stale according to the `metadataMaxAge` param or does not contain information about the provided topics\n   *\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  refreshMetadataIfNecessary(topics) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const shouldRefresh = _this5.metadata == null || _this5.metadataExpireAt == null || Date.now() > _this5.metadataExpireAt || !topics.every(topic => _this5.metadata.topicMetadata.some(topicMetadata => topicMetadata.topic === topic));\n      if (shouldRefresh) {\n        return _this5.refreshMetadata(topics);\n      }\n    })();\n  }\n\n  /** @type {() => string[]} */\n  getNodeIds() {\n    return keys(this.brokers);\n  }\n\n  /**\n   * @public\n   * @param {object} options\n   * @param {string} options.nodeId\n   * @returns {Promise<Broker>}\n   */\n  findBroker({\n    nodeId\n  }) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const broker = _this6.brokers[nodeId];\n      if (!broker) {\n        throw new KafkaJSBrokerNotFound(`Broker ${nodeId} not found in the cached metadata`);\n      }\n      yield _this6.connectBroker(broker);\n      return broker;\n    })();\n  }\n\n  /**\n   * @public\n   * @param {(params: { nodeId: string, broker: Broker }) => Promise<T>} callback\n   * @returns {Promise<T>}\n   * @template T\n   */\n  withBroker(callback) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const brokers = shuffle(keys(_this7.brokers));\n      if (brokers.length === 0) {\n        throw new KafkaJSBrokerNotFound('No brokers in the broker pool');\n      }\n      for (const nodeId of brokers) {\n        const broker = yield _this7.findBroker({\n          nodeId\n        });\n        try {\n          return yield callback({\n            nodeId,\n            broker\n          });\n        } catch (e) {}\n      }\n      return null;\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n  findConnectedBroker() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const nodeIds = shuffle(keys(_this8.brokers));\n      const connectedBrokerId = nodeIds.find(nodeId => _this8.brokers[nodeId].isConnected());\n      if (connectedBrokerId) {\n        return yield _this8.findBroker({\n          nodeId: connectedBrokerId\n        });\n      }\n\n      // Cycle through the nodes until one connects\n      for (const nodeId of nodeIds) {\n        try {\n          return yield _this8.findBroker({\n            nodeId\n          });\n        } catch (e) {}\n      }\n\n      // Failed to connect to all known brokers, metadata might be old\n      yield _this8.connect();\n      return _this8.seedBroker;\n    })();\n  }\n\n  /**\n   * @private\n   * @param {Broker} broker\n   * @returns {Promise<null>}\n   */\n  connectBroker(broker) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (broker.isConnected()) {\n        return;\n      }\n      return _this9.retrier( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield broker.connect();\n          } catch (e) {\n            if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n              yield broker.disconnect();\n            }\n\n            // To avoid reconnecting to an unavailable host, we bail on connection errors\n            // and refresh metadata on a higher level before reconnecting\n            if (e.name === 'KafkaJSConnectionError') {\n              return bail(e);\n            }\n            if (e.type === 'ILLEGAL_SASL_STATE') {\n              // Rebuild the connection pool since it can't recover from illegal SASL state\n              broker.connectionPool = yield _this9.connectionPoolBuilder.build({\n                host: broker.connectionPool.host,\n                port: broker.connectionPool.port,\n                rack: broker.connectionPool.rack\n              });\n              _this9.logger.error(`Failed to connect to broker, reconnecting`, {\n                retryCount,\n                retryTime\n              });\n              throw new KafkaJSProtocolError(e, {\n                retriable: true\n              });\n            }\n            if (e.retriable) throw e;\n            _this9.logger.error(e, {\n              retryCount,\n              retryTime,\n              stack: e.stack\n            });\n            bail(e);\n          }\n        });\n        return function (_x9, _x10, _x11) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n};","map":{"version":3,"names":["Broker","require","createRetry","shuffle","arrayDiff","KafkaJSBrokerNotFound","KafkaJSProtocolError","keys","assign","values","Object","hasBrokerBeenReplaced","broker","host","port","rack","connectionPool","module","exports","BrokerPool","constructor","connectionPoolBuilder","logger","retry","allowAutoTopicCreation","authenticationTimeout","metadataMaxAge","rootLogger","namespace","retrier","createBroker","options","brokers","seedBroker","undefined","metadata","metadataExpireAt","versions","hasConnectedBrokers","find","isConnected","createSeedBroker","disconnect","build","connect","bail","retryCount","retryTime","e","name","type","error","message","retriable","Promise","all","map","removeBroker","removedBroker","nodeId","refreshMetadata","topics","findConnectedBroker","seedHost","seedPort","Date","now","replacedBrokers","reduce","resultPromise","result","push","freshBrokerIds","sort","currentBrokerIds","unusedBrokerIds","brokerDisconnects","then","replacedBrokersDisconnects","refreshMetadataIfNecessary","shouldRefresh","every","topic","topicMetadata","some","getNodeIds","findBroker","connectBroker","withBroker","callback","length","nodeIds","connectedBrokerId","stack"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/cluster/brokerPool.js"],"sourcesContent":["const Broker = require('../broker')\nconst createRetry = require('../retry')\nconst shuffle = require('../utils/shuffle')\nconst arrayDiff = require('../utils/arrayDiff')\nconst { KafkaJSBrokerNotFound, KafkaJSProtocolError } = require('../errors')\n\nconst { keys, assign, values } = Object\nconst hasBrokerBeenReplaced = (broker, { host, port, rack }) =>\n  broker.connectionPool.host !== host ||\n  broker.connectionPool.port !== port ||\n  broker.connectionPool.rack !== rack\n\nmodule.exports = class BrokerPool {\n  /**\n   * @param {object} options\n   * @param {import(\"./connectionPoolBuilder\").ConnectionPoolBuilder} options.connectionPoolBuilder\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").RetryOptions} [options.retry]\n   * @param {boolean} [options.allowAutoTopicCreation]\n   * @param {number} [options.authenticationTimeout]\n   * @param {number} [options.metadataMaxAge]\n   */\n  constructor({\n    connectionPoolBuilder,\n    logger,\n    retry,\n    allowAutoTopicCreation,\n    authenticationTimeout,\n    metadataMaxAge,\n  }) {\n    this.rootLogger = logger\n    this.connectionPoolBuilder = connectionPoolBuilder\n    this.metadataMaxAge = metadataMaxAge || 0\n    this.logger = logger.namespace('BrokerPool')\n    this.retrier = createRetry(assign({}, retry))\n\n    this.createBroker = options =>\n      new Broker({\n        allowAutoTopicCreation,\n        authenticationTimeout,\n        ...options,\n      })\n\n    this.brokers = {}\n    /** @type {Broker | undefined} */\n    this.seedBroker = undefined\n    /** @type {import(\"../../types\").BrokerMetadata | null} */\n    this.metadata = null\n    this.metadataExpireAt = null\n    this.versions = null\n  }\n\n  /**\n   * @public\n   * @returns {Boolean}\n   */\n  hasConnectedBrokers() {\n    const brokers = values(this.brokers)\n    return (\n      !!brokers.find(broker => broker.isConnected()) ||\n      (this.seedBroker ? this.seedBroker.isConnected() : false)\n    )\n  }\n\n  async createSeedBroker() {\n    if (this.seedBroker) {\n      await this.seedBroker.disconnect()\n    }\n\n    const connectionPool = await this.connectionPoolBuilder.build()\n\n    this.seedBroker = this.createBroker({\n      connectionPool,\n      logger: this.rootLogger,\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  async connect() {\n    if (this.hasConnectedBrokers()) {\n      return\n    }\n\n    if (!this.seedBroker) {\n      await this.createSeedBroker()\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.seedBroker.connect()\n        this.versions = this.seedBroker.versions\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          // Connection builder will always rotate the seed broker\n          await this.createSeedBroker()\n          this.logger.error(\n            `Failed to connect to seed broker, trying another broker from the list: ${e.message}`,\n            { retryCount, retryTime }\n          )\n        } else {\n          this.logger.error(e.message, { retryCount, retryTime })\n        }\n\n        if (e.retriable) throw e\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    this.seedBroker && (await this.seedBroker.disconnect())\n    await Promise.all(values(this.brokers).map(broker => broker.disconnect()))\n\n    this.brokers = {}\n    this.metadata = null\n    this.versions = null\n  }\n\n  /**\n   * @public\n   * @param {Object} destination\n   * @param {string} destination.host\n   * @param {number} destination.port\n   */\n  removeBroker({ host, port }) {\n    const removedBroker = values(this.brokers).find(\n      broker => broker.connectionPool.host === host && broker.connectionPool.port === port\n    )\n\n    if (removedBroker) {\n      delete this.brokers[removedBroker.nodeId]\n      this.metadataExpireAt = null\n\n      if (this.seedBroker.nodeId === removedBroker.nodeId) {\n        this.seedBroker = shuffle(values(this.brokers))[0]\n      }\n    }\n  }\n\n  /**\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  async refreshMetadata(topics) {\n    const broker = await this.findConnectedBroker()\n    const { host: seedHost, port: seedPort } = this.seedBroker.connectionPool\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        this.metadata = await broker.metadata(topics)\n        this.metadataExpireAt = Date.now() + this.metadataMaxAge\n\n        const replacedBrokers = []\n\n        this.brokers = await this.metadata.brokers.reduce(\n          async (resultPromise, { nodeId, host, port, rack }) => {\n            const result = await resultPromise\n\n            if (result[nodeId]) {\n              if (!hasBrokerBeenReplaced(result[nodeId], { host, port, rack })) {\n                return result\n              }\n\n              replacedBrokers.push(result[nodeId])\n            }\n\n            if (host === seedHost && port === seedPort) {\n              this.seedBroker.nodeId = nodeId\n              this.seedBroker.connectionPool.rack = rack\n              return assign(result, {\n                [nodeId]: this.seedBroker,\n              })\n            }\n\n            return assign(result, {\n              [nodeId]: this.createBroker({\n                logger: this.rootLogger,\n                versions: this.versions,\n                connectionPool: await this.connectionPoolBuilder.build({ host, port, rack }),\n                nodeId,\n              }),\n            })\n          },\n          this.brokers\n        )\n\n        const freshBrokerIds = this.metadata.brokers.map(({ nodeId }) => `${nodeId}`).sort()\n        const currentBrokerIds = keys(this.brokers).sort()\n        const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds)\n\n        const brokerDisconnects = unusedBrokerIds.map(nodeId => {\n          const broker = this.brokers[nodeId]\n          return broker.disconnect().then(() => {\n            delete this.brokers[nodeId]\n          })\n        })\n\n        const replacedBrokersDisconnects = replacedBrokers.map(broker => broker.disconnect())\n        await Promise.all([...brokerDisconnects, ...replacedBrokersDisconnects])\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Only refreshes metadata if the data is stale according to the `metadataMaxAge` param or does not contain information about the provided topics\n   *\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  async refreshMetadataIfNecessary(topics) {\n    const shouldRefresh =\n      this.metadata == null ||\n      this.metadataExpireAt == null ||\n      Date.now() > this.metadataExpireAt ||\n      !topics.every(topic =>\n        this.metadata.topicMetadata.some(topicMetadata => topicMetadata.topic === topic)\n      )\n\n    if (shouldRefresh) {\n      return this.refreshMetadata(topics)\n    }\n  }\n\n  /** @type {() => string[]} */\n  getNodeIds() {\n    return keys(this.brokers)\n  }\n\n  /**\n   * @public\n   * @param {object} options\n   * @param {string} options.nodeId\n   * @returns {Promise<Broker>}\n   */\n  async findBroker({ nodeId }) {\n    const broker = this.brokers[nodeId]\n\n    if (!broker) {\n      throw new KafkaJSBrokerNotFound(`Broker ${nodeId} not found in the cached metadata`)\n    }\n\n    await this.connectBroker(broker)\n    return broker\n  }\n\n  /**\n   * @public\n   * @param {(params: { nodeId: string, broker: Broker }) => Promise<T>} callback\n   * @returns {Promise<T>}\n   * @template T\n   */\n  async withBroker(callback) {\n    const brokers = shuffle(keys(this.brokers))\n    if (brokers.length === 0) {\n      throw new KafkaJSBrokerNotFound('No brokers in the broker pool')\n    }\n\n    for (const nodeId of brokers) {\n      const broker = await this.findBroker({ nodeId })\n      try {\n        return await callback({ nodeId, broker })\n      } catch (e) {}\n    }\n\n    return null\n  }\n\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n  async findConnectedBroker() {\n    const nodeIds = shuffle(keys(this.brokers))\n    const connectedBrokerId = nodeIds.find(nodeId => this.brokers[nodeId].isConnected())\n\n    if (connectedBrokerId) {\n      return await this.findBroker({ nodeId: connectedBrokerId })\n    }\n\n    // Cycle through the nodes until one connects\n    for (const nodeId of nodeIds) {\n      try {\n        return await this.findBroker({ nodeId })\n      } catch (e) {}\n    }\n\n    // Failed to connect to all known brokers, metadata might be old\n    await this.connect()\n    return this.seedBroker\n  }\n\n  /**\n   * @private\n   * @param {Broker} broker\n   * @returns {Promise<null>}\n   */\n  async connectBroker(broker) {\n    if (broker.isConnected()) {\n      return\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await broker.connect()\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          await broker.disconnect()\n        }\n\n        // To avoid reconnecting to an unavailable host, we bail on connection errors\n        // and refresh metadata on a higher level before reconnecting\n        if (e.name === 'KafkaJSConnectionError') {\n          return bail(e)\n        }\n\n        if (e.type === 'ILLEGAL_SASL_STATE') {\n          // Rebuild the connection pool since it can't recover from illegal SASL state\n          broker.connectionPool = await this.connectionPoolBuilder.build({\n            host: broker.connectionPool.host,\n            port: broker.connectionPool.port,\n            rack: broker.connectionPool.rack,\n          })\n\n          this.logger.error(`Failed to connect to broker, reconnecting`, { retryCount, retryTime })\n          throw new KafkaJSProtocolError(e, { retriable: true })\n        }\n\n        if (e.retriable) throw e\n        this.logger.error(e, { retryCount, retryTime, stack: e.stack })\n        bail(e)\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}