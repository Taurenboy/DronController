{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\nconst SocketRequest = require('./socketRequest');\nconst events = require('../instrumentationEvents');\nconst {\n  KafkaJSInvariantViolation\n} = require('../../errors');\nconst PRIVATE = {\n  EMIT_QUEUE_SIZE_EVENT: Symbol('private:RequestQueue:emitQueueSizeEvent'),\n  EMIT_REQUEST_QUEUE_EMPTY: Symbol('private:RequestQueue:emitQueueEmpty')\n};\nconst REQUEST_QUEUE_EMPTY = 'requestQueueEmpty';\nconst CHECK_PENDING_REQUESTS_INTERVAL = 10;\nmodule.exports = class RequestQueue extends EventEmitter {\n  /**\n   * @param {Object} options\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.requestTimeout\n   * @param {boolean} options.enforceRequestTimeout\n   * @param {string} options.clientId\n   * @param {string} options.broker\n   * @param {import(\"../../../types\").Logger} options.logger\n   * @param {import(\"../../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   * @param {() => boolean} [options.isConnected]\n   */\n  constructor({\n    instrumentationEmitter = null,\n    maxInFlightRequests,\n    requestTimeout,\n    enforceRequestTimeout,\n    clientId,\n    broker,\n    logger,\n    isConnected = () => true\n  }) {\n    super();\n    this.instrumentationEmitter = instrumentationEmitter;\n    this.maxInFlightRequests = maxInFlightRequests;\n    this.requestTimeout = requestTimeout;\n    this.enforceRequestTimeout = enforceRequestTimeout;\n    this.clientId = clientId;\n    this.broker = broker;\n    this.logger = logger;\n    this.isConnected = isConnected;\n    this.inflight = new Map();\n    this.pending = [];\n\n    /**\n     * Until when this request queue is throttled and shouldn't send requests\n     *\n     * The value represents the timestamp of the end of the throttling in ms-since-epoch. If the value\n     * is smaller than the current timestamp no throttling is active.\n     *\n     * @type {number}\n     */\n    this.throttledUntil = -1;\n\n    /**\n     * Timeout id if we have scheduled a check for pending requests due to client-side throttling\n     *\n     * @type {null|NodeJS.Timeout}\n     */\n    this.throttleCheckTimeoutId = null;\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY] = () => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        this.emit(REQUEST_QUEUE_EMPTY);\n      }\n    };\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT] = () => {\n      instrumentationEmitter && instrumentationEmitter.emit(events.NETWORK_REQUEST_QUEUE_SIZE, {\n        broker: this.broker,\n        clientId: this.clientId,\n        queueSize: this.pending.length\n      });\n      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();\n    };\n  }\n\n  /**\n   * @public\n   */\n  scheduleRequestTimeoutCheck() {\n    if (this.enforceRequestTimeout) {\n      this.destroy();\n      this.requestTimeoutIntervalId = setInterval(() => {\n        this.inflight.forEach(request => {\n          if (Date.now() - request.sentAt > request.requestTimeout) {\n            request.timeoutRequest();\n          }\n        });\n        if (!this.isConnected()) {\n          this.destroy();\n        }\n      }, Math.min(this.requestTimeout, 100));\n    }\n  }\n  maybeThrottle(clientSideThrottleTime) {\n    if (clientSideThrottleTime !== null && clientSideThrottleTime > 0) {\n      this.logger.debug(`Client side throttling in effect for ${clientSideThrottleTime}ms`);\n      const minimumThrottledUntil = Date.now() + clientSideThrottleTime;\n      this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil);\n    }\n  }\n  createSocketRequest(pushedRequest) {\n    const {\n      correlationId\n    } = pushedRequest.entry;\n    const defaultRequestTimeout = this.requestTimeout;\n    const customRequestTimeout = pushedRequest.requestTimeout;\n\n    // Some protocol requests have custom request timeouts (e.g JoinGroup, Fetch, etc). The custom\n    // timeouts are influenced by user configurations, which can be lower than the default requestTimeout\n    const requestTimeout = Math.max(defaultRequestTimeout, customRequestTimeout || 0);\n    const socketRequest = new SocketRequest({\n      entry: pushedRequest.entry,\n      expectResponse: pushedRequest.expectResponse,\n      broker: this.broker,\n      clientId: this.clientId,\n      instrumentationEmitter: this.instrumentationEmitter,\n      requestTimeout,\n      send: () => {\n        if (this.inflight.has(correlationId)) {\n          throw new KafkaJSInvariantViolation('Correlation id already exists');\n        }\n        this.inflight.set(correlationId, socketRequest);\n        pushedRequest.sendRequest();\n      },\n      timeout: () => {\n        this.inflight.delete(correlationId);\n        this.checkPendingRequests();\n        // Try to emit REQUEST_QUEUE_EMPTY. Otherwise, waitForPendingRequests may stuck forever\n        this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();\n      }\n    });\n    return socketRequest;\n  }\n\n  /**\n   * @typedef {Object} PushedRequest\n   * @property {import(\"./socketRequest\").RequestEntry} entry\n   * @property {boolean} expectResponse\n   * @property {Function} sendRequest\n   * @property {number} [requestTimeout]\n   *\n   * @public\n   * @param {PushedRequest} pushedRequest\n   */\n  push(pushedRequest) {\n    const {\n      correlationId\n    } = pushedRequest.entry;\n    const socketRequest = this.createSocketRequest(pushedRequest);\n    if (this.canSendSocketRequestImmediately()) {\n      this.sendSocketRequest(socketRequest);\n      return;\n    }\n    this.pending.push(socketRequest);\n    this.scheduleCheckPendingRequests();\n    this.logger.debug(`Request enqueued`, {\n      clientId: this.clientId,\n      broker: this.broker,\n      correlationId\n    });\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n  }\n\n  /**\n   * @param {SocketRequest} socketRequest\n   */\n  sendSocketRequest(socketRequest) {\n    socketRequest.send();\n    if (!socketRequest.expectResponse) {\n      this.logger.debug(`Request does not expect a response, resolving immediately`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: socketRequest.correlationId\n      });\n      this.inflight.delete(socketRequest.correlationId);\n      socketRequest.completed({\n        size: 0,\n        payload: null\n      });\n    }\n  }\n\n  /**\n   * @public\n   * @param {object} response\n   * @param {number} response.correlationId\n   * @param {Buffer} response.payload\n   * @param {number} response.size\n   */\n  fulfillRequest({\n    correlationId,\n    payload,\n    size\n  }) {\n    const socketRequest = this.inflight.get(correlationId);\n    this.inflight.delete(correlationId);\n    this.checkPendingRequests();\n    if (socketRequest) {\n      socketRequest.completed({\n        size,\n        payload\n      });\n    } else {\n      this.logger.warn(`Response without match`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId\n      });\n    }\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();\n  }\n\n  /**\n   * @public\n   * @param {Error} error\n   */\n  rejectAll(error) {\n    const requests = [...this.inflight.values(), ...this.pending];\n    for (const socketRequest of requests) {\n      socketRequest.rejected(error);\n      this.inflight.delete(socketRequest.correlationId);\n    }\n    this.pending = [];\n    this.inflight.clear();\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n  }\n\n  /**\n   * @public\n   */\n  waitForPendingRequests() {\n    return new Promise(resolve => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        return resolve();\n      }\n      this.logger.debug('Waiting for pending requests', {\n        clientId: this.clientId,\n        broker: this.broker,\n        currentInflightRequests: this.inflight.size,\n        currentPendingQueueSize: this.pending.length\n      });\n      this.once(REQUEST_QUEUE_EMPTY, () => resolve());\n    });\n  }\n\n  /**\n   * @public\n   */\n  destroy() {\n    clearInterval(this.requestTimeoutIntervalId);\n    clearTimeout(this.throttleCheckTimeoutId);\n    this.throttleCheckTimeoutId = null;\n  }\n  canSendSocketRequestImmediately() {\n    const shouldEnqueue = this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests || this.throttledUntil > Date.now();\n    return !shouldEnqueue;\n  }\n\n  /**\n   * Check and process pending requests either now or in the future\n   *\n   * This function will send out as many pending requests as possible taking throttling and\n   * in-flight limits into account.\n   */\n  checkPendingRequests() {\n    while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {\n      const pendingRequest = this.pending.shift(); // first in first out\n      this.sendSocketRequest(pendingRequest);\n      this.logger.debug(`Consumed pending request`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: pendingRequest.correlationId,\n        pendingDuration: pendingRequest.pendingDuration,\n        currentPendingQueueSize: this.pending.length\n      });\n      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n    }\n    this.scheduleCheckPendingRequests();\n  }\n\n  /**\n   * Ensure that pending requests will be checked in the future\n   *\n   * If there is a client-side throttling in place this will ensure that we will check\n   * the pending request queue eventually.\n   */\n  scheduleCheckPendingRequests() {\n    // If we're throttled: Schedule checkPendingRequests when the throttle\n    // should be resolved. If there is already something scheduled we assume that that\n    // will be fine, and potentially fix up a new timeout if needed at that time.\n    // Note that if we're merely \"overloaded\" by having too many inflight requests\n    // we will anyways check the queue when one of them gets fulfilled.\n    let scheduleAt = this.throttledUntil - Date.now();\n    if (!this.throttleCheckTimeoutId) {\n      if (this.pending.length > 0) {\n        scheduleAt = scheduleAt > 0 ? scheduleAt : CHECK_PENDING_REQUESTS_INTERVAL;\n      }\n      this.throttleCheckTimeoutId = setTimeout(() => {\n        this.throttleCheckTimeoutId = null;\n        this.checkPendingRequests();\n      }, scheduleAt);\n    }\n  }\n};","map":{"version":3,"names":["EventEmitter","require","SocketRequest","events","KafkaJSInvariantViolation","PRIVATE","EMIT_QUEUE_SIZE_EVENT","Symbol","EMIT_REQUEST_QUEUE_EMPTY","REQUEST_QUEUE_EMPTY","CHECK_PENDING_REQUESTS_INTERVAL","module","exports","RequestQueue","constructor","instrumentationEmitter","maxInFlightRequests","requestTimeout","enforceRequestTimeout","clientId","broker","logger","isConnected","inflight","Map","pending","throttledUntil","throttleCheckTimeoutId","length","size","emit","NETWORK_REQUEST_QUEUE_SIZE","queueSize","scheduleRequestTimeoutCheck","destroy","requestTimeoutIntervalId","setInterval","forEach","request","Date","now","sentAt","timeoutRequest","Math","min","maybeThrottle","clientSideThrottleTime","debug","minimumThrottledUntil","max","createSocketRequest","pushedRequest","correlationId","entry","defaultRequestTimeout","customRequestTimeout","socketRequest","expectResponse","send","has","set","sendRequest","timeout","delete","checkPendingRequests","push","canSendSocketRequestImmediately","sendSocketRequest","scheduleCheckPendingRequests","completed","payload","fulfillRequest","get","warn","rejectAll","error","requests","values","rejected","clear","waitForPendingRequests","Promise","resolve","currentInflightRequests","currentPendingQueueSize","once","clearInterval","clearTimeout","shouldEnqueue","pendingRequest","shift","pendingDuration","scheduleAt","setTimeout"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/network/requestQueue/index.js"],"sourcesContent":["const { EventEmitter } = require('events')\nconst SocketRequest = require('./socketRequest')\nconst events = require('../instrumentationEvents')\nconst { KafkaJSInvariantViolation } = require('../../errors')\n\nconst PRIVATE = {\n  EMIT_QUEUE_SIZE_EVENT: Symbol('private:RequestQueue:emitQueueSizeEvent'),\n  EMIT_REQUEST_QUEUE_EMPTY: Symbol('private:RequestQueue:emitQueueEmpty'),\n}\n\nconst REQUEST_QUEUE_EMPTY = 'requestQueueEmpty'\nconst CHECK_PENDING_REQUESTS_INTERVAL = 10\n\nmodule.exports = class RequestQueue extends EventEmitter {\n  /**\n   * @param {Object} options\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.requestTimeout\n   * @param {boolean} options.enforceRequestTimeout\n   * @param {string} options.clientId\n   * @param {string} options.broker\n   * @param {import(\"../../../types\").Logger} options.logger\n   * @param {import(\"../../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   * @param {() => boolean} [options.isConnected]\n   */\n  constructor({\n    instrumentationEmitter = null,\n    maxInFlightRequests,\n    requestTimeout,\n    enforceRequestTimeout,\n    clientId,\n    broker,\n    logger,\n    isConnected = () => true,\n  }) {\n    super()\n    this.instrumentationEmitter = instrumentationEmitter\n    this.maxInFlightRequests = maxInFlightRequests\n    this.requestTimeout = requestTimeout\n    this.enforceRequestTimeout = enforceRequestTimeout\n    this.clientId = clientId\n    this.broker = broker\n    this.logger = logger\n    this.isConnected = isConnected\n\n    this.inflight = new Map()\n    this.pending = []\n\n    /**\n     * Until when this request queue is throttled and shouldn't send requests\n     *\n     * The value represents the timestamp of the end of the throttling in ms-since-epoch. If the value\n     * is smaller than the current timestamp no throttling is active.\n     *\n     * @type {number}\n     */\n    this.throttledUntil = -1\n\n    /**\n     * Timeout id if we have scheduled a check for pending requests due to client-side throttling\n     *\n     * @type {null|NodeJS.Timeout}\n     */\n    this.throttleCheckTimeoutId = null\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY] = () => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        this.emit(REQUEST_QUEUE_EMPTY)\n      }\n    }\n\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT] = () => {\n      instrumentationEmitter &&\n        instrumentationEmitter.emit(events.NETWORK_REQUEST_QUEUE_SIZE, {\n          broker: this.broker,\n          clientId: this.clientId,\n          queueSize: this.pending.length,\n        })\n\n      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]()\n    }\n  }\n\n  /**\n   * @public\n   */\n  scheduleRequestTimeoutCheck() {\n    if (this.enforceRequestTimeout) {\n      this.destroy()\n\n      this.requestTimeoutIntervalId = setInterval(() => {\n        this.inflight.forEach(request => {\n          if (Date.now() - request.sentAt > request.requestTimeout) {\n            request.timeoutRequest()\n          }\n        })\n\n        if (!this.isConnected()) {\n          this.destroy()\n        }\n      }, Math.min(this.requestTimeout, 100))\n    }\n  }\n\n  maybeThrottle(clientSideThrottleTime) {\n    if (clientSideThrottleTime !== null && clientSideThrottleTime > 0) {\n      this.logger.debug(`Client side throttling in effect for ${clientSideThrottleTime}ms`)\n      const minimumThrottledUntil = Date.now() + clientSideThrottleTime\n      this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil)\n    }\n  }\n\n  createSocketRequest(pushedRequest) {\n    const { correlationId } = pushedRequest.entry\n    const defaultRequestTimeout = this.requestTimeout\n    const customRequestTimeout = pushedRequest.requestTimeout\n\n    // Some protocol requests have custom request timeouts (e.g JoinGroup, Fetch, etc). The custom\n    // timeouts are influenced by user configurations, which can be lower than the default requestTimeout\n    const requestTimeout = Math.max(defaultRequestTimeout, customRequestTimeout || 0)\n\n    const socketRequest = new SocketRequest({\n      entry: pushedRequest.entry,\n      expectResponse: pushedRequest.expectResponse,\n      broker: this.broker,\n      clientId: this.clientId,\n      instrumentationEmitter: this.instrumentationEmitter,\n      requestTimeout,\n      send: () => {\n        if (this.inflight.has(correlationId)) {\n          throw new KafkaJSInvariantViolation('Correlation id already exists')\n        }\n        this.inflight.set(correlationId, socketRequest)\n        pushedRequest.sendRequest()\n      },\n      timeout: () => {\n        this.inflight.delete(correlationId)\n        this.checkPendingRequests()\n        // Try to emit REQUEST_QUEUE_EMPTY. Otherwise, waitForPendingRequests may stuck forever\n        this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]()\n      },\n    })\n\n    return socketRequest\n  }\n\n  /**\n   * @typedef {Object} PushedRequest\n   * @property {import(\"./socketRequest\").RequestEntry} entry\n   * @property {boolean} expectResponse\n   * @property {Function} sendRequest\n   * @property {number} [requestTimeout]\n   *\n   * @public\n   * @param {PushedRequest} pushedRequest\n   */\n  push(pushedRequest) {\n    const { correlationId } = pushedRequest.entry\n    const socketRequest = this.createSocketRequest(pushedRequest)\n\n    if (this.canSendSocketRequestImmediately()) {\n      this.sendSocketRequest(socketRequest)\n      return\n    }\n\n    this.pending.push(socketRequest)\n    this.scheduleCheckPendingRequests()\n\n    this.logger.debug(`Request enqueued`, {\n      clientId: this.clientId,\n      broker: this.broker,\n      correlationId,\n    })\n\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n  }\n\n  /**\n   * @param {SocketRequest} socketRequest\n   */\n  sendSocketRequest(socketRequest) {\n    socketRequest.send()\n\n    if (!socketRequest.expectResponse) {\n      this.logger.debug(`Request does not expect a response, resolving immediately`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: socketRequest.correlationId,\n      })\n\n      this.inflight.delete(socketRequest.correlationId)\n      socketRequest.completed({ size: 0, payload: null })\n    }\n  }\n\n  /**\n   * @public\n   * @param {object} response\n   * @param {number} response.correlationId\n   * @param {Buffer} response.payload\n   * @param {number} response.size\n   */\n  fulfillRequest({ correlationId, payload, size }) {\n    const socketRequest = this.inflight.get(correlationId)\n    this.inflight.delete(correlationId)\n    this.checkPendingRequests()\n\n    if (socketRequest) {\n      socketRequest.completed({ size, payload })\n    } else {\n      this.logger.warn(`Response without match`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId,\n      })\n    }\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]()\n  }\n\n  /**\n   * @public\n   * @param {Error} error\n   */\n  rejectAll(error) {\n    const requests = [...this.inflight.values(), ...this.pending]\n\n    for (const socketRequest of requests) {\n      socketRequest.rejected(error)\n      this.inflight.delete(socketRequest.correlationId)\n    }\n\n    this.pending = []\n    this.inflight.clear()\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n  }\n\n  /**\n   * @public\n   */\n  waitForPendingRequests() {\n    return new Promise(resolve => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        return resolve()\n      }\n\n      this.logger.debug('Waiting for pending requests', {\n        clientId: this.clientId,\n        broker: this.broker,\n        currentInflightRequests: this.inflight.size,\n        currentPendingQueueSize: this.pending.length,\n      })\n\n      this.once(REQUEST_QUEUE_EMPTY, () => resolve())\n    })\n  }\n\n  /**\n   * @public\n   */\n  destroy() {\n    clearInterval(this.requestTimeoutIntervalId)\n    clearTimeout(this.throttleCheckTimeoutId)\n    this.throttleCheckTimeoutId = null\n  }\n\n  canSendSocketRequestImmediately() {\n    const shouldEnqueue =\n      (this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests) ||\n      this.throttledUntil > Date.now()\n\n    return !shouldEnqueue\n  }\n\n  /**\n   * Check and process pending requests either now or in the future\n   *\n   * This function will send out as many pending requests as possible taking throttling and\n   * in-flight limits into account.\n   */\n  checkPendingRequests() {\n    while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {\n      const pendingRequest = this.pending.shift() // first in first out\n      this.sendSocketRequest(pendingRequest)\n\n      this.logger.debug(`Consumed pending request`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: pendingRequest.correlationId,\n        pendingDuration: pendingRequest.pendingDuration,\n        currentPendingQueueSize: this.pending.length,\n      })\n\n      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n    }\n\n    this.scheduleCheckPendingRequests()\n  }\n\n  /**\n   * Ensure that pending requests will be checked in the future\n   *\n   * If there is a client-side throttling in place this will ensure that we will check\n   * the pending request queue eventually.\n   */\n  scheduleCheckPendingRequests() {\n    // If we're throttled: Schedule checkPendingRequests when the throttle\n    // should be resolved. If there is already something scheduled we assume that that\n    // will be fine, and potentially fix up a new timeout if needed at that time.\n    // Note that if we're merely \"overloaded\" by having too many inflight requests\n    // we will anyways check the queue when one of them gets fulfilled.\n    let scheduleAt = this.throttledUntil - Date.now()\n    if (!this.throttleCheckTimeoutId) {\n      if (this.pending.length > 0) {\n        scheduleAt = scheduleAt > 0 ? scheduleAt : CHECK_PENDING_REQUESTS_INTERVAL\n      }\n      this.throttleCheckTimeoutId = setTimeout(() => {\n        this.throttleCheckTimeoutId = null\n        this.checkPendingRequests()\n      }, scheduleAt)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}