{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Lock = require('../utils/lock');\nconst {\n  Types: Compression\n} = require('../protocol/message/compression');\nconst {\n  requests,\n  lookup\n} = require('../protocol/requests');\nconst {\n  KafkaJSNonRetriableError\n} = require('../errors');\nconst apiKeys = require('../protocol/requests/apiKeys');\nconst shuffle = require('../utils/shuffle');\nconst PRIVATE = {\n  SEND_REQUEST: Symbol('private:Broker:sendRequest')\n};\n\n/** @type {import(\"../protocol/requests\").Lookup} */\nconst notInitializedLookup = () => {\n  throw new Error('Broker not connected');\n};\n\n/**\n * Each node in a Kafka cluster is called broker. This class contains\n * the high-level operations a node can perform.\n *\n * @type {import(\"../../types\").Broker}\n */\nmodule.exports = class Broker {\n  /**\n   * @param {Object} options\n   * @param {import(\"../network/connectionPool\")} options.connectionPool\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {number} [options.nodeId]\n   * @param {import(\"../../types\").ApiVersions} [options.versions=null] The object with all available versions and APIs\n   *                                 supported by this cluster. The output of broker#apiVersions\n   * @param {number} [options.authenticationTimeout=10000]\n   * @param {boolean} [options.allowAutoTopicCreation=true] If this and the broker config 'auto.create.topics.enable'\n   *                                                are true, topics that don't exist will be created when\n   *                                                fetching metadata.\n   */\n  constructor({\n    connectionPool,\n    logger,\n    nodeId = null,\n    versions = null,\n    authenticationTimeout = 10000,\n    allowAutoTopicCreation = true\n  }) {\n    this.connectionPool = connectionPool;\n    this.nodeId = nodeId;\n    this.rootLogger = logger;\n    this.logger = logger.namespace('Broker');\n    this.versions = versions;\n    this.authenticationTimeout = authenticationTimeout;\n    this.allowAutoTopicCreation = allowAutoTopicCreation;\n\n    // The lock timeout has twice the connectionTimeout because the same timeout is used\n    // for the first apiVersions call\n    const lockTimeout = 2 * this.connectionPool.connectionTimeout + this.authenticationTimeout;\n    this.brokerAddress = `${this.connectionPool.host}:${this.connectionPool.port}`;\n    this.lock = new Lock({\n      timeout: lockTimeout,\n      description: `connect to broker ${this.brokerAddress}`\n    });\n    this.lookupRequest = notInitializedLookup;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.connectionPool.sasl ? this.connectionPool.isConnected() && this.connectionPool.isAuthenticated() : this.connectionPool.isConnected();\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  connect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.lock.acquire();\n      try {\n        if (_this.isConnected()) {\n          return;\n        }\n        const connection = yield _this.connectionPool.getConnection();\n        if (!_this.versions) {\n          _this.versions = yield _this.apiVersions();\n        }\n        _this.connectionPool.setVersions(_this.versions);\n        _this.lookupRequest = lookup(_this.versions);\n        if (connection.getSupportAuthenticationProtocol() === null) {\n          let supportAuthenticationProtocol = false;\n          try {\n            _this.lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate);\n            supportAuthenticationProtocol = true;\n          } catch (_) {\n            supportAuthenticationProtocol = false;\n          }\n          _this.connectionPool.setSupportAuthenticationProtocol(supportAuthenticationProtocol);\n          _this.logger.debug(`Verified support for SaslAuthenticate`, {\n            broker: _this.brokerAddress,\n            supportAuthenticationProtocol\n          });\n        }\n        yield connection.authenticate();\n      } finally {\n        yield _this.lock.release();\n      }\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  disconnect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.connectionPool.destroy();\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").ApiVersions>}\n   */\n  apiVersions() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      let response;\n      const availableVersions = requests.ApiVersions.versions.map(Number).sort().reverse();\n\n      // Find the best version implemented by the server\n      for (const candidateVersion of availableVersions) {\n        try {\n          const apiVersions = requests.ApiVersions.protocol({\n            version: candidateVersion\n          });\n          response = yield _this3[PRIVATE.SEND_REQUEST]({\n            ...apiVersions(),\n            requestTimeout: _this3.connectionPool.connectionTimeout\n          });\n          break;\n        } catch (e) {\n          if (e.type !== 'UNSUPPORTED_VERSION') {\n            throw e;\n          }\n        }\n      }\n      if (!response) {\n        throw new KafkaJSNonRetriableError('API Versions not supported');\n      }\n      return response.apiVersions.reduce((obj, version) => Object.assign(obj, {\n        [version.apiKey]: {\n          minVersion: version.minVersion,\n          maxVersion: version.maxVersion\n        }\n      }), {});\n    })();\n  }\n\n  /**\n   * @public\n   * @type {import(\"../../types\").Broker['metadata']}\n   * @param {string[]} [topics=[]] An array of topics to fetch metadata for.\n   *                            If no topics are specified fetch metadata for all topics\n   */\n  metadata(topics = []) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this4.lookupRequest(apiKeys.Metadata, requests.Metadata);\n      const shuffledTopics = shuffle(topics);\n      return yield _this4[PRIVATE.SEND_REQUEST](metadata({\n        topics: shuffledTopics,\n        allowAutoTopicCreation: _this4.allowAutoTopicCreation\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {Array} request.topicData An array of messages per topic and per partition, example:\n   *                          [\n   *                            {\n   *                              topic: 'test-topic-1',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 0,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '1', value: 'A' },\n   *                                    { key: '2', value: 'B' },\n   *                                  ]\n   *                                },\n   *                                {\n   *                                  partition: 1,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '3', value: 'C' },\n   *                                  ]\n   *                                }\n   *                              ]\n   *                            },\n   *                            {\n   *                              topic: 'test-topic-2',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 4,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '32', value: 'E' },\n   *                                  ]\n   *                                },\n   *                              ]\n   *                            },\n   *                          ]\n   * @param {number} [request.acks=-1] Control the number of required acks.\n   *                           -1 = all replicas must acknowledge\n   *                            0 = no acknowledgments\n   *                            1 = only waits for the leader to acknowledge\n   * @param {number} [request.timeout=30000] The time to await a response in ms\n   * @param {string} [request.transactionalId=null]\n   * @param {number} [request.producerId=-1] Broker assigned producerId\n   * @param {number} [request.producerEpoch=0] Broker assigned producerEpoch\n   * @param {import(\"../../types\").CompressionTypes} [request.compression=CompressionTypes.None] Compression codec\n   * @returns {Promise}\n   */\n  produce({\n    topicData,\n    transactionalId,\n    producerId,\n    producerEpoch,\n    acks = -1,\n    timeout = 30000,\n    compression = Compression.None\n  }) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const produce = _this5.lookupRequest(apiKeys.Produce, requests.Produce);\n      return yield _this5[PRIVATE.SEND_REQUEST](produce({\n        acks,\n        timeout,\n        compression,\n        topicData,\n        transactionalId,\n        producerId,\n        producerEpoch\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {number} [request.replicaId=-1] Broker id of the follower. For normal consumers, use -1\n   * @param {number} [request.isolationLevel=1] This setting controls the visibility of transactional records. Default READ_COMMITTED.\n   * @param {number} [request.maxWaitTime=5000] Maximum time in ms to wait for the response\n   * @param {number} [request.minBytes=1] Minimum bytes to accumulate in the response\n   * @param {number} [request.maxBytes=10485760] Maximum bytes to accumulate in the response. Note that this is\n   *                                   not an absolute maximum, if the first message in the first non-empty\n   *                                   partition of the fetch is larger than this value, the message will still\n   *                                   be returned to ensure that progress can be made. Default 10MB.\n   * @param {Array} request.topics Topics to fetch\n   *                        [\n   *                          {\n   *                            topic: 'topic-name',\n   *                            partitions: [\n   *                              {\n   *                                partition: 0,\n   *                                fetchOffset: '4124',\n   *                                maxBytes: 2048\n   *                              }\n   *                            ]\n   *                          }\n   *                        ]\n   * @param {string} [request.rackId=''] A rack identifier for this client. This can be any string value which indicates where this\n   *                           client is physically located. It corresponds with the broker config `broker.rack`.\n   * @returns {Promise}\n   */\n  fetch({\n    replicaId,\n    isolationLevel,\n    maxWaitTime = 5000,\n    minBytes = 1,\n    maxBytes = 10485760,\n    topics,\n    rackId = ''\n  }) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // TODO: validate topics not null/empty\n      const fetch = _this6.lookupRequest(apiKeys.Fetch, requests.Fetch);\n\n      // Shuffle topic-partitions to ensure fair response allocation across partitions (KIP-74)\n      const flattenedTopicPartitions = topics.reduce((topicPartitions, {\n        topic,\n        partitions\n      }) => {\n        partitions.forEach(partition => {\n          topicPartitions.push({\n            topic,\n            partition\n          });\n        });\n        return topicPartitions;\n      }, []);\n      const shuffledTopicPartitions = shuffle(flattenedTopicPartitions);\n\n      // Consecutive partitions for the same topic can be combined into a single `topic` entry\n      const consolidatedTopicPartitions = shuffledTopicPartitions.reduce((topicPartitions, {\n        topic,\n        partition\n      }) => {\n        const last = topicPartitions[topicPartitions.length - 1];\n        if (last != null && last.topic === topic) {\n          topicPartitions[topicPartitions.length - 1].partitions.push(partition);\n        } else {\n          topicPartitions.push({\n            topic,\n            partitions: [partition]\n          });\n        }\n        return topicPartitions;\n      }, []);\n      return yield _this6[PRIVATE.SEND_REQUEST](fetch({\n        replicaId,\n        isolationLevel,\n        maxWaitTime,\n        minBytes,\n        maxBytes,\n        topics: consolidatedTopicPartitions,\n        rackId\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The group id\n   * @param {number} request.groupGenerationId The generation of the group\n   * @param {string} request.memberId The member id assigned by the group coordinator\n   * @returns {Promise}\n   */\n  heartbeat({\n    groupId,\n    groupGenerationId,\n    memberId\n  }) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const heartbeat = _this7.lookupRequest(apiKeys.Heartbeat, requests.Heartbeat);\n      return yield _this7[PRIVATE.SEND_REQUEST](heartbeat({\n        groupId,\n        groupGenerationId,\n        memberId\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The unique group id\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} request.coordinatorType The type of coordinator to find\n   * @returns {Promise}\n   */\n  findGroupCoordinator({\n    groupId,\n    coordinatorType\n  }) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // TODO: validate groupId, mandatory\n      const findCoordinator = _this8.lookupRequest(apiKeys.GroupCoordinator, requests.GroupCoordinator);\n      return yield _this8[PRIVATE.SEND_REQUEST](findCoordinator({\n        groupId,\n        coordinatorType\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The unique group id\n   * @param {number} request.sessionTimeout The coordinator considers the consumer dead if it receives\n   *                                no heartbeat after this timeout in ms\n   * @param {number} request.rebalanceTimeout The maximum time that the coordinator will wait for each member\n   *                                  to rejoin when rebalancing the group\n   * @param {string} [request.memberId=\"\"] The assigned consumer id or an empty string for a new consumer\n   * @param {string} [request.protocolType=\"consumer\"] Unique name for class of protocols implemented by group\n   * @param {Array} request.groupProtocols List of protocols that the member supports (assignment strategy)\n   *                                [{ name: 'AssignerName', metadata: '{\"version\": 1, \"topics\": []}' }]\n   * @returns {Promise}\n   */\n  joinGroup({\n    groupId,\n    sessionTimeout,\n    rebalanceTimeout,\n    memberId = '',\n    protocolType = 'consumer',\n    groupProtocols\n  }) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const joinGroup = _this9.lookupRequest(apiKeys.JoinGroup, requests.JoinGroup);\n      const makeRequest = (assignedMemberId = memberId) => _this9[PRIVATE.SEND_REQUEST](joinGroup({\n        groupId,\n        sessionTimeout,\n        rebalanceTimeout,\n        memberId: assignedMemberId,\n        protocolType,\n        groupProtocols\n      }));\n      try {\n        return yield makeRequest();\n      } catch (error) {\n        if (error.name === 'KafkaJSMemberIdRequired') {\n          return makeRequest(error.memberId);\n        }\n        throw error;\n      }\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {string} request.memberId\n   * @returns {Promise}\n   */\n  leaveGroup({\n    groupId,\n    memberId\n  }) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const leaveGroup = _this10.lookupRequest(apiKeys.LeaveGroup, requests.LeaveGroup);\n      return yield _this10[PRIVATE.SEND_REQUEST](leaveGroup({\n        groupId,\n        memberId\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {number} request.generationId\n   * @param {string} request.memberId\n   * @param {object} request.groupAssignment\n   * @returns {Promise}\n   */\n  syncGroup({\n    groupId,\n    generationId,\n    memberId,\n    groupAssignment\n  }) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const syncGroup = _this11.lookupRequest(apiKeys.SyncGroup, requests.SyncGroup);\n      return yield _this11[PRIVATE.SEND_REQUEST](syncGroup({\n        groupId,\n        generationId,\n        memberId,\n        groupAssignment\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {number} request.replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} request.isolationLevel=1 This setting controls the visibility of transactional records (default READ_COMMITTED, Kafka >0.11 only)\n   * @param {TopicPartitionOffset[]} request.topics e.g:\n   *\n   * @typedef {Object} TopicPartitionOffset\n   * @property {string} topic\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {number} partition\n   * @property {number} [timestamp=-1]\n   *\n   *\n   * @returns {Promise}\n   */\n  listOffsets({\n    replicaId,\n    isolationLevel,\n    topics\n  }) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const listOffsets = _this12.lookupRequest(apiKeys.ListOffsets, requests.ListOffsets);\n      const result = yield _this12[PRIVATE.SEND_REQUEST](listOffsets({\n        replicaId,\n        isolationLevel,\n        topics\n      }));\n\n      // ListOffsets >= v1 will return a single `offset` rather than an array of `offsets` (ListOffsets V0).\n      // Normalize to just return `offset`.\n      for (const response of result.responses) {\n        response.partitions = response.partitions.map(({\n          offsets,\n          ...partitionData\n        }) => {\n          return offsets ? {\n            ...partitionData,\n            offset: offsets.pop()\n          } : partitionData;\n        });\n      }\n      return result;\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {number} request.groupGenerationId\n   * @param {string} request.memberId\n   * @param {number} [request.retentionTime=-1] -1 signals to the broker that its default configuration\n   *                                    should be used.\n   * @param {object} request.topics Topics to commit offsets, e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0, offset: '11' }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  offsetCommit({\n    groupId,\n    groupGenerationId,\n    memberId,\n    retentionTime,\n    topics\n  }) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const offsetCommit = _this13.lookupRequest(apiKeys.OffsetCommit, requests.OffsetCommit);\n      return yield _this13[PRIVATE.SEND_REQUEST](offsetCommit({\n        groupId,\n        groupGenerationId,\n        memberId,\n        retentionTime,\n        topics\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {object} request.topics - If the topic array is null fetch offsets for all topics. e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0 }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  offsetFetch({\n    groupId,\n    topics\n  }) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const offsetFetch = _this14.lookupRequest(apiKeys.OffsetFetch, requests.OffsetFetch);\n      return yield _this14[PRIVATE.SEND_REQUEST](offsetFetch({\n        groupId,\n        topics\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.groupIds\n   * @returns {Promise}\n   */\n  describeGroups({\n    groupIds\n  }) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const describeGroups = _this15.lookupRequest(apiKeys.DescribeGroups, requests.DescribeGroups);\n      return yield _this15[PRIVATE.SEND_REQUEST](describeGroups({\n        groupIds\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.topics e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     numPartitions: 1,\n   *                     replicationFactor: 1\n   *                   }\n   *                 ]\n   * @param {boolean} [request.validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise}\n   */\n  createTopics({\n    topics,\n    validateOnly = false,\n    timeout = 5000\n  }) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const createTopics = _this16.lookupRequest(apiKeys.CreateTopics, requests.CreateTopics);\n      return yield _this16[PRIVATE.SEND_REQUEST](createTopics({\n        topics,\n        validateOnly,\n        timeout\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.topicPartitions e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     count: 3,\n   *                     assignments: []\n   *                   }\n   *                 ]\n   * @param {boolean} [request.validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise<void>}\n   */\n  createPartitions({\n    topicPartitions,\n    validateOnly = false,\n    timeout = 5000\n  }) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const createPartitions = _this17.lookupRequest(apiKeys.CreatePartitions, requests.CreatePartitions);\n      return yield _this17[PRIVATE.SEND_REQUEST](createPartitions({\n        topicPartitions,\n        validateOnly,\n        timeout\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string[]} request.topics An array of topics to be deleted\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely deleted on the\n   *                                controller node.\n   * @returns {Promise}\n   */\n  deleteTopics({\n    topics,\n    timeout = 5000\n  }) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const deleteTopics = _this18.lookupRequest(apiKeys.DeleteTopics, requests.DeleteTopics);\n      return yield _this18[PRIVATE.SEND_REQUEST](deleteTopics({\n        topics,\n        timeout\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").ResourceConfigQuery[]} request.resources\n   *                                 [{\n   *                                   type: RESOURCE_TYPES.TOPIC,\n   *                                   name: 'topic-name',\n   *                                   configNames: ['compression.type', 'retention.ms']\n   *                                 }]\n   * @param {boolean} [request.includeSynonyms=false]\n   * @returns {Promise}\n   */\n  describeConfigs({\n    resources,\n    includeSynonyms = false\n  }) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const describeConfigs = _this19.lookupRequest(apiKeys.DescribeConfigs, requests.DescribeConfigs);\n      return yield _this19[PRIVATE.SEND_REQUEST](describeConfigs({\n        resources,\n        includeSynonyms\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").IResourceConfig[]} request.resources\n   *                                 [{\n   *                                  type: RESOURCE_TYPES.TOPIC,\n   *                                  name: 'topic-name',\n   *                                  configEntries: [\n   *                                    {\n   *                                      name: 'cleanup.policy',\n   *                                      value: 'compact'\n   *                                    }\n   *                                  ]\n   *                                 }]\n   * @param {boolean} [request.validateOnly=false]\n   * @returns {Promise}\n   */\n  alterConfigs({\n    resources,\n    validateOnly = false\n  }) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const alterConfigs = _this20.lookupRequest(apiKeys.AlterConfigs, requests.AlterConfigs);\n      return yield _this20[PRIVATE.SEND_REQUEST](alterConfigs({\n        resources,\n        validateOnly\n      }));\n    })();\n  }\n\n  /**\n   * Send an `InitProducerId` request to fetch a PID and bump the producer epoch.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {number} request.transactionTimeout The time in ms to wait for before aborting idle transactions\n   * @param {number} [request.transactionalId] The transactional id or null if the producer is not transactional\n   * @returns {Promise}\n   */\n  initProducerId({\n    transactionalId,\n    transactionTimeout\n  }) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const initProducerId = _this21.lookupRequest(apiKeys.InitProducerId, requests.InitProducerId);\n      return yield _this21[PRIVATE.SEND_REQUEST](initProducerId({\n        transactionalId,\n        transactionTimeout\n      }));\n    })();\n  }\n\n  /**\n   * Send an `AddPartitionsToTxn` request to mark a TopicPartition as participating in the transaction.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {object[]} request.topics e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [ 0, 1]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  addPartitionsToTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    topics\n  }) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const addPartitionsToTxn = _this22.lookupRequest(apiKeys.AddPartitionsToTxn, requests.AddPartitionsToTxn);\n      return yield _this22[PRIVATE.SEND_REQUEST](addPartitionsToTxn({\n        transactionalId,\n        producerId,\n        producerEpoch,\n        topics\n      }));\n    })();\n  }\n\n  /**\n   * Send an `AddOffsetsToTxn` request.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {string} request.groupId The unique group identifier (for the consumer group)\n   * @returns {Promise}\n   */\n  addOffsetsToTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    groupId\n  }) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const addOffsetsToTxn = _this23.lookupRequest(apiKeys.AddOffsetsToTxn, requests.AddOffsetsToTxn);\n      return yield _this23[PRIVATE.SEND_REQUEST](addOffsetsToTxn({\n        transactionalId,\n        producerId,\n        producerEpoch,\n        groupId\n      }));\n    })();\n  }\n\n  /**\n   * Send a `TxnOffsetCommit` request to persist the offsets in the `__consumer_offsets` topics.\n   *\n   * Request should be made to the consumer coordinator.\n   * @public\n   * @param {object} request\n   * @param {OffsetCommitTopic[]} request.topics\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {string} request.groupId The unique group identifier (for the consumer group)\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {OffsetCommitTopic[]} request.topics\n   *\n   * @typedef {Object} OffsetCommitTopic\n   * @property {string} topic\n   * @property {OffsetCommitTopicPartition[]} partitions\n   *\n   * @typedef {Object} OffsetCommitTopicPartition\n   * @property {number} partition\n   * @property {number} offset\n   * @property {string} [metadata]\n   *\n   * @returns {Promise}\n   */\n  txnOffsetCommit({\n    transactionalId,\n    groupId,\n    producerId,\n    producerEpoch,\n    topics\n  }) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const txnOffsetCommit = _this24.lookupRequest(apiKeys.TxnOffsetCommit, requests.TxnOffsetCommit);\n      return yield _this24[PRIVATE.SEND_REQUEST](txnOffsetCommit({\n        transactionalId,\n        groupId,\n        producerId,\n        producerEpoch,\n        topics\n      }));\n    })();\n  }\n\n  /**\n   * Send an `EndTxn` request to indicate transaction should be committed or aborted.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {boolean} request.transactionResult The result of the transaction (false = ABORT, true = COMMIT)\n   * @returns {Promise}\n   */\n  endTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    transactionResult\n  }) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const endTxn = _this25.lookupRequest(apiKeys.EndTxn, requests.EndTxn);\n      return yield _this25[PRIVATE.SEND_REQUEST](endTxn({\n        transactionalId,\n        producerId,\n        producerEpoch,\n        transactionResult\n      }));\n    })();\n  }\n\n  /**\n   * Send request for list of groups\n   * @public\n   * @returns {Promise}\n   */\n  listGroups() {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const listGroups = _this26.lookupRequest(apiKeys.ListGroups, requests.ListGroups);\n      return yield _this26[PRIVATE.SEND_REQUEST](listGroups());\n    })();\n  }\n\n  /**\n   * Send request to delete groups\n   * @param {string[]} groupIds\n   * @public\n   * @returns {Promise}\n   */\n  deleteGroups(groupIds) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const deleteGroups = _this27.lookupRequest(apiKeys.DeleteGroups, requests.DeleteGroups);\n      return yield _this27[PRIVATE.SEND_REQUEST](deleteGroups(groupIds));\n    })();\n  }\n\n  /**\n   * Send request to delete records\n   * @public\n   * @param {object} request\n   * @param {TopicPartitionRecords[]} request.topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset 2 },\n   *                                { partition: 1, offset 4 },\n   *                              ],\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          {\n   *                            throttleTime: 0\n   *                           [\n   *                              {\n   *                                topic: 'my-topic-name',\n   *                                partitions: [\n   *                                 { partition: 0, lowWatermark: '2n', errorCode: 0 },\n   *                                 { partition: 1, lowWatermark: '4n', errorCode: 0 },\n   *                               ],\n   *                             },\n   *                           ]\n   *                          }\n   *\n   * @typedef {object} TopicPartitionRecords\n   * @property {string} topic\n   * @property {PartitionRecord[]} partitions\n   *\n   * @typedef {object} PartitionRecord\n   * @property {number} partition\n   * @property {number} offset\n   */\n  deleteRecords({\n    topics\n  }) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const deleteRecords = _this28.lookupRequest(apiKeys.DeleteRecords, requests.DeleteRecords);\n      return yield _this28[PRIVATE.SEND_REQUEST](deleteRecords({\n        topics\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").AclEntry[]} request.acl e.g:\n   *                 [\n   *                   {\n   *                     resourceType: AclResourceTypes.TOPIC,\n   *                     resourceName: 'topic-name',\n   *                     resourcePatternType: ResourcePatternTypes.LITERAL,\n   *                     principal: 'User:bob',\n   *                     host: '*',\n   *                     operation: AclOperationTypes.ALL,\n   *                     permissionType: AclPermissionTypes.DENY,\n   *                   }\n   *                 ]\n   * @returns {Promise<void>}\n   */\n  createAcls({\n    acl\n  }) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const createAcls = _this29.lookupRequest(apiKeys.CreateAcls, requests.CreateAcls);\n      return yield _this29[PRIVATE.SEND_REQUEST](createAcls({\n        creations: acl\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {import(\"../../types\").AclEntry} aclEntry\n   * @returns {Promise<void>}\n   */\n  describeAcls({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType\n  }) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      const describeAcls = _this30.lookupRequest(apiKeys.DescribeAcls, requests.DescribeAcls);\n      return yield _this30[PRIVATE.SEND_REQUEST](describeAcls({\n        resourceType,\n        resourceName,\n        resourcePatternType,\n        principal,\n        host,\n        operation,\n        permissionType\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").AclEntry[]} request.filters\n   * @returns {Promise<void>}\n   */\n  deleteAcls({\n    filters\n  }) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const deleteAcls = _this31.lookupRequest(apiKeys.DeleteAcls, requests.DeleteAcls);\n      return yield _this31[PRIVATE.SEND_REQUEST](deleteAcls({\n        filters\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").PartitionReassignment[]} request.topics\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  alterPartitionReassignments({\n    topics,\n    timeout\n  }) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const alterPartitionReassignments = _this32.lookupRequest(apiKeys.AlterPartitionReassignments, requests.AlterPartitionReassignments);\n      return yield _this32[PRIVATE.SEND_REQUEST](alterPartitionReassignments({\n        topics,\n        timeout\n      }));\n    })();\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").TopicPartitions[]} request.topics can be null\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  listPartitionReassignments({\n    topics = null,\n    timeout\n  }) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const listPartitionReassignments = _this33.lookupRequest(apiKeys.ListPartitionReassignments, requests.ListPartitionReassignments);\n      return yield _this33[PRIVATE.SEND_REQUEST](listPartitionReassignments({\n        topics,\n        timeout\n      }));\n    })();\n  }\n\n  /**\n   * @private\n   */\n  [PRIVATE.SEND_REQUEST](protocolRequest) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this34.connectionPool.send(protocolRequest);\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionClosedError') {\n          yield _this34.disconnect();\n        }\n        throw e;\n      }\n    })();\n  }\n};","map":{"version":3,"names":["Lock","require","Types","Compression","requests","lookup","KafkaJSNonRetriableError","apiKeys","shuffle","PRIVATE","SEND_REQUEST","Symbol","notInitializedLookup","Error","module","exports","Broker","constructor","connectionPool","logger","nodeId","versions","authenticationTimeout","allowAutoTopicCreation","rootLogger","namespace","lockTimeout","connectionTimeout","brokerAddress","host","port","lock","timeout","description","lookupRequest","isConnected","sasl","isAuthenticated","connect","acquire","connection","getConnection","apiVersions","setVersions","getSupportAuthenticationProtocol","supportAuthenticationProtocol","SaslAuthenticate","_","setSupportAuthenticationProtocol","debug","broker","authenticate","release","disconnect","destroy","response","availableVersions","ApiVersions","map","Number","sort","reverse","candidateVersion","protocol","version","requestTimeout","e","type","reduce","obj","Object","assign","apiKey","minVersion","maxVersion","metadata","topics","Metadata","shuffledTopics","produce","topicData","transactionalId","producerId","producerEpoch","acks","compression","None","Produce","fetch","replicaId","isolationLevel","maxWaitTime","minBytes","maxBytes","rackId","Fetch","flattenedTopicPartitions","topicPartitions","topic","partitions","forEach","partition","push","shuffledTopicPartitions","consolidatedTopicPartitions","last","length","heartbeat","groupId","groupGenerationId","memberId","Heartbeat","findGroupCoordinator","coordinatorType","findCoordinator","GroupCoordinator","joinGroup","sessionTimeout","rebalanceTimeout","protocolType","groupProtocols","JoinGroup","makeRequest","assignedMemberId","error","name","leaveGroup","LeaveGroup","syncGroup","generationId","groupAssignment","SyncGroup","listOffsets","ListOffsets","result","responses","offsets","partitionData","offset","pop","offsetCommit","retentionTime","OffsetCommit","offsetFetch","OffsetFetch","describeGroups","groupIds","DescribeGroups","createTopics","validateOnly","CreateTopics","createPartitions","CreatePartitions","deleteTopics","DeleteTopics","describeConfigs","resources","includeSynonyms","DescribeConfigs","alterConfigs","AlterConfigs","initProducerId","transactionTimeout","InitProducerId","addPartitionsToTxn","AddPartitionsToTxn","addOffsetsToTxn","AddOffsetsToTxn","txnOffsetCommit","TxnOffsetCommit","endTxn","transactionResult","EndTxn","listGroups","ListGroups","deleteGroups","DeleteGroups","deleteRecords","DeleteRecords","createAcls","acl","CreateAcls","creations","describeAcls","resourceType","resourceName","resourcePatternType","principal","operation","permissionType","DescribeAcls","deleteAcls","filters","DeleteAcls","alterPartitionReassignments","AlterPartitionReassignments","listPartitionReassignments","ListPartitionReassignments","protocolRequest","send"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/broker/index.js"],"sourcesContent":["const Lock = require('../utils/lock')\nconst { Types: Compression } = require('../protocol/message/compression')\nconst { requests, lookup } = require('../protocol/requests')\nconst { KafkaJSNonRetriableError } = require('../errors')\nconst apiKeys = require('../protocol/requests/apiKeys')\nconst shuffle = require('../utils/shuffle')\n\nconst PRIVATE = {\n  SEND_REQUEST: Symbol('private:Broker:sendRequest'),\n}\n\n/** @type {import(\"../protocol/requests\").Lookup} */\nconst notInitializedLookup = () => {\n  throw new Error('Broker not connected')\n}\n\n/**\n * Each node in a Kafka cluster is called broker. This class contains\n * the high-level operations a node can perform.\n *\n * @type {import(\"../../types\").Broker}\n */\nmodule.exports = class Broker {\n  /**\n   * @param {Object} options\n   * @param {import(\"../network/connectionPool\")} options.connectionPool\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {number} [options.nodeId]\n   * @param {import(\"../../types\").ApiVersions} [options.versions=null] The object with all available versions and APIs\n   *                                 supported by this cluster. The output of broker#apiVersions\n   * @param {number} [options.authenticationTimeout=10000]\n   * @param {boolean} [options.allowAutoTopicCreation=true] If this and the broker config 'auto.create.topics.enable'\n   *                                                are true, topics that don't exist will be created when\n   *                                                fetching metadata.\n   */\n  constructor({\n    connectionPool,\n    logger,\n    nodeId = null,\n    versions = null,\n    authenticationTimeout = 10000,\n    allowAutoTopicCreation = true,\n  }) {\n    this.connectionPool = connectionPool\n    this.nodeId = nodeId\n    this.rootLogger = logger\n    this.logger = logger.namespace('Broker')\n    this.versions = versions\n    this.authenticationTimeout = authenticationTimeout\n    this.allowAutoTopicCreation = allowAutoTopicCreation\n\n    // The lock timeout has twice the connectionTimeout because the same timeout is used\n    // for the first apiVersions call\n    const lockTimeout = 2 * this.connectionPool.connectionTimeout + this.authenticationTimeout\n    this.brokerAddress = `${this.connectionPool.host}:${this.connectionPool.port}`\n\n    this.lock = new Lock({\n      timeout: lockTimeout,\n      description: `connect to broker ${this.brokerAddress}`,\n    })\n\n    this.lookupRequest = notInitializedLookup\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.connectionPool.sasl\n      ? this.connectionPool.isConnected() && this.connectionPool.isAuthenticated()\n      : this.connectionPool.isConnected()\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async connect() {\n    await this.lock.acquire()\n    try {\n      if (this.isConnected()) {\n        return\n      }\n\n      const connection = await this.connectionPool.getConnection()\n\n      if (!this.versions) {\n        this.versions = await this.apiVersions()\n      }\n      this.connectionPool.setVersions(this.versions)\n\n      this.lookupRequest = lookup(this.versions)\n\n      if (connection.getSupportAuthenticationProtocol() === null) {\n        let supportAuthenticationProtocol = false\n        try {\n          this.lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate)\n          supportAuthenticationProtocol = true\n        } catch (_) {\n          supportAuthenticationProtocol = false\n        }\n        this.connectionPool.setSupportAuthenticationProtocol(supportAuthenticationProtocol)\n\n        this.logger.debug(`Verified support for SaslAuthenticate`, {\n          broker: this.brokerAddress,\n          supportAuthenticationProtocol,\n        })\n      }\n\n      await connection.authenticate()\n    } finally {\n      await this.lock.release()\n    }\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    await this.connectionPool.destroy()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").ApiVersions>}\n   */\n  async apiVersions() {\n    let response\n    const availableVersions = requests.ApiVersions.versions\n      .map(Number)\n      .sort()\n      .reverse()\n\n    // Find the best version implemented by the server\n    for (const candidateVersion of availableVersions) {\n      try {\n        const apiVersions = requests.ApiVersions.protocol({ version: candidateVersion })\n        response = await this[PRIVATE.SEND_REQUEST]({\n          ...apiVersions(),\n          requestTimeout: this.connectionPool.connectionTimeout,\n        })\n        break\n      } catch (e) {\n        if (e.type !== 'UNSUPPORTED_VERSION') {\n          throw e\n        }\n      }\n    }\n\n    if (!response) {\n      throw new KafkaJSNonRetriableError('API Versions not supported')\n    }\n\n    return response.apiVersions.reduce(\n      (obj, version) =>\n        Object.assign(obj, {\n          [version.apiKey]: {\n            minVersion: version.minVersion,\n            maxVersion: version.maxVersion,\n          },\n        }),\n      {}\n    )\n  }\n\n  /**\n   * @public\n   * @type {import(\"../../types\").Broker['metadata']}\n   * @param {string[]} [topics=[]] An array of topics to fetch metadata for.\n   *                            If no topics are specified fetch metadata for all topics\n   */\n  async metadata(topics = []) {\n    const metadata = this.lookupRequest(apiKeys.Metadata, requests.Metadata)\n    const shuffledTopics = shuffle(topics)\n    return await this[PRIVATE.SEND_REQUEST](\n      metadata({ topics: shuffledTopics, allowAutoTopicCreation: this.allowAutoTopicCreation })\n    )\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {Array} request.topicData An array of messages per topic and per partition, example:\n   *                          [\n   *                            {\n   *                              topic: 'test-topic-1',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 0,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '1', value: 'A' },\n   *                                    { key: '2', value: 'B' },\n   *                                  ]\n   *                                },\n   *                                {\n   *                                  partition: 1,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '3', value: 'C' },\n   *                                  ]\n   *                                }\n   *                              ]\n   *                            },\n   *                            {\n   *                              topic: 'test-topic-2',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 4,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '32', value: 'E' },\n   *                                  ]\n   *                                },\n   *                              ]\n   *                            },\n   *                          ]\n   * @param {number} [request.acks=-1] Control the number of required acks.\n   *                           -1 = all replicas must acknowledge\n   *                            0 = no acknowledgments\n   *                            1 = only waits for the leader to acknowledge\n   * @param {number} [request.timeout=30000] The time to await a response in ms\n   * @param {string} [request.transactionalId=null]\n   * @param {number} [request.producerId=-1] Broker assigned producerId\n   * @param {number} [request.producerEpoch=0] Broker assigned producerEpoch\n   * @param {import(\"../../types\").CompressionTypes} [request.compression=CompressionTypes.None] Compression codec\n   * @returns {Promise}\n   */\n  async produce({\n    topicData,\n    transactionalId,\n    producerId,\n    producerEpoch,\n    acks = -1,\n    timeout = 30000,\n    compression = Compression.None,\n  }) {\n    const produce = this.lookupRequest(apiKeys.Produce, requests.Produce)\n    return await this[PRIVATE.SEND_REQUEST](\n      produce({\n        acks,\n        timeout,\n        compression,\n        topicData,\n        transactionalId,\n        producerId,\n        producerEpoch,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {number} [request.replicaId=-1] Broker id of the follower. For normal consumers, use -1\n   * @param {number} [request.isolationLevel=1] This setting controls the visibility of transactional records. Default READ_COMMITTED.\n   * @param {number} [request.maxWaitTime=5000] Maximum time in ms to wait for the response\n   * @param {number} [request.minBytes=1] Minimum bytes to accumulate in the response\n   * @param {number} [request.maxBytes=10485760] Maximum bytes to accumulate in the response. Note that this is\n   *                                   not an absolute maximum, if the first message in the first non-empty\n   *                                   partition of the fetch is larger than this value, the message will still\n   *                                   be returned to ensure that progress can be made. Default 10MB.\n   * @param {Array} request.topics Topics to fetch\n   *                        [\n   *                          {\n   *                            topic: 'topic-name',\n   *                            partitions: [\n   *                              {\n   *                                partition: 0,\n   *                                fetchOffset: '4124',\n   *                                maxBytes: 2048\n   *                              }\n   *                            ]\n   *                          }\n   *                        ]\n   * @param {string} [request.rackId=''] A rack identifier for this client. This can be any string value which indicates where this\n   *                           client is physically located. It corresponds with the broker config `broker.rack`.\n   * @returns {Promise}\n   */\n  async fetch({\n    replicaId,\n    isolationLevel,\n    maxWaitTime = 5000,\n    minBytes = 1,\n    maxBytes = 10485760,\n    topics,\n    rackId = '',\n  }) {\n    // TODO: validate topics not null/empty\n    const fetch = this.lookupRequest(apiKeys.Fetch, requests.Fetch)\n\n    // Shuffle topic-partitions to ensure fair response allocation across partitions (KIP-74)\n    const flattenedTopicPartitions = topics.reduce((topicPartitions, { topic, partitions }) => {\n      partitions.forEach(partition => {\n        topicPartitions.push({ topic, partition })\n      })\n      return topicPartitions\n    }, [])\n\n    const shuffledTopicPartitions = shuffle(flattenedTopicPartitions)\n\n    // Consecutive partitions for the same topic can be combined into a single `topic` entry\n    const consolidatedTopicPartitions = shuffledTopicPartitions.reduce(\n      (topicPartitions, { topic, partition }) => {\n        const last = topicPartitions[topicPartitions.length - 1]\n\n        if (last != null && last.topic === topic) {\n          topicPartitions[topicPartitions.length - 1].partitions.push(partition)\n        } else {\n          topicPartitions.push({ topic, partitions: [partition] })\n        }\n\n        return topicPartitions\n      },\n      []\n    )\n\n    return await this[PRIVATE.SEND_REQUEST](\n      fetch({\n        replicaId,\n        isolationLevel,\n        maxWaitTime,\n        minBytes,\n        maxBytes,\n        topics: consolidatedTopicPartitions,\n        rackId,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The group id\n   * @param {number} request.groupGenerationId The generation of the group\n   * @param {string} request.memberId The member id assigned by the group coordinator\n   * @returns {Promise}\n   */\n  async heartbeat({ groupId, groupGenerationId, memberId }) {\n    const heartbeat = this.lookupRequest(apiKeys.Heartbeat, requests.Heartbeat)\n    return await this[PRIVATE.SEND_REQUEST](heartbeat({ groupId, groupGenerationId, memberId }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The unique group id\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} request.coordinatorType The type of coordinator to find\n   * @returns {Promise}\n   */\n  async findGroupCoordinator({ groupId, coordinatorType }) {\n    // TODO: validate groupId, mandatory\n    const findCoordinator = this.lookupRequest(apiKeys.GroupCoordinator, requests.GroupCoordinator)\n    return await this[PRIVATE.SEND_REQUEST](findCoordinator({ groupId, coordinatorType }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId The unique group id\n   * @param {number} request.sessionTimeout The coordinator considers the consumer dead if it receives\n   *                                no heartbeat after this timeout in ms\n   * @param {number} request.rebalanceTimeout The maximum time that the coordinator will wait for each member\n   *                                  to rejoin when rebalancing the group\n   * @param {string} [request.memberId=\"\"] The assigned consumer id or an empty string for a new consumer\n   * @param {string} [request.protocolType=\"consumer\"] Unique name for class of protocols implemented by group\n   * @param {Array} request.groupProtocols List of protocols that the member supports (assignment strategy)\n   *                                [{ name: 'AssignerName', metadata: '{\"version\": 1, \"topics\": []}' }]\n   * @returns {Promise}\n   */\n  async joinGroup({\n    groupId,\n    sessionTimeout,\n    rebalanceTimeout,\n    memberId = '',\n    protocolType = 'consumer',\n    groupProtocols,\n  }) {\n    const joinGroup = this.lookupRequest(apiKeys.JoinGroup, requests.JoinGroup)\n    const makeRequest = (assignedMemberId = memberId) =>\n      this[PRIVATE.SEND_REQUEST](\n        joinGroup({\n          groupId,\n          sessionTimeout,\n          rebalanceTimeout,\n          memberId: assignedMemberId,\n          protocolType,\n          groupProtocols,\n        })\n      )\n\n    try {\n      return await makeRequest()\n    } catch (error) {\n      if (error.name === 'KafkaJSMemberIdRequired') {\n        return makeRequest(error.memberId)\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {string} request.memberId\n   * @returns {Promise}\n   */\n  async leaveGroup({ groupId, memberId }) {\n    const leaveGroup = this.lookupRequest(apiKeys.LeaveGroup, requests.LeaveGroup)\n    return await this[PRIVATE.SEND_REQUEST](leaveGroup({ groupId, memberId }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {number} request.generationId\n   * @param {string} request.memberId\n   * @param {object} request.groupAssignment\n   * @returns {Promise}\n   */\n  async syncGroup({ groupId, generationId, memberId, groupAssignment }) {\n    const syncGroup = this.lookupRequest(apiKeys.SyncGroup, requests.SyncGroup)\n    return await this[PRIVATE.SEND_REQUEST](\n      syncGroup({\n        groupId,\n        generationId,\n        memberId,\n        groupAssignment,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {number} request.replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} request.isolationLevel=1 This setting controls the visibility of transactional records (default READ_COMMITTED, Kafka >0.11 only)\n   * @param {TopicPartitionOffset[]} request.topics e.g:\n   *\n   * @typedef {Object} TopicPartitionOffset\n   * @property {string} topic\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {number} partition\n   * @property {number} [timestamp=-1]\n   *\n   *\n   * @returns {Promise}\n   */\n  async listOffsets({ replicaId, isolationLevel, topics }) {\n    const listOffsets = this.lookupRequest(apiKeys.ListOffsets, requests.ListOffsets)\n    const result = await this[PRIVATE.SEND_REQUEST](\n      listOffsets({ replicaId, isolationLevel, topics })\n    )\n\n    // ListOffsets >= v1 will return a single `offset` rather than an array of `offsets` (ListOffsets V0).\n    // Normalize to just return `offset`.\n    for (const response of result.responses) {\n      response.partitions = response.partitions.map(({ offsets, ...partitionData }) => {\n        return offsets ? { ...partitionData, offset: offsets.pop() } : partitionData\n      })\n    }\n\n    return result\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {number} request.groupGenerationId\n   * @param {string} request.memberId\n   * @param {number} [request.retentionTime=-1] -1 signals to the broker that its default configuration\n   *                                    should be used.\n   * @param {object} request.topics Topics to commit offsets, e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0, offset: '11' }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async offsetCommit({ groupId, groupGenerationId, memberId, retentionTime, topics }) {\n    const offsetCommit = this.lookupRequest(apiKeys.OffsetCommit, requests.OffsetCommit)\n    return await this[PRIVATE.SEND_REQUEST](\n      offsetCommit({\n        groupId,\n        groupGenerationId,\n        memberId,\n        retentionTime,\n        topics,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string} request.groupId\n   * @param {object} request.topics - If the topic array is null fetch offsets for all topics. e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0 }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async offsetFetch({ groupId, topics }) {\n    const offsetFetch = this.lookupRequest(apiKeys.OffsetFetch, requests.OffsetFetch)\n    return await this[PRIVATE.SEND_REQUEST](offsetFetch({ groupId, topics }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.groupIds\n   * @returns {Promise}\n   */\n  async describeGroups({ groupIds }) {\n    const describeGroups = this.lookupRequest(apiKeys.DescribeGroups, requests.DescribeGroups)\n    return await this[PRIVATE.SEND_REQUEST](describeGroups({ groupIds }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.topics e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     numPartitions: 1,\n   *                     replicationFactor: 1\n   *                   }\n   *                 ]\n   * @param {boolean} [request.validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise}\n   */\n  async createTopics({ topics, validateOnly = false, timeout = 5000 }) {\n    const createTopics = this.lookupRequest(apiKeys.CreateTopics, requests.CreateTopics)\n    return await this[PRIVATE.SEND_REQUEST](createTopics({ topics, validateOnly, timeout }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {Array} request.topicPartitions e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     count: 3,\n   *                     assignments: []\n   *                   }\n   *                 ]\n   * @param {boolean} [request.validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise<void>}\n   */\n  async createPartitions({ topicPartitions, validateOnly = false, timeout = 5000 }) {\n    const createPartitions = this.lookupRequest(apiKeys.CreatePartitions, requests.CreatePartitions)\n    return await this[PRIVATE.SEND_REQUEST](\n      createPartitions({ topicPartitions, validateOnly, timeout })\n    )\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {string[]} request.topics An array of topics to be deleted\n   * @param {number} [request.timeout=5000] The time in ms to wait for a topic to be completely deleted on the\n   *                                controller node.\n   * @returns {Promise}\n   */\n  async deleteTopics({ topics, timeout = 5000 }) {\n    const deleteTopics = this.lookupRequest(apiKeys.DeleteTopics, requests.DeleteTopics)\n    return await this[PRIVATE.SEND_REQUEST](deleteTopics({ topics, timeout }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").ResourceConfigQuery[]} request.resources\n   *                                 [{\n   *                                   type: RESOURCE_TYPES.TOPIC,\n   *                                   name: 'topic-name',\n   *                                   configNames: ['compression.type', 'retention.ms']\n   *                                 }]\n   * @param {boolean} [request.includeSynonyms=false]\n   * @returns {Promise}\n   */\n  async describeConfigs({ resources, includeSynonyms = false }) {\n    const describeConfigs = this.lookupRequest(apiKeys.DescribeConfigs, requests.DescribeConfigs)\n    return await this[PRIVATE.SEND_REQUEST](describeConfigs({ resources, includeSynonyms }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").IResourceConfig[]} request.resources\n   *                                 [{\n   *                                  type: RESOURCE_TYPES.TOPIC,\n   *                                  name: 'topic-name',\n   *                                  configEntries: [\n   *                                    {\n   *                                      name: 'cleanup.policy',\n   *                                      value: 'compact'\n   *                                    }\n   *                                  ]\n   *                                 }]\n   * @param {boolean} [request.validateOnly=false]\n   * @returns {Promise}\n   */\n  async alterConfigs({ resources, validateOnly = false }) {\n    const alterConfigs = this.lookupRequest(apiKeys.AlterConfigs, requests.AlterConfigs)\n    return await this[PRIVATE.SEND_REQUEST](alterConfigs({ resources, validateOnly }))\n  }\n\n  /**\n   * Send an `InitProducerId` request to fetch a PID and bump the producer epoch.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {number} request.transactionTimeout The time in ms to wait for before aborting idle transactions\n   * @param {number} [request.transactionalId] The transactional id or null if the producer is not transactional\n   * @returns {Promise}\n   */\n  async initProducerId({ transactionalId, transactionTimeout }) {\n    const initProducerId = this.lookupRequest(apiKeys.InitProducerId, requests.InitProducerId)\n    return await this[PRIVATE.SEND_REQUEST](initProducerId({ transactionalId, transactionTimeout }))\n  }\n\n  /**\n   * Send an `AddPartitionsToTxn` request to mark a TopicPartition as participating in the transaction.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {object[]} request.topics e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [ 0, 1]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics }) {\n    const addPartitionsToTxn = this.lookupRequest(\n      apiKeys.AddPartitionsToTxn,\n      requests.AddPartitionsToTxn\n    )\n    return await this[PRIVATE.SEND_REQUEST](\n      addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics })\n    )\n  }\n\n  /**\n   * Send an `AddOffsetsToTxn` request.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {string} request.groupId The unique group identifier (for the consumer group)\n   * @returns {Promise}\n   */\n  async addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId }) {\n    const addOffsetsToTxn = this.lookupRequest(apiKeys.AddOffsetsToTxn, requests.AddOffsetsToTxn)\n    return await this[PRIVATE.SEND_REQUEST](\n      addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId })\n    )\n  }\n\n  /**\n   * Send a `TxnOffsetCommit` request to persist the offsets in the `__consumer_offsets` topics.\n   *\n   * Request should be made to the consumer coordinator.\n   * @public\n   * @param {object} request\n   * @param {OffsetCommitTopic[]} request.topics\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {string} request.groupId The unique group identifier (for the consumer group)\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {OffsetCommitTopic[]} request.topics\n   *\n   * @typedef {Object} OffsetCommitTopic\n   * @property {string} topic\n   * @property {OffsetCommitTopicPartition[]} partitions\n   *\n   * @typedef {Object} OffsetCommitTopicPartition\n   * @property {number} partition\n   * @property {number} offset\n   * @property {string} [metadata]\n   *\n   * @returns {Promise}\n   */\n  async txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics }) {\n    const txnOffsetCommit = this.lookupRequest(apiKeys.TxnOffsetCommit, requests.TxnOffsetCommit)\n    return await this[PRIVATE.SEND_REQUEST](\n      txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics })\n    )\n  }\n\n  /**\n   * Send an `EndTxn` request to indicate transaction should be committed or aborted.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {object} request\n   * @param {string} request.transactionalId The transactional id corresponding to the transaction.\n   * @param {number} request.producerId Current producer id in use by the transactional id.\n   * @param {number} request.producerEpoch Current epoch associated with the producer id.\n   * @param {boolean} request.transactionResult The result of the transaction (false = ABORT, true = COMMIT)\n   * @returns {Promise}\n   */\n  async endTxn({ transactionalId, producerId, producerEpoch, transactionResult }) {\n    const endTxn = this.lookupRequest(apiKeys.EndTxn, requests.EndTxn)\n    return await this[PRIVATE.SEND_REQUEST](\n      endTxn({ transactionalId, producerId, producerEpoch, transactionResult })\n    )\n  }\n\n  /**\n   * Send request for list of groups\n   * @public\n   * @returns {Promise}\n   */\n  async listGroups() {\n    const listGroups = this.lookupRequest(apiKeys.ListGroups, requests.ListGroups)\n    return await this[PRIVATE.SEND_REQUEST](listGroups())\n  }\n\n  /**\n   * Send request to delete groups\n   * @param {string[]} groupIds\n   * @public\n   * @returns {Promise}\n   */\n  async deleteGroups(groupIds) {\n    const deleteGroups = this.lookupRequest(apiKeys.DeleteGroups, requests.DeleteGroups)\n    return await this[PRIVATE.SEND_REQUEST](deleteGroups(groupIds))\n  }\n\n  /**\n   * Send request to delete records\n   * @public\n   * @param {object} request\n   * @param {TopicPartitionRecords[]} request.topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset 2 },\n   *                                { partition: 1, offset 4 },\n   *                              ],\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          {\n   *                            throttleTime: 0\n   *                           [\n   *                              {\n   *                                topic: 'my-topic-name',\n   *                                partitions: [\n   *                                 { partition: 0, lowWatermark: '2n', errorCode: 0 },\n   *                                 { partition: 1, lowWatermark: '4n', errorCode: 0 },\n   *                               ],\n   *                             },\n   *                           ]\n   *                          }\n   *\n   * @typedef {object} TopicPartitionRecords\n   * @property {string} topic\n   * @property {PartitionRecord[]} partitions\n   *\n   * @typedef {object} PartitionRecord\n   * @property {number} partition\n   * @property {number} offset\n   */\n  async deleteRecords({ topics }) {\n    const deleteRecords = this.lookupRequest(apiKeys.DeleteRecords, requests.DeleteRecords)\n    return await this[PRIVATE.SEND_REQUEST](deleteRecords({ topics }))\n  }\n\n  /**\n   * @public\n   * @param {object} request\n   * @param {import(\"../../types\").AclEntry[]} request.acl e.g:\n   *                 [\n   *                   {\n   *                     resourceType: AclResourceTypes.TOPIC,\n   *                     resourceName: 'topic-name',\n   *                     resourcePatternType: ResourcePatternTypes.LITERAL,\n   *                     principal: 'User:bob',\n   *                     host: '*',\n   *                     operation: AclOperationTypes.ALL,\n   *                     permissionType: AclPermissionTypes.DENY,\n   *                   }\n   *                 ]\n   * @returns {Promise<void>}\n   */\n  async createAcls({ acl }) {\n    const createAcls = this.lookupRequest(apiKeys.CreateAcls, requests.CreateAcls)\n    return await this[PRIVATE.SEND_REQUEST](createAcls({ creations: acl }))\n  }\n\n  /**\n   * @public\n   * @param {import(\"../../types\").AclEntry} aclEntry\n   * @returns {Promise<void>}\n   */\n  async describeAcls({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType,\n  }) {\n    const describeAcls = this.lookupRequest(apiKeys.DescribeAcls, requests.DescribeAcls)\n    return await this[PRIVATE.SEND_REQUEST](\n      describeAcls({\n        resourceType,\n        resourceName,\n        resourcePatternType,\n        principal,\n        host,\n        operation,\n        permissionType,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").AclEntry[]} request.filters\n   * @returns {Promise<void>}\n   */\n  async deleteAcls({ filters }) {\n    const deleteAcls = this.lookupRequest(apiKeys.DeleteAcls, requests.DeleteAcls)\n    return await this[PRIVATE.SEND_REQUEST](deleteAcls({ filters }))\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").PartitionReassignment[]} request.topics\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  async alterPartitionReassignments({ topics, timeout }) {\n    const alterPartitionReassignments = this.lookupRequest(\n      apiKeys.AlterPartitionReassignments,\n      requests.AlterPartitionReassignments\n    )\n    return await this[PRIVATE.SEND_REQUEST](alterPartitionReassignments({ topics, timeout }))\n  }\n\n  /**\n   * @public\n   * @param {Object} request\n   * @param {import(\"../../types\").TopicPartitions[]} request.topics can be null\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  async listPartitionReassignments({ topics = null, timeout }) {\n    const listPartitionReassignments = this.lookupRequest(\n      apiKeys.ListPartitionReassignments,\n      requests.ListPartitionReassignments\n    )\n    return await this[PRIVATE.SEND_REQUEST](listPartitionReassignments({ topics, timeout }))\n  }\n\n  /**\n   * @private\n   */\n  async [PRIVATE.SEND_REQUEST](protocolRequest) {\n    try {\n      return await this.connectionPool.send(protocolRequest)\n    } catch (e) {\n      if (e.name === 'KafkaJSConnectionClosedError') {\n        await this.disconnect()\n      }\n\n      throw e\n    }\n  }\n}\n"],"mappings":";AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAe,CAAC;AACrC,MAAM;EAAEC,KAAK,EAAEC;AAAY,CAAC,GAAGF,OAAO,CAAC,iCAAiC,CAAC;AACzE,MAAM;EAAEG,QAAQ;EAAEC;AAAO,CAAC,GAAGJ,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAM;EAAEK;AAAyB,CAAC,GAAGL,OAAO,CAAC,WAAW,CAAC;AACzD,MAAMM,OAAO,GAAGN,OAAO,CAAC,8BAA8B,CAAC;AACvD,MAAMO,OAAO,GAAGP,OAAO,CAAC,kBAAkB,CAAC;AAE3C,MAAMQ,OAAO,GAAG;EACdC,YAAY,EAAEC,MAAM,CAAC,4BAA4B;AACnD,CAAC;;AAED;AACA,MAAMC,oBAAoB,GAAG,MAAM;EACjC,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;AACzC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,MAAMC,MAAM,CAAC;EAC5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAW,CAAC;IACVC,cAAc;IACdC,MAAM;IACNC,MAAM,GAAG,IAAI;IACbC,QAAQ,GAAG,IAAI;IACfC,qBAAqB,GAAG,KAAK;IAC7BC,sBAAsB,GAAG;EAC3B,CAAC,EAAE;IACD,IAAI,CAACL,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACE,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACI,UAAU,GAAGL,MAAM;IACxB,IAAI,CAACA,MAAM,GAAGA,MAAM,CAACM,SAAS,CAAC,QAAQ,CAAC;IACxC,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACC,sBAAsB,GAAGA,sBAAsB;;IAEpD;IACA;IACA,MAAMG,WAAW,GAAG,CAAC,GAAG,IAAI,CAACR,cAAc,CAACS,iBAAiB,GAAG,IAAI,CAACL,qBAAqB;IAC1F,IAAI,CAACM,aAAa,GAAI,GAAE,IAAI,CAACV,cAAc,CAACW,IAAK,IAAG,IAAI,CAACX,cAAc,CAACY,IAAK,EAAC;IAE9E,IAAI,CAACC,IAAI,GAAG,IAAI/B,IAAI,CAAC;MACnBgC,OAAO,EAAEN,WAAW;MACpBO,WAAW,EAAG,qBAAoB,IAAI,CAACL,aAAc;IACvD,CAAC,CAAC;IAEF,IAAI,CAACM,aAAa,GAAGtB,oBAAoB;EAC3C;;EAEA;AACF;AACA;AACA;EACEuB,WAAW,GAAG;IACZ,OAAO,IAAI,CAACjB,cAAc,CAACkB,IAAI,GAC3B,IAAI,CAAClB,cAAc,CAACiB,WAAW,EAAE,IAAI,IAAI,CAACjB,cAAc,CAACmB,eAAe,EAAE,GAC1E,IAAI,CAACnB,cAAc,CAACiB,WAAW,EAAE;EACvC;;EAEA;AACF;AACA;AACA;EACQG,OAAO,GAAG;IAAA;IAAA;MACd,MAAM,KAAI,CAACP,IAAI,CAACQ,OAAO,EAAE;MACzB,IAAI;QACF,IAAI,KAAI,CAACJ,WAAW,EAAE,EAAE;UACtB;QACF;QAEA,MAAMK,UAAU,SAAS,KAAI,CAACtB,cAAc,CAACuB,aAAa,EAAE;QAE5D,IAAI,CAAC,KAAI,CAACpB,QAAQ,EAAE;UAClB,KAAI,CAACA,QAAQ,SAAS,KAAI,CAACqB,WAAW,EAAE;QAC1C;QACA,KAAI,CAACxB,cAAc,CAACyB,WAAW,CAAC,KAAI,CAACtB,QAAQ,CAAC;QAE9C,KAAI,CAACa,aAAa,GAAG7B,MAAM,CAAC,KAAI,CAACgB,QAAQ,CAAC;QAE1C,IAAImB,UAAU,CAACI,gCAAgC,EAAE,KAAK,IAAI,EAAE;UAC1D,IAAIC,6BAA6B,GAAG,KAAK;UACzC,IAAI;YACF,KAAI,CAACX,aAAa,CAAC3B,OAAO,CAACuC,gBAAgB,EAAE1C,QAAQ,CAAC0C,gBAAgB,CAAC;YACvED,6BAA6B,GAAG,IAAI;UACtC,CAAC,CAAC,OAAOE,CAAC,EAAE;YACVF,6BAA6B,GAAG,KAAK;UACvC;UACA,KAAI,CAAC3B,cAAc,CAAC8B,gCAAgC,CAACH,6BAA6B,CAAC;UAEnF,KAAI,CAAC1B,MAAM,CAAC8B,KAAK,CAAE,uCAAsC,EAAE;YACzDC,MAAM,EAAE,KAAI,CAACtB,aAAa;YAC1BiB;UACF,CAAC,CAAC;QACJ;QAEA,MAAML,UAAU,CAACW,YAAY,EAAE;MACjC,CAAC,SAAS;QACR,MAAM,KAAI,CAACpB,IAAI,CAACqB,OAAO,EAAE;MAC3B;IAAC;EACH;;EAEA;AACF;AACA;AACA;EACQC,UAAU,GAAG;IAAA;IAAA;MACjB,MAAM,MAAI,CAACnC,cAAc,CAACoC,OAAO,EAAE;IAAA;EACrC;;EAEA;AACF;AACA;AACA;EACQZ,WAAW,GAAG;IAAA;IAAA;MAClB,IAAIa,QAAQ;MACZ,MAAMC,iBAAiB,GAAGpD,QAAQ,CAACqD,WAAW,CAACpC,QAAQ,CACpDqC,GAAG,CAACC,MAAM,CAAC,CACXC,IAAI,EAAE,CACNC,OAAO,EAAE;;MAEZ;MACA,KAAK,MAAMC,gBAAgB,IAAIN,iBAAiB,EAAE;QAChD,IAAI;UACF,MAAMd,WAAW,GAAGtC,QAAQ,CAACqD,WAAW,CAACM,QAAQ,CAAC;YAAEC,OAAO,EAAEF;UAAiB,CAAC,CAAC;UAChFP,QAAQ,SAAS,MAAI,CAAC9C,OAAO,CAACC,YAAY,CAAC,CAAC;YAC1C,GAAGgC,WAAW,EAAE;YAChBuB,cAAc,EAAE,MAAI,CAAC/C,cAAc,CAACS;UACtC,CAAC,CAAC;UACF;QACF,CAAC,CAAC,OAAOuC,CAAC,EAAE;UACV,IAAIA,CAAC,CAACC,IAAI,KAAK,qBAAqB,EAAE;YACpC,MAAMD,CAAC;UACT;QACF;MACF;MAEA,IAAI,CAACX,QAAQ,EAAE;QACb,MAAM,IAAIjD,wBAAwB,CAAC,4BAA4B,CAAC;MAClE;MAEA,OAAOiD,QAAQ,CAACb,WAAW,CAAC0B,MAAM,CAChC,CAACC,GAAG,EAAEL,OAAO,KACXM,MAAM,CAACC,MAAM,CAACF,GAAG,EAAE;QACjB,CAACL,OAAO,CAACQ,MAAM,GAAG;UAChBC,UAAU,EAAET,OAAO,CAACS,UAAU;UAC9BC,UAAU,EAAEV,OAAO,CAACU;QACtB;MACF,CAAC,CAAC,EACJ,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACQC,QAAQ,CAACC,MAAM,GAAG,EAAE,EAAE;IAAA;IAAA;MAC1B,MAAMD,QAAQ,GAAG,MAAI,CAACzC,aAAa,CAAC3B,OAAO,CAACsE,QAAQ,EAAEzE,QAAQ,CAACyE,QAAQ,CAAC;MACxE,MAAMC,cAAc,GAAGtE,OAAO,CAACoE,MAAM,CAAC;MACtC,aAAa,MAAI,CAACnE,OAAO,CAACC,YAAY,CAAC,CACrCiE,QAAQ,CAAC;QAAEC,MAAM,EAAEE,cAAc;QAAEvD,sBAAsB,EAAE,MAAI,CAACA;MAAuB,CAAC,CAAC,CAC1F;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQwD,OAAO,CAAC;IACZC,SAAS;IACTC,eAAe;IACfC,UAAU;IACVC,aAAa;IACbC,IAAI,GAAG,CAAC,CAAC;IACTpD,OAAO,GAAG,KAAK;IACfqD,WAAW,GAAGlF,WAAW,CAACmF;EAC5B,CAAC,EAAE;IAAA;IAAA;MACD,MAAMP,OAAO,GAAG,MAAI,CAAC7C,aAAa,CAAC3B,OAAO,CAACgF,OAAO,EAAEnF,QAAQ,CAACmF,OAAO,CAAC;MACrE,aAAa,MAAI,CAAC9E,OAAO,CAACC,YAAY,CAAC,CACrCqE,OAAO,CAAC;QACNK,IAAI;QACJpD,OAAO;QACPqD,WAAW;QACXL,SAAS;QACTC,eAAe;QACfC,UAAU;QACVC;MACF,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQK,KAAK,CAAC;IACVC,SAAS;IACTC,cAAc;IACdC,WAAW,GAAG,IAAI;IAClBC,QAAQ,GAAG,CAAC;IACZC,QAAQ,GAAG,QAAQ;IACnBjB,MAAM;IACNkB,MAAM,GAAG;EACX,CAAC,EAAE;IAAA;IAAA;MACD;MACA,MAAMN,KAAK,GAAG,MAAI,CAACtD,aAAa,CAAC3B,OAAO,CAACwF,KAAK,EAAE3F,QAAQ,CAAC2F,KAAK,CAAC;;MAE/D;MACA,MAAMC,wBAAwB,GAAGpB,MAAM,CAACR,MAAM,CAAC,CAAC6B,eAAe,EAAE;QAAEC,KAAK;QAAEC;MAAW,CAAC,KAAK;QACzFA,UAAU,CAACC,OAAO,CAACC,SAAS,IAAI;UAC9BJ,eAAe,CAACK,IAAI,CAAC;YAAEJ,KAAK;YAAEG;UAAU,CAAC,CAAC;QAC5C,CAAC,CAAC;QACF,OAAOJ,eAAe;MACxB,CAAC,EAAE,EAAE,CAAC;MAEN,MAAMM,uBAAuB,GAAG/F,OAAO,CAACwF,wBAAwB,CAAC;;MAEjE;MACA,MAAMQ,2BAA2B,GAAGD,uBAAuB,CAACnC,MAAM,CAChE,CAAC6B,eAAe,EAAE;QAAEC,KAAK;QAAEG;MAAU,CAAC,KAAK;QACzC,MAAMI,IAAI,GAAGR,eAAe,CAACA,eAAe,CAACS,MAAM,GAAG,CAAC,CAAC;QAExD,IAAID,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACP,KAAK,KAAKA,KAAK,EAAE;UACxCD,eAAe,CAACA,eAAe,CAACS,MAAM,GAAG,CAAC,CAAC,CAACP,UAAU,CAACG,IAAI,CAACD,SAAS,CAAC;QACxE,CAAC,MAAM;UACLJ,eAAe,CAACK,IAAI,CAAC;YAAEJ,KAAK;YAAEC,UAAU,EAAE,CAACE,SAAS;UAAE,CAAC,CAAC;QAC1D;QAEA,OAAOJ,eAAe;MACxB,CAAC,EACD,EAAE,CACH;MAED,aAAa,MAAI,CAACxF,OAAO,CAACC,YAAY,CAAC,CACrC8E,KAAK,CAAC;QACJC,SAAS;QACTC,cAAc;QACdC,WAAW;QACXC,QAAQ;QACRC,QAAQ;QACRjB,MAAM,EAAE4B,2BAA2B;QACnCV;MACF,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACQa,SAAS,CAAC;IAAEC,OAAO;IAAEC,iBAAiB;IAAEC;EAAS,CAAC,EAAE;IAAA;IAAA;MACxD,MAAMH,SAAS,GAAG,MAAI,CAACzE,aAAa,CAAC3B,OAAO,CAACwG,SAAS,EAAE3G,QAAQ,CAAC2G,SAAS,CAAC;MAC3E,aAAa,MAAI,CAACtG,OAAO,CAACC,YAAY,CAAC,CAACiG,SAAS,CAAC;QAAEC,OAAO;QAAEC,iBAAiB;QAAEC;MAAS,CAAC,CAAC,CAAC;IAAA;EAC9F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACQE,oBAAoB,CAAC;IAAEJ,OAAO;IAAEK;EAAgB,CAAC,EAAE;IAAA;IAAA;MACvD;MACA,MAAMC,eAAe,GAAG,MAAI,CAAChF,aAAa,CAAC3B,OAAO,CAAC4G,gBAAgB,EAAE/G,QAAQ,CAAC+G,gBAAgB,CAAC;MAC/F,aAAa,MAAI,CAAC1G,OAAO,CAACC,YAAY,CAAC,CAACwG,eAAe,CAAC;QAAEN,OAAO;QAAEK;MAAgB,CAAC,CAAC,CAAC;IAAA;EACxF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQG,SAAS,CAAC;IACdR,OAAO;IACPS,cAAc;IACdC,gBAAgB;IAChBR,QAAQ,GAAG,EAAE;IACbS,YAAY,GAAG,UAAU;IACzBC;EACF,CAAC,EAAE;IAAA;IAAA;MACD,MAAMJ,SAAS,GAAG,MAAI,CAAClF,aAAa,CAAC3B,OAAO,CAACkH,SAAS,EAAErH,QAAQ,CAACqH,SAAS,CAAC;MAC3E,MAAMC,WAAW,GAAG,CAACC,gBAAgB,GAAGb,QAAQ,KAC9C,MAAI,CAACrG,OAAO,CAACC,YAAY,CAAC,CACxB0G,SAAS,CAAC;QACRR,OAAO;QACPS,cAAc;QACdC,gBAAgB;QAChBR,QAAQ,EAAEa,gBAAgB;QAC1BJ,YAAY;QACZC;MACF,CAAC,CAAC,CACH;MAEH,IAAI;QACF,aAAaE,WAAW,EAAE;MAC5B,CAAC,CAAC,OAAOE,KAAK,EAAE;QACd,IAAIA,KAAK,CAACC,IAAI,KAAK,yBAAyB,EAAE;UAC5C,OAAOH,WAAW,CAACE,KAAK,CAACd,QAAQ,CAAC;QACpC;QAEA,MAAMc,KAAK;MACb;IAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACQE,UAAU,CAAC;IAAElB,OAAO;IAAEE;EAAS,CAAC,EAAE;IAAA;IAAA;MACtC,MAAMgB,UAAU,GAAG,OAAI,CAAC5F,aAAa,CAAC3B,OAAO,CAACwH,UAAU,EAAE3H,QAAQ,CAAC2H,UAAU,CAAC;MAC9E,aAAa,OAAI,CAACtH,OAAO,CAACC,YAAY,CAAC,CAACoH,UAAU,CAAC;QAAElB,OAAO;QAAEE;MAAS,CAAC,CAAC,CAAC;IAAA;EAC5E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQkB,SAAS,CAAC;IAAEpB,OAAO;IAAEqB,YAAY;IAAEnB,QAAQ;IAAEoB;EAAgB,CAAC,EAAE;IAAA;IAAA;MACpE,MAAMF,SAAS,GAAG,OAAI,CAAC9F,aAAa,CAAC3B,OAAO,CAAC4H,SAAS,EAAE/H,QAAQ,CAAC+H,SAAS,CAAC;MAC3E,aAAa,OAAI,CAAC1H,OAAO,CAACC,YAAY,CAAC,CACrCsH,SAAS,CAAC;QACRpB,OAAO;QACPqB,YAAY;QACZnB,QAAQ;QACRoB;MACF,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQE,WAAW,CAAC;IAAE3C,SAAS;IAAEC,cAAc;IAAEd;EAAO,CAAC,EAAE;IAAA;IAAA;MACvD,MAAMwD,WAAW,GAAG,OAAI,CAAClG,aAAa,CAAC3B,OAAO,CAAC8H,WAAW,EAAEjI,QAAQ,CAACiI,WAAW,CAAC;MACjF,MAAMC,MAAM,SAAS,OAAI,CAAC7H,OAAO,CAACC,YAAY,CAAC,CAC7C0H,WAAW,CAAC;QAAE3C,SAAS;QAAEC,cAAc;QAAEd;MAAO,CAAC,CAAC,CACnD;;MAED;MACA;MACA,KAAK,MAAMrB,QAAQ,IAAI+E,MAAM,CAACC,SAAS,EAAE;QACvChF,QAAQ,CAAC4C,UAAU,GAAG5C,QAAQ,CAAC4C,UAAU,CAACzC,GAAG,CAAC,CAAC;UAAE8E,OAAO;UAAE,GAAGC;QAAc,CAAC,KAAK;UAC/E,OAAOD,OAAO,GAAG;YAAE,GAAGC,aAAa;YAAEC,MAAM,EAAEF,OAAO,CAACG,GAAG;UAAG,CAAC,GAAGF,aAAa;QAC9E,CAAC,CAAC;MACJ;MAEA,OAAOH,MAAM;IAAA;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQM,YAAY,CAAC;IAAEhC,OAAO;IAAEC,iBAAiB;IAAEC,QAAQ;IAAE+B,aAAa;IAAEjE;EAAO,CAAC,EAAE;IAAA;IAAA;MAClF,MAAMgE,YAAY,GAAG,OAAI,CAAC1G,aAAa,CAAC3B,OAAO,CAACuI,YAAY,EAAE1I,QAAQ,CAAC0I,YAAY,CAAC;MACpF,aAAa,OAAI,CAACrI,OAAO,CAACC,YAAY,CAAC,CACrCkI,YAAY,CAAC;QACXhC,OAAO;QACPC,iBAAiB;QACjBC,QAAQ;QACR+B,aAAa;QACbjE;MACF,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQmE,WAAW,CAAC;IAAEnC,OAAO;IAAEhC;EAAO,CAAC,EAAE;IAAA;IAAA;MACrC,MAAMmE,WAAW,GAAG,OAAI,CAAC7G,aAAa,CAAC3B,OAAO,CAACyI,WAAW,EAAE5I,QAAQ,CAAC4I,WAAW,CAAC;MACjF,aAAa,OAAI,CAACvI,OAAO,CAACC,YAAY,CAAC,CAACqI,WAAW,CAAC;QAAEnC,OAAO;QAAEhC;MAAO,CAAC,CAAC,CAAC;IAAA;EAC3E;;EAEA;AACF;AACA;AACA;AACA;AACA;EACQqE,cAAc,CAAC;IAAEC;EAAS,CAAC,EAAE;IAAA;IAAA;MACjC,MAAMD,cAAc,GAAG,OAAI,CAAC/G,aAAa,CAAC3B,OAAO,CAAC4I,cAAc,EAAE/I,QAAQ,CAAC+I,cAAc,CAAC;MAC1F,aAAa,OAAI,CAAC1I,OAAO,CAACC,YAAY,CAAC,CAACuI,cAAc,CAAC;QAAEC;MAAS,CAAC,CAAC,CAAC;IAAA;EACvE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQE,YAAY,CAAC;IAAExE,MAAM;IAAEyE,YAAY,GAAG,KAAK;IAAErH,OAAO,GAAG;EAAK,CAAC,EAAE;IAAA;IAAA;MACnE,MAAMoH,YAAY,GAAG,OAAI,CAAClH,aAAa,CAAC3B,OAAO,CAAC+I,YAAY,EAAElJ,QAAQ,CAACkJ,YAAY,CAAC;MACpF,aAAa,OAAI,CAAC7I,OAAO,CAACC,YAAY,CAAC,CAAC0I,YAAY,CAAC;QAAExE,MAAM;QAAEyE,YAAY;QAAErH;MAAQ,CAAC,CAAC,CAAC;IAAA;EAC1F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQuH,gBAAgB,CAAC;IAAEtD,eAAe;IAAEoD,YAAY,GAAG,KAAK;IAAErH,OAAO,GAAG;EAAK,CAAC,EAAE;IAAA;IAAA;MAChF,MAAMuH,gBAAgB,GAAG,OAAI,CAACrH,aAAa,CAAC3B,OAAO,CAACiJ,gBAAgB,EAAEpJ,QAAQ,CAACoJ,gBAAgB,CAAC;MAChG,aAAa,OAAI,CAAC/I,OAAO,CAACC,YAAY,CAAC,CACrC6I,gBAAgB,CAAC;QAAEtD,eAAe;QAAEoD,YAAY;QAAErH;MAAQ,CAAC,CAAC,CAC7D;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACQyH,YAAY,CAAC;IAAE7E,MAAM;IAAE5C,OAAO,GAAG;EAAK,CAAC,EAAE;IAAA;IAAA;MAC7C,MAAMyH,YAAY,GAAG,OAAI,CAACvH,aAAa,CAAC3B,OAAO,CAACmJ,YAAY,EAAEtJ,QAAQ,CAACsJ,YAAY,CAAC;MACpF,aAAa,OAAI,CAACjJ,OAAO,CAACC,YAAY,CAAC,CAAC+I,YAAY,CAAC;QAAE7E,MAAM;QAAE5C;MAAQ,CAAC,CAAC,CAAC;IAAA;EAC5E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ2H,eAAe,CAAC;IAAEC,SAAS;IAAEC,eAAe,GAAG;EAAM,CAAC,EAAE;IAAA;IAAA;MAC5D,MAAMF,eAAe,GAAG,OAAI,CAACzH,aAAa,CAAC3B,OAAO,CAACuJ,eAAe,EAAE1J,QAAQ,CAAC0J,eAAe,CAAC;MAC7F,aAAa,OAAI,CAACrJ,OAAO,CAACC,YAAY,CAAC,CAACiJ,eAAe,CAAC;QAAEC,SAAS;QAAEC;MAAgB,CAAC,CAAC,CAAC;IAAA;EAC1F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQE,YAAY,CAAC;IAAEH,SAAS;IAAEP,YAAY,GAAG;EAAM,CAAC,EAAE;IAAA;IAAA;MACtD,MAAMU,YAAY,GAAG,OAAI,CAAC7H,aAAa,CAAC3B,OAAO,CAACyJ,YAAY,EAAE5J,QAAQ,CAAC4J,YAAY,CAAC;MACpF,aAAa,OAAI,CAACvJ,OAAO,CAACC,YAAY,CAAC,CAACqJ,YAAY,CAAC;QAAEH,SAAS;QAAEP;MAAa,CAAC,CAAC,CAAC;IAAA;EACpF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQY,cAAc,CAAC;IAAEhF,eAAe;IAAEiF;EAAmB,CAAC,EAAE;IAAA;IAAA;MAC5D,MAAMD,cAAc,GAAG,OAAI,CAAC/H,aAAa,CAAC3B,OAAO,CAAC4J,cAAc,EAAE/J,QAAQ,CAAC+J,cAAc,CAAC;MAC1F,aAAa,OAAI,CAAC1J,OAAO,CAACC,YAAY,CAAC,CAACuJ,cAAc,CAAC;QAAEhF,eAAe;QAAEiF;MAAmB,CAAC,CAAC,CAAC;IAAA;EAClG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQE,kBAAkB,CAAC;IAAEnF,eAAe;IAAEC,UAAU;IAAEC,aAAa;IAAEP;EAAO,CAAC,EAAE;IAAA;IAAA;MAC/E,MAAMwF,kBAAkB,GAAG,OAAI,CAAClI,aAAa,CAC3C3B,OAAO,CAAC8J,kBAAkB,EAC1BjK,QAAQ,CAACiK,kBAAkB,CAC5B;MACD,aAAa,OAAI,CAAC5J,OAAO,CAACC,YAAY,CAAC,CACrC0J,kBAAkB,CAAC;QAAEnF,eAAe;QAAEC,UAAU;QAAEC,aAAa;QAAEP;MAAO,CAAC,CAAC,CAC3E;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ0F,eAAe,CAAC;IAAErF,eAAe;IAAEC,UAAU;IAAEC,aAAa;IAAEyB;EAAQ,CAAC,EAAE;IAAA;IAAA;MAC7E,MAAM0D,eAAe,GAAG,OAAI,CAACpI,aAAa,CAAC3B,OAAO,CAACgK,eAAe,EAAEnK,QAAQ,CAACmK,eAAe,CAAC;MAC7F,aAAa,OAAI,CAAC9J,OAAO,CAACC,YAAY,CAAC,CACrC4J,eAAe,CAAC;QAAErF,eAAe;QAAEC,UAAU;QAAEC,aAAa;QAAEyB;MAAQ,CAAC,CAAC,CACzE;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ4D,eAAe,CAAC;IAAEvF,eAAe;IAAE2B,OAAO;IAAE1B,UAAU;IAAEC,aAAa;IAAEP;EAAO,CAAC,EAAE;IAAA;IAAA;MACrF,MAAM4F,eAAe,GAAG,OAAI,CAACtI,aAAa,CAAC3B,OAAO,CAACkK,eAAe,EAAErK,QAAQ,CAACqK,eAAe,CAAC;MAC7F,aAAa,OAAI,CAAChK,OAAO,CAACC,YAAY,CAAC,CACrC8J,eAAe,CAAC;QAAEvF,eAAe;QAAE2B,OAAO;QAAE1B,UAAU;QAAEC,aAAa;QAAEP;MAAO,CAAC,CAAC,CACjF;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ8F,MAAM,CAAC;IAAEzF,eAAe;IAAEC,UAAU;IAAEC,aAAa;IAAEwF;EAAkB,CAAC,EAAE;IAAA;IAAA;MAC9E,MAAMD,MAAM,GAAG,OAAI,CAACxI,aAAa,CAAC3B,OAAO,CAACqK,MAAM,EAAExK,QAAQ,CAACwK,MAAM,CAAC;MAClE,aAAa,OAAI,CAACnK,OAAO,CAACC,YAAY,CAAC,CACrCgK,MAAM,CAAC;QAAEzF,eAAe;QAAEC,UAAU;QAAEC,aAAa;QAAEwF;MAAkB,CAAC,CAAC,CAC1E;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;EACQE,UAAU,GAAG;IAAA;IAAA;MACjB,MAAMA,UAAU,GAAG,OAAI,CAAC3I,aAAa,CAAC3B,OAAO,CAACuK,UAAU,EAAE1K,QAAQ,CAAC0K,UAAU,CAAC;MAC9E,aAAa,OAAI,CAACrK,OAAO,CAACC,YAAY,CAAC,CAACmK,UAAU,EAAE,CAAC;IAAA;EACvD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACQE,YAAY,CAAC7B,QAAQ,EAAE;IAAA;IAAA;MAC3B,MAAM6B,YAAY,GAAG,OAAI,CAAC7I,aAAa,CAAC3B,OAAO,CAACyK,YAAY,EAAE5K,QAAQ,CAAC4K,YAAY,CAAC;MACpF,aAAa,OAAI,CAACvK,OAAO,CAACC,YAAY,CAAC,CAACqK,YAAY,CAAC7B,QAAQ,CAAC,CAAC;IAAA;EACjE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ+B,aAAa,CAAC;IAAErG;EAAO,CAAC,EAAE;IAAA;IAAA;MAC9B,MAAMqG,aAAa,GAAG,OAAI,CAAC/I,aAAa,CAAC3B,OAAO,CAAC2K,aAAa,EAAE9K,QAAQ,CAAC8K,aAAa,CAAC;MACvF,aAAa,OAAI,CAACzK,OAAO,CAACC,YAAY,CAAC,CAACuK,aAAa,CAAC;QAAErG;MAAO,CAAC,CAAC,CAAC;IAAA;EACpE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQuG,UAAU,CAAC;IAAEC;EAAI,CAAC,EAAE;IAAA;IAAA;MACxB,MAAMD,UAAU,GAAG,OAAI,CAACjJ,aAAa,CAAC3B,OAAO,CAAC8K,UAAU,EAAEjL,QAAQ,CAACiL,UAAU,CAAC;MAC9E,aAAa,OAAI,CAAC5K,OAAO,CAACC,YAAY,CAAC,CAACyK,UAAU,CAAC;QAAEG,SAAS,EAAEF;MAAI,CAAC,CAAC,CAAC;IAAA;EACzE;;EAEA;AACF;AACA;AACA;AACA;EACQG,YAAY,CAAC;IACjBC,YAAY;IACZC,YAAY;IACZC,mBAAmB;IACnBC,SAAS;IACT9J,IAAI;IACJ+J,SAAS;IACTC;EACF,CAAC,EAAE;IAAA;IAAA;MACD,MAAMN,YAAY,GAAG,OAAI,CAACrJ,aAAa,CAAC3B,OAAO,CAACuL,YAAY,EAAE1L,QAAQ,CAAC0L,YAAY,CAAC;MACpF,aAAa,OAAI,CAACrL,OAAO,CAACC,YAAY,CAAC,CACrC6K,YAAY,CAAC;QACXC,YAAY;QACZC,YAAY;QACZC,mBAAmB;QACnBC,SAAS;QACT9J,IAAI;QACJ+J,SAAS;QACTC;MACF,CAAC,CAAC,CACH;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACQE,UAAU,CAAC;IAAEC;EAAQ,CAAC,EAAE;IAAA;IAAA;MAC5B,MAAMD,UAAU,GAAG,OAAI,CAAC7J,aAAa,CAAC3B,OAAO,CAAC0L,UAAU,EAAE7L,QAAQ,CAAC6L,UAAU,CAAC;MAC9E,aAAa,OAAI,CAACxL,OAAO,CAACC,YAAY,CAAC,CAACqL,UAAU,CAAC;QAAEC;MAAQ,CAAC,CAAC,CAAC;IAAA;EAClE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACQE,2BAA2B,CAAC;IAAEtH,MAAM;IAAE5C;EAAQ,CAAC,EAAE;IAAA;IAAA;MACrD,MAAMkK,2BAA2B,GAAG,OAAI,CAAChK,aAAa,CACpD3B,OAAO,CAAC4L,2BAA2B,EACnC/L,QAAQ,CAAC+L,2BAA2B,CACrC;MACD,aAAa,OAAI,CAAC1L,OAAO,CAACC,YAAY,CAAC,CAACwL,2BAA2B,CAAC;QAAEtH,MAAM;QAAE5C;MAAQ,CAAC,CAAC,CAAC;IAAA;EAC3F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACQoK,0BAA0B,CAAC;IAAExH,MAAM,GAAG,IAAI;IAAE5C;EAAQ,CAAC,EAAE;IAAA;IAAA;MAC3D,MAAMoK,0BAA0B,GAAG,OAAI,CAAClK,aAAa,CACnD3B,OAAO,CAAC8L,0BAA0B,EAClCjM,QAAQ,CAACiM,0BAA0B,CACpC;MACD,aAAa,OAAI,CAAC5L,OAAO,CAACC,YAAY,CAAC,CAAC0L,0BAA0B,CAAC;QAAExH,MAAM;QAAE5C;MAAQ,CAAC,CAAC,CAAC;IAAA;EAC1F;;EAEA;AACF;AACA;EACE,CAAOvB,OAAO,CAACC,YAAY,EAAE4L,eAAe,EAAE;IAAA;IAAA;MAC5C,IAAI;QACF,aAAa,OAAI,CAACpL,cAAc,CAACqL,IAAI,CAACD,eAAe,CAAC;MACxD,CAAC,CAAC,OAAOpI,CAAC,EAAE;QACV,IAAIA,CAAC,CAAC2D,IAAI,KAAK,8BAA8B,EAAE;UAC7C,MAAM,OAAI,CAACxE,UAAU,EAAE;QACzB;QAEA,MAAMa,CAAC;MACT;IAAC;EACH;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}