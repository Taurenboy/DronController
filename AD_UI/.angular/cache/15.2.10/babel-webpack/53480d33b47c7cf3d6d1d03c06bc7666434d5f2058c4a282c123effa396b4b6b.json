{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  MemberMetadata,\n  MemberAssignment\n} = require('../../assignerProtocol');\n\n/**\n * RoundRobinAssigner\n * @type {import('types').PartitionAssigner}\n */\nmodule.exports = ({\n  cluster\n}) => ({\n  name: 'RoundRobinAssigner',\n  version: 0,\n  /**\n   * Assign the topics to the provided members.\n   *\n   * The members array contains information about each member, `memberMetadata` is the result of the\n   * `protocol` operation.\n   *\n   * @param {object} group\n   * @param {import('types').GroupMember[]} group.members array of members, e.g:\n                              [{ memberId: 'test-5f93f5a3', memberMetadata: Buffer }]\n   * @param {string[]} group.topics\n   * @returns {Promise<import('types').GroupMemberAssignment[]>} object partitions per topic per member, e.g:\n   *                   [\n   *                     {\n   *                       memberId: 'test-5f93f5a3',\n   *                       memberAssignment: {\n   *                         'topic-A': [0, 2, 4, 6],\n   *                         'topic-B': [1],\n   *                       },\n   *                     },\n   *                     {\n   *                       memberId: 'test-3d3d5341',\n   *                       memberAssignment: {\n   *                         'topic-A': [1, 3, 5],\n   *                         'topic-B': [0, 2],\n   *                       },\n   *                     }\n   *                   ]\n   */\n  assign({\n    members,\n    topics\n  }) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const membersCount = members.length;\n      const sortedMembers = members.map(({\n        memberId\n      }) => memberId).sort();\n      const assignment = {};\n      const topicsPartitions = topics.flatMap(topic => {\n        const partitionMetadata = cluster.findTopicPartitionMetadata(topic);\n        return partitionMetadata.map(m => ({\n          topic: topic,\n          partitionId: m.partitionId\n        }));\n      });\n      topicsPartitions.forEach((topicPartition, i) => {\n        const assignee = sortedMembers[i % membersCount];\n        if (!assignment[assignee]) {\n          assignment[assignee] = Object.create(null);\n        }\n        if (!assignment[assignee][topicPartition.topic]) {\n          assignment[assignee][topicPartition.topic] = [];\n        }\n        assignment[assignee][topicPartition.topic].push(topicPartition.partitionId);\n      });\n      return Object.keys(assignment).map(memberId => ({\n        memberId,\n        memberAssignment: MemberAssignment.encode({\n          version: _this.version,\n          assignment: assignment[memberId]\n        })\n      }));\n    })();\n  },\n  protocol({\n    topics\n  }) {\n    return {\n      name: this.name,\n      metadata: MemberMetadata.encode({\n        version: this.version,\n        topics\n      })\n    };\n  }\n});","map":{"version":3,"names":["MemberMetadata","MemberAssignment","require","module","exports","cluster","name","version","assign","members","topics","membersCount","length","sortedMembers","map","memberId","sort","assignment","topicsPartitions","flatMap","topic","partitionMetadata","findTopicPartitionMetadata","m","partitionId","forEach","topicPartition","i","assignee","Object","create","push","keys","memberAssignment","encode","protocol","metadata"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/assigners/roundRobinAssigner/index.js"],"sourcesContent":["const { MemberMetadata, MemberAssignment } = require('../../assignerProtocol')\n\n/**\n * RoundRobinAssigner\n * @type {import('types').PartitionAssigner}\n */\nmodule.exports = ({ cluster }) => ({\n  name: 'RoundRobinAssigner',\n  version: 0,\n\n  /**\n   * Assign the topics to the provided members.\n   *\n   * The members array contains information about each member, `memberMetadata` is the result of the\n   * `protocol` operation.\n   *\n   * @param {object} group\n   * @param {import('types').GroupMember[]} group.members array of members, e.g:\n                              [{ memberId: 'test-5f93f5a3', memberMetadata: Buffer }]\n   * @param {string[]} group.topics\n   * @returns {Promise<import('types').GroupMemberAssignment[]>} object partitions per topic per member, e.g:\n   *                   [\n   *                     {\n   *                       memberId: 'test-5f93f5a3',\n   *                       memberAssignment: {\n   *                         'topic-A': [0, 2, 4, 6],\n   *                         'topic-B': [1],\n   *                       },\n   *                     },\n   *                     {\n   *                       memberId: 'test-3d3d5341',\n   *                       memberAssignment: {\n   *                         'topic-A': [1, 3, 5],\n   *                         'topic-B': [0, 2],\n   *                       },\n   *                     }\n   *                   ]\n   */\n  async assign({ members, topics }) {\n    const membersCount = members.length\n    const sortedMembers = members.map(({ memberId }) => memberId).sort()\n    const assignment = {}\n\n    const topicsPartitions = topics.flatMap(topic => {\n      const partitionMetadata = cluster.findTopicPartitionMetadata(topic)\n      return partitionMetadata.map(m => ({ topic: topic, partitionId: m.partitionId }))\n    })\n\n    topicsPartitions.forEach((topicPartition, i) => {\n      const assignee = sortedMembers[i % membersCount]\n\n      if (!assignment[assignee]) {\n        assignment[assignee] = Object.create(null)\n      }\n\n      if (!assignment[assignee][topicPartition.topic]) {\n        assignment[assignee][topicPartition.topic] = []\n      }\n\n      assignment[assignee][topicPartition.topic].push(topicPartition.partitionId)\n    })\n\n    return Object.keys(assignment).map(memberId => ({\n      memberId,\n      memberAssignment: MemberAssignment.encode({\n        version: this.version,\n        assignment: assignment[memberId],\n      }),\n    }))\n  },\n\n  protocol({ topics }) {\n    return {\n      name: this.name,\n      metadata: MemberMetadata.encode({\n        version: this.version,\n        topics,\n      }),\n    }\n  },\n})\n"],"mappings":";AAAA,MAAM;EAAEA,cAAc;EAAEC;AAAiB,CAAC,GAAGC,OAAO,CAAC,wBAAwB,CAAC;;AAE9E;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC;AAAQ,CAAC,MAAM;EACjCC,IAAI,EAAE,oBAAoB;EAC1BC,OAAO,EAAE,CAAC;EAEV;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQC,MAAM,CAAC;IAAEC,OAAO;IAAEC;EAAO,CAAC,EAAE;IAAA;IAAA;MAChC,MAAMC,YAAY,GAAGF,OAAO,CAACG,MAAM;MACnC,MAAMC,aAAa,GAAGJ,OAAO,CAACK,GAAG,CAAC,CAAC;QAAEC;MAAS,CAAC,KAAKA,QAAQ,CAAC,CAACC,IAAI,EAAE;MACpE,MAAMC,UAAU,GAAG,CAAC,CAAC;MAErB,MAAMC,gBAAgB,GAAGR,MAAM,CAACS,OAAO,CAACC,KAAK,IAAI;QAC/C,MAAMC,iBAAiB,GAAGhB,OAAO,CAACiB,0BAA0B,CAACF,KAAK,CAAC;QACnE,OAAOC,iBAAiB,CAACP,GAAG,CAACS,CAAC,KAAK;UAAEH,KAAK,EAAEA,KAAK;UAAEI,WAAW,EAAED,CAAC,CAACC;QAAY,CAAC,CAAC,CAAC;MACnF,CAAC,CAAC;MAEFN,gBAAgB,CAACO,OAAO,CAAC,CAACC,cAAc,EAAEC,CAAC,KAAK;QAC9C,MAAMC,QAAQ,GAAGf,aAAa,CAACc,CAAC,GAAGhB,YAAY,CAAC;QAEhD,IAAI,CAACM,UAAU,CAACW,QAAQ,CAAC,EAAE;UACzBX,UAAU,CAACW,QAAQ,CAAC,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;QAC5C;QAEA,IAAI,CAACb,UAAU,CAACW,QAAQ,CAAC,CAACF,cAAc,CAACN,KAAK,CAAC,EAAE;UAC/CH,UAAU,CAACW,QAAQ,CAAC,CAACF,cAAc,CAACN,KAAK,CAAC,GAAG,EAAE;QACjD;QAEAH,UAAU,CAACW,QAAQ,CAAC,CAACF,cAAc,CAACN,KAAK,CAAC,CAACW,IAAI,CAACL,cAAc,CAACF,WAAW,CAAC;MAC7E,CAAC,CAAC;MAEF,OAAOK,MAAM,CAACG,IAAI,CAACf,UAAU,CAAC,CAACH,GAAG,CAACC,QAAQ,KAAK;QAC9CA,QAAQ;QACRkB,gBAAgB,EAAEhC,gBAAgB,CAACiC,MAAM,CAAC;UACxC3B,OAAO,EAAE,KAAI,CAACA,OAAO;UACrBU,UAAU,EAAEA,UAAU,CAACF,QAAQ;QACjC,CAAC;MACH,CAAC,CAAC,CAAC;IAAA;EACL,CAAC;EAEDoB,QAAQ,CAAC;IAAEzB;EAAO,CAAC,EAAE;IACnB,OAAO;MACLJ,IAAI,EAAE,IAAI,CAACA,IAAI;MACf8B,QAAQ,EAAEpC,cAAc,CAACkC,MAAM,CAAC;QAC9B3B,OAAO,EAAE,IAAI,CAACA,OAAO;QACrBG;MACF,CAAC;IACH,CAAC;EACH;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}