{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst createRetry = require('../retry');\nconst waitFor = require('../utils/waitFor');\nconst groupBy = require('../utils/groupBy');\nconst createConsumer = require('../consumer');\nconst InstrumentationEventEmitter = require('../instrumentation/emitter');\nconst {\n  events,\n  wrap: wrapEvent,\n  unwrap: unwrapEvent\n} = require('./instrumentationEvents');\nconst {\n  LEVELS\n} = require('../loggers');\nconst {\n  KafkaJSNonRetriableError,\n  KafkaJSDeleteGroupsError,\n  KafkaJSBrokerNotFound,\n  KafkaJSDeleteTopicRecordsError,\n  KafkaJSAggregateError\n} = require('../errors');\nconst {\n  staleMetadata\n} = require('../protocol/error');\nconst CONFIG_RESOURCE_TYPES = require('../protocol/configResourceTypes');\nconst ACL_RESOURCE_TYPES = require('../protocol/aclResourceTypes');\nconst ACL_OPERATION_TYPES = require('../protocol/aclOperationTypes');\nconst ACL_PERMISSION_TYPES = require('../protocol/aclPermissionTypes');\nconst RESOURCE_PATTERN_TYPES = require('../protocol/resourcePatternTypes');\nconst {\n  EARLIEST_OFFSET,\n  LATEST_OFFSET\n} = require('../constants');\nconst {\n  CONNECT,\n  DISCONNECT\n} = events;\nconst NO_CONTROLLER_ID = -1;\nconst {\n  values,\n  keys,\n  entries\n} = Object;\nconst eventNames = values(events);\nconst eventKeys = keys(events).map(key => `admin.events.${key}`).join(', ');\nconst retryOnLeaderNotAvailable = (fn, opts = {}) => {\n  const callback = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* () {\n      try {\n        return yield fn();\n      } catch (e) {\n        if (e.type !== 'LEADER_NOT_AVAILABLE') {\n          throw e;\n        }\n        return false;\n      }\n    });\n    return function callback() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return waitFor(callback, opts);\n};\nconst isConsumerGroupRunning = description => ['Empty', 'Dead'].includes(description.state);\nconst findTopicPartitions = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (cluster, topic) {\n    yield cluster.addTargetTopic(topic);\n    yield cluster.refreshMetadataIfNecessary();\n    return cluster.findTopicPartitionMetadata(topic).map(({\n      partitionId\n    }) => partitionId).sort();\n  });\n  return function findTopicPartitions(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nconst indexByPartition = array => array.reduce((obj, {\n  partition,\n  ...props\n}) => Object.assign(obj, {\n  [partition]: {\n    ...props\n  }\n}), {});\n\n/**\n *\n * @param {Object} params\n * @param {import(\"../../types\").Logger} params.logger\n * @param {InstrumentationEventEmitter} [params.instrumentationEmitter]\n * @param {import('../../types').RetryOptions} params.retry\n * @param {import(\"../../types\").Cluster} params.cluster\n *\n * @returns {import(\"../../types\").Admin}\n */\nmodule.exports = ({\n  logger: rootLogger,\n  instrumentationEmitter: rootInstrumentationEmitter,\n  retry,\n  cluster\n}) => {\n  const logger = rootLogger.namespace('Admin');\n  const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter();\n\n  /**\n   * @returns {Promise}\n   */\n  const connect = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* () {\n      yield cluster.connect();\n      instrumentationEmitter.emit(CONNECT);\n    });\n    return function connect() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @return {Promise}\n   */\n  const disconnect = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* () {\n      yield cluster.disconnect();\n      instrumentationEmitter.emit(DISCONNECT);\n    });\n    return function disconnect() {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @return {Promise}\n   */\n  const listTopics = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator(function* () {\n      const {\n        topicMetadata\n      } = yield cluster.metadata();\n      const topics = topicMetadata.map(t => t.topic);\n      return topics;\n    });\n    return function listTopics() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {Object} request\n   * @param {array} request.topics\n   * @param {boolean} [request.validateOnly=false]\n   * @param {number} [request.timeout=5000]\n   * @param {boolean} [request.waitForLeaders=true]\n   * @return {Promise}\n   */\n  const createTopics = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator(function* ({\n      topics,\n      validateOnly,\n      timeout,\n      waitForLeaders = true\n    }) {\n      if (!topics || !Array.isArray(topics)) {\n        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n      }\n      if (topics.filter(({\n        topic\n      }) => typeof topic !== 'string').length > 0) {\n        throw new KafkaJSNonRetriableError('Invalid topics array, the topic names have to be a valid string');\n      }\n      const topicNames = new Set(topics.map(({\n        topic\n      }) => topic));\n      if (topicNames.size < topics.length) {\n        throw new KafkaJSNonRetriableError('Invalid topics array, it cannot have multiple entries for the same topic');\n      }\n      for (const {\n        topic,\n        configEntries\n      } of topics) {\n        if (configEntries == null) {\n          continue;\n        }\n        if (!Array.isArray(configEntries)) {\n          throw new KafkaJSNonRetriableError(`Invalid configEntries for topic \"${topic}\", must be an array`);\n        }\n        configEntries.forEach((entry, index) => {\n          if (typeof entry !== 'object' || entry == null) {\n            throw new KafkaJSNonRetriableError(`Invalid configEntries for topic \"${topic}\". Entry ${index} must be an object`);\n          }\n          for (const requiredProperty of ['name', 'value']) {\n            if (!Object.prototype.hasOwnProperty.call(entry, requiredProperty) || typeof entry[requiredProperty] !== 'string') {\n              throw new KafkaJSNonRetriableError(`Invalid configEntries for topic \"${topic}\". Entry ${index} must have a valid \"${requiredProperty}\" property`);\n            }\n          }\n        });\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            yield broker.createTopics({\n              topics,\n              validateOnly,\n              timeout\n            });\n            if (waitForLeaders) {\n              const topicNamesArray = Array.from(topicNames.values());\n              yield retryOnLeaderNotAvailable( /*#__PURE__*/_asyncToGenerator(function* () {\n                return yield broker.metadata(topicNamesArray);\n              }), {\n                delay: 100,\n                maxWait: timeout,\n                timeoutMessage: 'Timed out while waiting for topic leaders'\n              });\n            }\n            return true;\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not create topics', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            if (e instanceof KafkaJSAggregateError) {\n              if (e.errors.every(error => error.type === 'TOPIC_ALREADY_EXISTS')) {\n                return false;\n              }\n            }\n            bail(e);\n          }\n        });\n        return function (_x4, _x5, _x6) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n    });\n    return function createTopics(_x3) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  /**\n   * @param {array} topicPartitions\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @return {Promise<void>}\n   */\n  const createPartitions = /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator(function* ({\n      topicPartitions,\n      validateOnly,\n      timeout\n    }) {\n      if (!topicPartitions || !Array.isArray(topicPartitions)) {\n        throw new KafkaJSNonRetriableError(`Invalid topic partitions array ${topicPartitions}`);\n      }\n      if (topicPartitions.length === 0) {\n        throw new KafkaJSNonRetriableError(`Empty topic partitions array`);\n      }\n      if (topicPartitions.filter(({\n        topic\n      }) => typeof topic !== 'string').length > 0) {\n        throw new KafkaJSNonRetriableError('Invalid topic partitions array, the topic names have to be a valid string');\n      }\n      const topicNames = new Set(topicPartitions.map(({\n        topic\n      }) => topic));\n      if (topicNames.size < topicPartitions.length) {\n        throw new KafkaJSNonRetriableError('Invalid topic partitions array, it cannot have multiple entries for the same topic');\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            yield broker.createPartitions({\n              topicPartitions,\n              validateOnly,\n              timeout\n            });\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not create topics', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x8, _x9, _x10) {\n          return _ref10.apply(this, arguments);\n        };\n      }());\n    });\n    return function createPartitions(_x7) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {string[]} topics\n   * @param {number} [timeout=5000]\n   * @return {Promise}\n   */\n  const deleteTopics = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator(function* ({\n      topics,\n      timeout\n    }) {\n      if (!topics || !Array.isArray(topics)) {\n        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n      }\n      if (topics.filter(topic => typeof topic !== 'string').length > 0) {\n        throw new KafkaJSNonRetriableError('Invalid topics array, the names must be a valid string');\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref12 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            yield broker.deleteTopics({\n              topics,\n              timeout\n            });\n\n            // Remove deleted topics\n            for (const topic of topics) {\n              cluster.targetTopics.delete(topic);\n            }\n            yield cluster.refreshMetadata();\n          } catch (e) {\n            if (['NOT_CONTROLLER', 'UNKNOWN_TOPIC_OR_PARTITION'].includes(e.type)) {\n              logger.warn('Could not delete topics', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            if (e.type === 'REQUEST_TIMED_OUT') {\n              logger.error('Could not delete topics, check if \"delete.topic.enable\" is set to \"true\" (the default value is \"false\") or increase the timeout', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n            }\n            bail(e);\n          }\n        });\n        return function (_x12, _x13, _x14) {\n          return _ref12.apply(this, arguments);\n        };\n      }());\n    });\n    return function deleteTopics(_x11) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {string} topic\n   */\n\n  const fetchTopicOffsets = /*#__PURE__*/function () {\n    var _ref13 = _asyncToGenerator(function* (topic) {\n      if (!topic || typeof topic !== 'string') {\n        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref14 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.addTargetTopic(topic);\n            yield cluster.refreshMetadataIfNecessary();\n            const metadata = cluster.findTopicPartitionMetadata(topic);\n            const high = yield cluster.fetchTopicsOffset([{\n              topic,\n              fromBeginning: false,\n              partitions: metadata.map(p => ({\n                partition: p.partitionId\n              }))\n            }]);\n            const low = yield cluster.fetchTopicsOffset([{\n              topic,\n              fromBeginning: true,\n              partitions: metadata.map(p => ({\n                partition: p.partitionId\n              }))\n            }]);\n            const {\n              partitions: highPartitions\n            } = high.pop();\n            const {\n              partitions: lowPartitions\n            } = low.pop();\n            return highPartitions.map(({\n              partition,\n              offset\n            }) => ({\n              partition,\n              offset,\n              high: offset,\n              low: lowPartitions.find(({\n                partition: lowPartition\n              }) => lowPartition === partition).offset\n            }));\n          } catch (e) {\n            if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n              yield cluster.refreshMetadata();\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x16, _x17, _x18) {\n          return _ref14.apply(this, arguments);\n        };\n      }());\n    });\n    return function fetchTopicOffsets(_x15) {\n      return _ref13.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {string} topic\n   * @param {number} [timestamp]\n   */\n\n  const fetchTopicOffsetsByTimestamp = /*#__PURE__*/function () {\n    var _ref15 = _asyncToGenerator(function* (topic, timestamp) {\n      if (!topic || typeof topic !== 'string') {\n        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref16 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.addTargetTopic(topic);\n            yield cluster.refreshMetadataIfNecessary();\n            const metadata = cluster.findTopicPartitionMetadata(topic);\n            const partitions = metadata.map(p => ({\n              partition: p.partitionId\n            }));\n            const high = yield cluster.fetchTopicsOffset([{\n              topic,\n              fromBeginning: false,\n              partitions\n            }]);\n            const {\n              partitions: highPartitions\n            } = high.pop();\n            const offsets = yield cluster.fetchTopicsOffset([{\n              topic,\n              fromTimestamp: timestamp,\n              partitions\n            }]);\n            const {\n              partitions: lowPartitions\n            } = offsets.pop();\n            return lowPartitions.map(({\n              partition,\n              offset\n            }) => ({\n              partition,\n              offset: parseInt(offset, 10) >= 0 ? offset : highPartitions.find(({\n                partition: highPartition\n              }) => highPartition === partition).offset\n            }));\n          } catch (e) {\n            if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n              yield cluster.refreshMetadata();\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x21, _x22, _x23) {\n          return _ref16.apply(this, arguments);\n        };\n      }());\n    });\n    return function fetchTopicOffsetsByTimestamp(_x19, _x20) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Fetch offsets for a topic or multiple topics\n   *\n   * Note: set either topic or topics but not both.\n   *\n   * @param {string} groupId\n   * @param {string[]} topics - list of topics to fetch offsets for, defaults to `[]` which fetches all topics for `groupId`.\n   * @param {boolean} [resolveOffsets=false]\n   * @return {Promise}\n   */\n  const fetchOffsets = /*#__PURE__*/function () {\n    var _ref17 = _asyncToGenerator(function* ({\n      groupId,\n      topics,\n      resolveOffsets = false\n    }) {\n      if (!groupId) {\n        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n      }\n      if (!topics) {\n        topics = [];\n      }\n      if (!Array.isArray(topics)) {\n        throw new KafkaJSNonRetriableError('Expected topics array to be set');\n      }\n      const coordinator = yield cluster.findGroupCoordinator({\n        groupId\n      });\n      const topicsToFetch = yield Promise.all(topics.map( /*#__PURE__*/function () {\n        var _ref18 = _asyncToGenerator(function* (topic) {\n          const partitions = yield findTopicPartitions(cluster, topic);\n          const partitionsToFetch = partitions.map(partition => ({\n            partition\n          }));\n          return {\n            topic,\n            partitions: partitionsToFetch\n          };\n        });\n        return function (_x25) {\n          return _ref18.apply(this, arguments);\n        };\n      }()));\n      let {\n        responses: consumerOffsets\n      } = yield coordinator.offsetFetch({\n        groupId,\n        topics: topicsToFetch\n      });\n      if (resolveOffsets) {\n        consumerOffsets = yield Promise.all(consumerOffsets.map( /*#__PURE__*/function () {\n          var _ref19 = _asyncToGenerator(function* ({\n            topic,\n            partitions\n          }) {\n            const indexedOffsets = indexByPartition(yield fetchTopicOffsets(topic));\n            const recalculatedPartitions = partitions.map(({\n              offset,\n              partition,\n              ...props\n            }) => {\n              let resolvedOffset = offset;\n              if (Number(offset) === EARLIEST_OFFSET) {\n                resolvedOffset = indexedOffsets[partition].low;\n              }\n              if (Number(offset) === LATEST_OFFSET) {\n                resolvedOffset = indexedOffsets[partition].high;\n              }\n              return {\n                partition,\n                offset: resolvedOffset,\n                ...props\n              };\n            });\n            yield setOffsets({\n              groupId,\n              topic,\n              partitions: recalculatedPartitions\n            });\n            return {\n              topic,\n              partitions: recalculatedPartitions\n            };\n          });\n          return function (_x26) {\n            return _ref19.apply(this, arguments);\n          };\n        }()));\n      }\n      return consumerOffsets.map(({\n        topic,\n        partitions\n      }) => {\n        const completePartitions = partitions.map(({\n          partition,\n          offset,\n          metadata\n        }) => ({\n          partition,\n          offset,\n          metadata: metadata || null\n        }));\n        return {\n          topic,\n          partitions: completePartitions\n        };\n      });\n    });\n    return function fetchOffsets(_x24) {\n      return _ref17.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [earliest=false]\n   * @return {Promise}\n   */\n  const resetOffsets = /*#__PURE__*/function () {\n    var _ref20 = _asyncToGenerator(function* ({\n      groupId,\n      topic,\n      earliest = false\n    }) {\n      if (!groupId) {\n        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n      }\n      if (!topic) {\n        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n      }\n      const partitions = yield findTopicPartitions(cluster, topic);\n      const partitionsToSeek = partitions.map(partition => ({\n        partition,\n        offset: cluster.defaultOffset({\n          fromBeginning: earliest\n        })\n      }));\n      return setOffsets({\n        groupId,\n        topic,\n        partitions: partitionsToSeek\n      });\n    });\n    return function resetOffsets(_x27) {\n      return _ref20.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const setOffsets = /*#__PURE__*/function () {\n    var _ref21 = _asyncToGenerator(function* ({\n      groupId,\n      topic,\n      partitions\n    }) {\n      if (!groupId) {\n        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n      }\n      if (!topic) {\n        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n      }\n      if (!partitions || partitions.length === 0) {\n        throw new KafkaJSNonRetriableError(`Invalid partitions`);\n      }\n      const consumer = createConsumer({\n        logger: rootLogger.namespace('Admin', LEVELS.NOTHING),\n        cluster,\n        groupId\n      });\n      yield consumer.subscribe({\n        topic,\n        fromBeginning: true\n      });\n      const description = yield consumer.describeGroup();\n      if (!isConsumerGroupRunning(description)) {\n        throw new KafkaJSNonRetriableError(`The consumer group must have no running instances, current state: ${description.state}`);\n      }\n      return new Promise((resolve, reject) => {\n        consumer.on(consumer.events.FETCH, /*#__PURE__*/_asyncToGenerator(function* () {\n          return consumer.stop().then(resolve).catch(reject);\n        }));\n        consumer.run({\n          eachBatchAutoResolve: false,\n          eachBatch: function () {\n            var _ref23 = _asyncToGenerator(function* () {\n              return true;\n            });\n            return function eachBatch() {\n              return _ref23.apply(this, arguments);\n            };\n          }()\n        }).catch(reject);\n\n        // This consumer doesn't need to consume any data\n        consumer.pause([{\n          topic\n        }]);\n        for (const seekData of partitions) {\n          consumer.seek({\n            topic,\n            ...seekData\n          });\n        }\n      });\n    });\n    return function setOffsets(_x28) {\n      return _ref21.apply(this, arguments);\n    };\n  }();\n  const isBrokerConfig = type => [CONFIG_RESOURCE_TYPES.BROKER, CONFIG_RESOURCE_TYPES.BROKER_LOGGER].includes(type);\n\n  /**\n   * Broker configs can only be returned by the target broker\n   *\n   * @see\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3783\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2027\n   *\n   * @param {Broker} defaultBroker. Broker used in case the configuration is not a broker config\n   */\n  const groupResourcesByBroker = ({\n    resources,\n    defaultBroker\n  }) => groupBy(resources, /*#__PURE__*/function () {\n    var _ref24 = _asyncToGenerator(function* ({\n      type,\n      name: nodeId\n    }) {\n      return isBrokerConfig(type) ? yield cluster.findBroker({\n        nodeId: String(nodeId)\n      }) : defaultBroker;\n    });\n    return function (_x29) {\n      return _ref24.apply(this, arguments);\n    };\n  }());\n\n  /**\n   * @param {Array<ResourceConfigQuery>} resources\n   * @param {boolean} [includeSynonyms=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfigQuery\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<String>} [configNames=[]]\n   */\n  const describeConfigs = /*#__PURE__*/function () {\n    var _ref25 = _asyncToGenerator(function* ({\n      resources,\n      includeSynonyms\n    }) {\n      if (!resources || !Array.isArray(resources)) {\n        throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);\n      }\n      if (resources.length === 0) {\n        throw new KafkaJSNonRetriableError('Resources array cannot be empty');\n      }\n      const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);\n      const invalidType = resources.find(r => !validResourceTypes.includes(r.type));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);\n      }\n      const invalidName = resources.find(r => !r.name || typeof r.name !== 'string');\n      if (invalidName) {\n        throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);\n      }\n      const invalidConfigs = resources.find(r => !Array.isArray(r.configNames) && r.configNames != null);\n      if (invalidConfigs) {\n        const {\n          configNames\n        } = invalidConfigs;\n        throw new KafkaJSNonRetriableError(`Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref26 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const controller = yield cluster.findControllerBroker();\n            const resourcerByBroker = yield groupResourcesByBroker({\n              resources,\n              defaultBroker: controller\n            });\n            const describeConfigsAction = /*#__PURE__*/function () {\n              var _ref27 = _asyncToGenerator(function* (broker) {\n                const targetBroker = broker || controller;\n                return targetBroker.describeConfigs({\n                  resources: resourcerByBroker.get(targetBroker),\n                  includeSynonyms\n                });\n              });\n              return function describeConfigsAction(_x34) {\n                return _ref27.apply(this, arguments);\n              };\n            }();\n            const brokers = Array.from(resourcerByBroker.keys());\n            const responses = yield Promise.all(brokers.map(describeConfigsAction));\n            const responseResources = responses.reduce((result, {\n              resources\n            }) => [...result, ...resources], []);\n            return {\n              resources: responseResources\n            };\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not describe configs', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x31, _x32, _x33) {\n          return _ref26.apply(this, arguments);\n        };\n      }());\n    });\n    return function describeConfigs(_x30) {\n      return _ref25.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {Array<ResourceConfig>} resources\n   * @param {boolean} [validateOnly=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfig\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<ResourceConfigEntry>} configEntries\n   *\n   * @typedef {Object} ResourceConfigEntry\n   * @property {string} name\n   * @property {string} value\n   */\n  const alterConfigs = /*#__PURE__*/function () {\n    var _ref28 = _asyncToGenerator(function* ({\n      resources,\n      validateOnly\n    }) {\n      if (!resources || !Array.isArray(resources)) {\n        throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);\n      }\n      if (resources.length === 0) {\n        throw new KafkaJSNonRetriableError('Resources array cannot be empty');\n      }\n      const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);\n      const invalidType = resources.find(r => !validResourceTypes.includes(r.type));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);\n      }\n      const invalidName = resources.find(r => !r.name || typeof r.name !== 'string');\n      if (invalidName) {\n        throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);\n      }\n      const invalidConfigs = resources.find(r => !Array.isArray(r.configEntries));\n      if (invalidConfigs) {\n        const {\n          configEntries\n        } = invalidConfigs;\n        throw new KafkaJSNonRetriableError(`Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`);\n      }\n      const invalidConfigValue = resources.find(r => r.configEntries.some(e => typeof e.name !== 'string' || typeof e.value !== 'string'));\n      if (invalidConfigValue) {\n        throw new KafkaJSNonRetriableError(`Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref29 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const controller = yield cluster.findControllerBroker();\n            const resourcerByBroker = yield groupResourcesByBroker({\n              resources,\n              defaultBroker: controller\n            });\n            const alterConfigsAction = /*#__PURE__*/function () {\n              var _ref30 = _asyncToGenerator(function* (broker) {\n                const targetBroker = broker || controller;\n                return targetBroker.alterConfigs({\n                  resources: resourcerByBroker.get(targetBroker),\n                  validateOnly: !!validateOnly\n                });\n              });\n              return function alterConfigsAction(_x39) {\n                return _ref30.apply(this, arguments);\n              };\n            }();\n            const brokers = Array.from(resourcerByBroker.keys());\n            const responses = yield Promise.all(brokers.map(alterConfigsAction));\n            const responseResources = responses.reduce((result, {\n              resources\n            }) => [...result, ...resources], []);\n            return {\n              resources: responseResources\n            };\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not alter configs', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x36, _x37, _x38) {\n          return _ref29.apply(this, arguments);\n        };\n      }());\n    });\n    return function alterConfigs(_x35) {\n      return _ref28.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n  const fetchTopicMetadata = /*#__PURE__*/function () {\n    var _ref31 = _asyncToGenerator(function* ({\n      topics = []\n    } = {}) {\n      if (topics) {\n        topics.forEach(topic => {\n          if (!topic || typeof topic !== 'string') {\n            throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n          }\n        });\n      }\n      const metadata = yield cluster.metadata({\n        topics\n      });\n      return {\n        topics: metadata.topicMetadata.map(topicMetadata => ({\n          name: topicMetadata.topic,\n          partitions: topicMetadata.partitionMetadata\n        }))\n      };\n    });\n    return function fetchTopicMetadata() {\n      return _ref31.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Describe cluster\n   *\n   * @return {Promise<ClusterMetadata>}\n   *\n   * @typedef {Object} ClusterMetadata\n   * @property {Array<Broker>} brokers\n   * @property {Number} controller Current controller id. Returns null if unknown.\n   * @property {String} clusterId\n   *\n   * @typedef {Object} Broker\n   * @property {Number} nodeId\n   * @property {String} host\n   * @property {Number} port\n   */\n  const describeCluster = /*#__PURE__*/function () {\n    var _ref32 = _asyncToGenerator(function* () {\n      const {\n        brokers: nodes,\n        clusterId,\n        controllerId\n      } = yield cluster.metadata({\n        topics: []\n      });\n      const brokers = nodes.map(({\n        nodeId,\n        host,\n        port\n      }) => ({\n        nodeId,\n        host,\n        port\n      }));\n      const controller = controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId;\n      return {\n        brokers,\n        controller,\n        clusterId\n      };\n    });\n    return function describeCluster() {\n      return _ref32.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * List groups in a broker\n   *\n   * @return {Promise<ListGroups>}\n   *\n   * @typedef {Object} ListGroups\n   * @property {Array<ListGroup>} groups\n   *\n   * @typedef {Object} ListGroup\n   * @property {string} groupId\n   * @property {string} protocolType\n   */\n  const listGroups = /*#__PURE__*/function () {\n    var _ref33 = _asyncToGenerator(function* () {\n      yield cluster.refreshMetadata();\n      let groups = [];\n      for (var nodeId in cluster.brokerPool.brokers) {\n        const broker = yield cluster.findBroker({\n          nodeId\n        });\n        const response = yield broker.listGroups();\n        groups = groups.concat(response.groups);\n      }\n      return {\n        groups\n      };\n    });\n    return function listGroups() {\n      return _ref33.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Describe groups by group ids\n   * @param {Array<string>} groupIds\n   *\n   * @typedef {Object} GroupDescriptions\n   * @property {Array<GroupDescription>} groups\n   *\n   * @return {Promise<GroupDescriptions>}\n   */\n  const describeGroups = /*#__PURE__*/function () {\n    var _ref34 = _asyncToGenerator(function* (groupIds) {\n      const coordinatorsForGroup = yield Promise.all(groupIds.map( /*#__PURE__*/function () {\n        var _ref35 = _asyncToGenerator(function* (groupId) {\n          const coordinator = yield cluster.findGroupCoordinator({\n            groupId\n          });\n          return {\n            coordinator,\n            groupId\n          };\n        });\n        return function (_x41) {\n          return _ref35.apply(this, arguments);\n        };\n      }()));\n      const groupsByCoordinator = Object.values(coordinatorsForGroup.reduce((coordinators, {\n        coordinator,\n        groupId\n      }) => {\n        const group = coordinators[coordinator.nodeId];\n        if (group) {\n          coordinators[coordinator.nodeId] = {\n            ...group,\n            groupIds: [...group.groupIds, groupId]\n          };\n        } else {\n          coordinators[coordinator.nodeId] = {\n            coordinator,\n            groupIds: [groupId]\n          };\n        }\n        return coordinators;\n      }, {}));\n      const responses = yield Promise.all(groupsByCoordinator.map( /*#__PURE__*/function () {\n        var _ref36 = _asyncToGenerator(function* ({\n          coordinator,\n          groupIds\n        }) {\n          const retrier = createRetry(retry);\n          const {\n            groups\n          } = yield retrier(() => coordinator.describeGroups({\n            groupIds\n          }));\n          return groups;\n        });\n        return function (_x42) {\n          return _ref36.apply(this, arguments);\n        };\n      }()));\n      const groups = [].concat.apply([], responses);\n      return {\n        groups\n      };\n    });\n    return function describeGroups(_x40) {\n      return _ref34.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Delete groups in a broker\n   *\n   * @param {string[]} [groupIds]\n   * @return {Promise<DeleteGroups>}\n   *\n   * @typedef {Array} DeleteGroups\n   * @property {string} groupId\n   * @property {number} errorCode\n   */\n  const deleteGroups = /*#__PURE__*/function () {\n    var _ref37 = _asyncToGenerator(function* (groupIds) {\n      if (!groupIds || !Array.isArray(groupIds)) {\n        throw new KafkaJSNonRetriableError(`Invalid groupIds array ${groupIds}`);\n      }\n      const invalidGroupId = groupIds.some(g => typeof g !== 'string');\n      if (invalidGroupId) {\n        throw new KafkaJSNonRetriableError(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`);\n      }\n      const retrier = createRetry(retry);\n      let results = [];\n      let clonedGroupIds = groupIds.slice();\n      return retrier( /*#__PURE__*/function () {\n        var _ref38 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            if (clonedGroupIds.length === 0) return [];\n            yield cluster.refreshMetadata();\n            const brokersPerGroups = {};\n            const brokersPerNode = {};\n            for (const groupId of clonedGroupIds) {\n              const broker = yield cluster.findGroupCoordinator({\n                groupId\n              });\n              if (brokersPerGroups[broker.nodeId] === undefined) brokersPerGroups[broker.nodeId] = [];\n              brokersPerGroups[broker.nodeId].push(groupId);\n              brokersPerNode[broker.nodeId] = broker;\n            }\n            const res = yield Promise.all(Object.keys(brokersPerNode).map( /*#__PURE__*/function () {\n              var _ref39 = _asyncToGenerator(function* (nodeId) {\n                return yield brokersPerNode[nodeId].deleteGroups(brokersPerGroups[nodeId]);\n              });\n              return function (_x47) {\n                return _ref39.apply(this, arguments);\n              };\n            }()));\n            const errors = res.flatMap(({\n              results\n            }) => results.map(({\n              groupId,\n              errorCode,\n              error\n            }) => {\n              return {\n                groupId,\n                errorCode,\n                error\n              };\n            })).filter(({\n              errorCode\n            }) => errorCode !== 0);\n            clonedGroupIds = errors.map(({\n              groupId\n            }) => groupId);\n            if (errors.length > 0) throw new KafkaJSDeleteGroupsError('Error in DeleteGroups', errors);\n            results = res.flatMap(({\n              results\n            }) => results);\n            return results;\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER' || e.type === 'COORDINATOR_NOT_AVAILABLE') {\n              logger.warn('Could not delete groups', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x44, _x45, _x46) {\n          return _ref38.apply(this, arguments);\n        };\n      }());\n    });\n    return function deleteGroups(_x43) {\n      return _ref37.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Delete topic records up to the selected partition offsets\n   *\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const deleteTopicRecords = /*#__PURE__*/function () {\n    var _ref40 = _asyncToGenerator(function* ({\n      topic,\n      partitions\n    }) {\n      if (!topic || typeof topic !== 'string') {\n        throw new KafkaJSNonRetriableError(`Invalid topic \"${topic}\"`);\n      }\n      if (!partitions || partitions.length === 0) {\n        throw new KafkaJSNonRetriableError(`Invalid partitions`);\n      }\n      const partitionsByBroker = cluster.findLeaderForPartitions(topic, partitions.map(p => p.partition));\n      const partitionsFound = values(partitionsByBroker).flat();\n      const topicOffsets = yield fetchTopicOffsets(topic);\n      const leaderNotFoundErrors = [];\n      partitions.forEach(({\n        partition,\n        offset\n      }) => {\n        // throw if no leader found for partition\n        if (!partitionsFound.includes(partition)) {\n          leaderNotFoundErrors.push({\n            partition,\n            offset,\n            error: new KafkaJSBrokerNotFound('Could not find the leader for the partition', {\n              retriable: false\n            })\n          });\n          return;\n        }\n        const {\n          low\n        } = topicOffsets.find(p => p.partition === partition) || {\n          high: undefined,\n          low: undefined\n        };\n        // warn in case of offset below low watermark\n        if (parseInt(offset) < parseInt(low) && parseInt(offset) !== -1) {\n          logger.warn('The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition', {\n            topic,\n            partition,\n            offset\n          });\n        }\n      });\n      if (leaderNotFoundErrors.length > 0) {\n        throw new KafkaJSDeleteTopicRecordsError({\n          topic,\n          partitions: leaderNotFoundErrors\n        });\n      }\n      const seekEntriesByBroker = entries(partitionsByBroker).reduce((obj, [nodeId, nodePartitions]) => {\n        obj[nodeId] = {\n          topic,\n          partitions: partitions.filter(p => nodePartitions.includes(p.partition))\n        };\n        return obj;\n      }, {});\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref41 = _asyncToGenerator(function* (bail) {\n          try {\n            const partitionErrors = [];\n            const brokerRequests = entries(seekEntriesByBroker).map(([nodeId, {\n              topic,\n              partitions\n            }]) => /*#__PURE__*/_asyncToGenerator(function* () {\n              const broker = yield cluster.findBroker({\n                nodeId\n              });\n              yield broker.deleteRecords({\n                topics: [{\n                  topic,\n                  partitions\n                }]\n              });\n              // remove successful entry so it's ignored on retry\n              delete seekEntriesByBroker[nodeId];\n            }));\n            yield Promise.all(brokerRequests.map(request => request().catch(e => {\n              if (e.name === 'KafkaJSDeleteTopicRecordsError') {\n                e.partitions.forEach(({\n                  partition,\n                  offset,\n                  error\n                }) => {\n                  partitionErrors.push({\n                    partition,\n                    offset,\n                    error\n                  });\n                });\n              } else {\n                // then it's an unknown error, not from the broker response\n                throw e;\n              }\n            })));\n            if (partitionErrors.length > 0) {\n              throw new KafkaJSDeleteTopicRecordsError({\n                topic,\n                partitions: partitionErrors\n              });\n            }\n          } catch (e) {\n            if (e.retriable && e.partitions.some(({\n              error\n            }) => staleMetadata(error) || error.name === 'KafkaJSMetadataNotLoaded')) {\n              yield cluster.refreshMetadata();\n            }\n            throw e;\n          }\n        });\n        return function (_x49) {\n          return _ref41.apply(this, arguments);\n        };\n      }());\n    });\n    return function deleteTopicRecords(_x48) {\n      return _ref40.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {Array<ACLEntry>} acl\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLEntry\n   */\n  const createAcls = /*#__PURE__*/function () {\n    var _ref43 = _asyncToGenerator(function* ({\n      acl\n    }) {\n      if (!acl || !Array.isArray(acl)) {\n        throw new KafkaJSNonRetriableError(`Invalid ACL array ${acl}`);\n      }\n      if (acl.length === 0) {\n        throw new KafkaJSNonRetriableError('Empty ACL array');\n      }\n\n      // Validate principal\n      if (acl.some(({\n        principal\n      }) => typeof principal !== 'string')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL array, the principals have to be a valid string');\n      }\n\n      // Validate host\n      if (acl.some(({\n        host\n      }) => typeof host !== 'string')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL array, the hosts have to be a valid string');\n      }\n\n      // Validate resourceName\n      if (acl.some(({\n        resourceName\n      }) => typeof resourceName !== 'string')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL array, the resourceNames have to be a valid string');\n      }\n      let invalidType;\n      // Validate operation\n      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n      invalidType = acl.find(i => !validOperationTypes.includes(i.operation));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate resourcePatternTypes\n      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n      invalidType = acl.find(i => !validResourcePatternTypes.includes(i.resourcePatternType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate permissionTypes\n      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n      invalidType = acl.find(i => !validPermissionTypes.includes(i.permissionType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate resourceTypes\n      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n      invalidType = acl.find(i => !validResourceTypes.includes(i.resourceType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref44 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            yield broker.createAcls({\n              acl\n            });\n            return true;\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not create ACL', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x51, _x52, _x53) {\n          return _ref44.apply(this, arguments);\n        };\n      }());\n    });\n    return function createAcls(_x50) {\n      return _ref43.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {ACLResourceTypes} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {ACLResourcePatternTypes} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {ACLOperationTypes} operation The type of operation\n   * @param {ACLPermissionTypes} permissionType The type of permission\n   * @return {Promise<void>}\n   *\n   * @typedef {number} ACLResourceTypes\n   * @typedef {number} ACLResourcePatternTypes\n   * @typedef {number} ACLOperationTypes\n   * @typedef {number} ACLPermissionTypes\n   */\n  const describeAcls = /*#__PURE__*/function () {\n    var _ref45 = _asyncToGenerator(function* ({\n      resourceType,\n      resourceName,\n      resourcePatternType,\n      principal,\n      host,\n      operation,\n      permissionType\n    }) {\n      // Validate principal\n      if (typeof principal !== 'string' && typeof principal !== 'undefined') {\n        throw new KafkaJSNonRetriableError('Invalid principal, the principal have to be a valid string');\n      }\n\n      // Validate host\n      if (typeof host !== 'string' && typeof host !== 'undefined') {\n        throw new KafkaJSNonRetriableError('Invalid host, the host have to be a valid string');\n      }\n\n      // Validate resourceName\n      if (typeof resourceName !== 'string' && typeof resourceName !== 'undefined') {\n        throw new KafkaJSNonRetriableError('Invalid resourceName, the resourceName have to be a valid string');\n      }\n\n      // Validate operation\n      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n      if (!validOperationTypes.includes(operation)) {\n        throw new KafkaJSNonRetriableError(`Invalid operation type ${operation}`);\n      }\n\n      // Validate resourcePatternType\n      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n      if (!validResourcePatternTypes.includes(resourcePatternType)) {\n        throw new KafkaJSNonRetriableError(`Invalid resource pattern filter type ${resourcePatternType}`);\n      }\n\n      // Validate permissionType\n      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n      if (!validPermissionTypes.includes(permissionType)) {\n        throw new KafkaJSNonRetriableError(`Invalid permission type ${permissionType}`);\n      }\n\n      // Validate resourceType\n      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n      if (!validResourceTypes.includes(resourceType)) {\n        throw new KafkaJSNonRetriableError(`Invalid resource type ${resourceType}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref46 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            const {\n              resources\n            } = yield broker.describeAcls({\n              resourceType,\n              resourceName,\n              resourcePatternType,\n              principal,\n              host,\n              operation,\n              permissionType\n            });\n            return {\n              resources\n            };\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not describe ACL', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x55, _x56, _x57) {\n          return _ref46.apply(this, arguments);\n        };\n      }());\n    });\n    return function describeAcls(_x54) {\n      return _ref45.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * @param {Array<ACLFilter>} filters\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLFilter\n   */\n  const deleteAcls = /*#__PURE__*/function () {\n    var _ref47 = _asyncToGenerator(function* ({\n      filters\n    }) {\n      if (!filters || !Array.isArray(filters)) {\n        throw new KafkaJSNonRetriableError(`Invalid ACL Filter array ${filters}`);\n      }\n      if (filters.length === 0) {\n        throw new KafkaJSNonRetriableError('Empty ACL Filter array');\n      }\n\n      // Validate principal\n      if (filters.some(({\n        principal\n      }) => typeof principal !== 'string' && typeof principal !== 'undefined')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the principals have to be a valid string');\n      }\n\n      // Validate host\n      if (filters.some(({\n        host\n      }) => typeof host !== 'string' && typeof host !== 'undefined')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the hosts have to be a valid string');\n      }\n\n      // Validate resourceName\n      if (filters.some(({\n        resourceName\n      }) => typeof resourceName !== 'string' && typeof resourceName !== 'undefined')) {\n        throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the resourceNames have to be a valid string');\n      }\n      let invalidType;\n      // Validate operation\n      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n      invalidType = filters.find(i => !validOperationTypes.includes(i.operation));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate resourcePatternTypes\n      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n      invalidType = filters.find(i => !validResourcePatternTypes.includes(i.resourcePatternType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate permissionTypes\n      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n      invalidType = filters.find(i => !validPermissionTypes.includes(i.permissionType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);\n      }\n\n      // Validate resourceTypes\n      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n      invalidType = filters.find(i => !validResourceTypes.includes(i.resourceType));\n      if (invalidType) {\n        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref48 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            const {\n              filterResponses\n            } = yield broker.deleteAcls({\n              filters\n            });\n            return {\n              filterResponses\n            };\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not delete ACL', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x59, _x60, _x61) {\n          return _ref48.apply(this, arguments);\n        };\n      }());\n    });\n    return function deleteAcls(_x58) {\n      return _ref47.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * Alter the replicas partitions are assigned to for a topic\n   * @param {Object} request\n   * @param {import(\"../../types\").IPartitionReassignment[]} request.topics topics and the paritions to be reassigned\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  const alterPartitionReassignments = /*#__PURE__*/function () {\n    var _ref49 = _asyncToGenerator(function* ({\n      topics,\n      timeout\n    }) {\n      if (!topics || !Array.isArray(topics)) {\n        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n      }\n      if (topics.filter(({\n        topic\n      }) => typeof topic !== 'string').length > 0) {\n        throw new KafkaJSNonRetriableError('Invalid topics array, the topic names have to be a valid string');\n      }\n      const topicNames = new Set(topics.map(({\n        topic\n      }) => topic));\n      if (topicNames.size < topics.length) {\n        throw new KafkaJSNonRetriableError('Invalid topics array, it cannot have multiple entries for the same topic');\n      }\n      for (const {\n        topic,\n        partitionAssignment\n      } of topics) {\n        if (!partitionAssignment || !Array.isArray(partitionAssignment)) {\n          throw new KafkaJSNonRetriableError(`Invalid partitions array: ${partitionAssignment} for topic: ${topic}`);\n        }\n        for (const {\n          partition,\n          replicas\n        } of partitionAssignment) {\n          if (partition === null || partition === undefined || typeof partition !== 'number' || partition < 0) {\n            throw new KafkaJSNonRetriableError(`Invalid partitions index: ${partition} for topic: ${topic}`);\n          }\n          if (!replicas || !Array.isArray(replicas)) {\n            throw new KafkaJSNonRetriableError(`Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}`);\n          }\n          if (replicas.filter(replica => typeof replica !== 'number' || replica < 0).length >= 1) {\n            throw new KafkaJSNonRetriableError(`Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}. Replicas must be a non negative number`);\n          }\n        }\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref50 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            yield broker.alterPartitionReassignments({\n              topics,\n              timeout\n            });\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not reassign partitions', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x63, _x64, _x65) {\n          return _ref50.apply(this, arguments);\n        };\n      }());\n    });\n    return function alterPartitionReassignments(_x62) {\n      return _ref49.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * List the partition reassignments in progress.\n   * If a partition is not going through a reassignment, its AddingReplicas and RemovingReplicas fields will simply be empty.\n   * If a partition doesn't exist, no response will be returned for it.\n   * @param {Object} request\n   * @param {import(\"../../types\").TopicPartitions[]} request.topics topics and the paritions to be returned, if this is null will return all the topics.\n   * @param {number} [request.timeout]\n   * @returns {Promise<import(\"../../types\").ListPartitionReassignmentsResponse>}\n   */\n  const listPartitionReassignments = /*#__PURE__*/function () {\n    var _ref51 = _asyncToGenerator(function* ({\n      topics = null,\n      timeout\n    }) {\n      if (topics) {\n        if (!Array.isArray(topics)) {\n          throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n        }\n        if (topics.filter(({\n          topic\n        }) => typeof topic !== 'string').length > 0) {\n          throw new KafkaJSNonRetriableError('Invalid topics array, the topic names have to be a valid string');\n        }\n        const topicNames = new Set(topics.map(({\n          topic\n        }) => topic));\n        if (topicNames.size < topics.length) {\n          throw new KafkaJSNonRetriableError('Invalid topics array, it cannot have multiple entries for the same topic');\n        }\n        for (const {\n          topic,\n          partitions\n        } of topics) {\n          if (!partitions || !Array.isArray(partitions)) {\n            throw new KafkaJSNonRetriableError(`Invalid partition array: ${partitions} for topic: ${topic}`);\n          }\n          if (partitions.filter(partition => typeof partition !== 'number' || partition < 0).length >= 1) {\n            throw new KafkaJSNonRetriableError(`Invalid partition array: ${partitions} for topic: ${topic}. The partition indices have to be a valid number greater than 0.`);\n          }\n        }\n      }\n      const retrier = createRetry(retry);\n      return retrier( /*#__PURE__*/function () {\n        var _ref52 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield cluster.refreshMetadata();\n            const broker = yield cluster.findControllerBroker();\n            const response = yield broker.listPartitionReassignments({\n              topics,\n              timeout\n            });\n            return {\n              topics: response.topics\n            };\n          } catch (e) {\n            if (e.type === 'NOT_CONTROLLER') {\n              logger.warn('Could not reassign partitions', {\n                error: e.message,\n                retryCount,\n                retryTime\n              });\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x67, _x68, _x69) {\n          return _ref52.apply(this, arguments);\n        };\n      }());\n    });\n    return function listPartitionReassignments(_x66) {\n      return _ref51.apply(this, arguments);\n    };\n  }();\n\n  /** @type {import(\"../../types\").Admin[\"on\"]} */\n  const on = (eventName, listener) => {\n    if (!eventNames.includes(eventName)) {\n      throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`);\n    }\n    return instrumentationEmitter.addListener(unwrapEvent(eventName), event => {\n      event.type = wrapEvent(event.type);\n      Promise.resolve(listener(event)).catch(e => {\n        logger.error(`Failed to execute listener: ${e.message}`, {\n          eventName,\n          stack: e.stack\n        });\n      });\n    });\n  };\n\n  /**\n   * @return {Object} logger\n   */\n  const getLogger = () => logger;\n  return {\n    connect,\n    disconnect,\n    listTopics,\n    createTopics,\n    deleteTopics,\n    createPartitions,\n    fetchTopicMetadata,\n    describeCluster,\n    events,\n    fetchOffsets,\n    fetchTopicOffsets,\n    fetchTopicOffsetsByTimestamp,\n    setOffsets,\n    resetOffsets,\n    describeConfigs,\n    alterConfigs,\n    on,\n    logger: getLogger,\n    listGroups,\n    describeGroups,\n    deleteGroups,\n    describeAcls,\n    deleteAcls,\n    createAcls,\n    deleteTopicRecords,\n    alterPartitionReassignments,\n    listPartitionReassignments\n  };\n};","map":{"version":3,"names":["createRetry","require","waitFor","groupBy","createConsumer","InstrumentationEventEmitter","events","wrap","wrapEvent","unwrap","unwrapEvent","LEVELS","KafkaJSNonRetriableError","KafkaJSDeleteGroupsError","KafkaJSBrokerNotFound","KafkaJSDeleteTopicRecordsError","KafkaJSAggregateError","staleMetadata","CONFIG_RESOURCE_TYPES","ACL_RESOURCE_TYPES","ACL_OPERATION_TYPES","ACL_PERMISSION_TYPES","RESOURCE_PATTERN_TYPES","EARLIEST_OFFSET","LATEST_OFFSET","CONNECT","DISCONNECT","NO_CONTROLLER_ID","values","keys","entries","Object","eventNames","eventKeys","map","key","join","retryOnLeaderNotAvailable","fn","opts","callback","e","type","isConsumerGroupRunning","description","includes","state","findTopicPartitions","cluster","topic","addTargetTopic","refreshMetadataIfNecessary","findTopicPartitionMetadata","partitionId","sort","indexByPartition","array","reduce","obj","partition","props","assign","module","exports","logger","rootLogger","instrumentationEmitter","rootInstrumentationEmitter","retry","namespace","connect","emit","disconnect","listTopics","topicMetadata","metadata","topics","t","createTopics","validateOnly","timeout","waitForLeaders","Array","isArray","filter","length","topicNames","Set","size","configEntries","forEach","entry","index","requiredProperty","prototype","hasOwnProperty","call","retrier","bail","retryCount","retryTime","refreshMetadata","broker","findControllerBroker","topicNamesArray","from","delay","maxWait","timeoutMessage","warn","error","message","errors","every","createPartitions","topicPartitions","deleteTopics","targetTopics","delete","fetchTopicOffsets","high","fetchTopicsOffset","fromBeginning","partitions","p","low","highPartitions","pop","lowPartitions","offset","find","lowPartition","fetchTopicOffsetsByTimestamp","timestamp","offsets","fromTimestamp","parseInt","highPartition","fetchOffsets","groupId","resolveOffsets","coordinator","findGroupCoordinator","topicsToFetch","Promise","all","partitionsToFetch","responses","consumerOffsets","offsetFetch","indexedOffsets","recalculatedPartitions","resolvedOffset","Number","setOffsets","completePartitions","resetOffsets","earliest","partitionsToSeek","defaultOffset","consumer","NOTHING","subscribe","describeGroup","resolve","reject","on","FETCH","stop","then","catch","run","eachBatchAutoResolve","eachBatch","pause","seekData","seek","isBrokerConfig","BROKER","BROKER_LOGGER","groupResourcesByBroker","resources","defaultBroker","name","nodeId","findBroker","String","describeConfigs","includeSynonyms","validResourceTypes","invalidType","r","JSON","stringify","invalidName","invalidConfigs","configNames","controller","resourcerByBroker","describeConfigsAction","targetBroker","get","brokers","responseResources","result","alterConfigs","invalidConfigValue","some","value","alterConfigsAction","fetchTopicMetadata","partitionMetadata","describeCluster","nodes","clusterId","controllerId","host","port","listGroups","groups","brokerPool","response","concat","describeGroups","groupIds","coordinatorsForGroup","groupsByCoordinator","coordinators","group","apply","deleteGroups","invalidGroupId","g","results","clonedGroupIds","slice","brokersPerGroups","brokersPerNode","undefined","push","res","flatMap","errorCode","deleteTopicRecords","partitionsByBroker","findLeaderForPartitions","partitionsFound","flat","topicOffsets","leaderNotFoundErrors","retriable","seekEntriesByBroker","nodePartitions","partitionErrors","brokerRequests","deleteRecords","request","createAcls","acl","principal","resourceName","validOperationTypes","i","operation","validResourcePatternTypes","resourcePatternType","validPermissionTypes","permissionType","resourceType","describeAcls","deleteAcls","filters","filterResponses","alterPartitionReassignments","partitionAssignment","replicas","replica","listPartitionReassignments","eventName","listener","addListener","event","stack","getLogger"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/admin/index.js"],"sourcesContent":["const createRetry = require('../retry')\nconst waitFor = require('../utils/waitFor')\nconst groupBy = require('../utils/groupBy')\nconst createConsumer = require('../consumer')\nconst InstrumentationEventEmitter = require('../instrumentation/emitter')\nconst { events, wrap: wrapEvent, unwrap: unwrapEvent } = require('./instrumentationEvents')\nconst { LEVELS } = require('../loggers')\nconst {\n  KafkaJSNonRetriableError,\n  KafkaJSDeleteGroupsError,\n  KafkaJSBrokerNotFound,\n  KafkaJSDeleteTopicRecordsError,\n  KafkaJSAggregateError,\n} = require('../errors')\nconst { staleMetadata } = require('../protocol/error')\nconst CONFIG_RESOURCE_TYPES = require('../protocol/configResourceTypes')\nconst ACL_RESOURCE_TYPES = require('../protocol/aclResourceTypes')\nconst ACL_OPERATION_TYPES = require('../protocol/aclOperationTypes')\nconst ACL_PERMISSION_TYPES = require('../protocol/aclPermissionTypes')\nconst RESOURCE_PATTERN_TYPES = require('../protocol/resourcePatternTypes')\nconst { EARLIEST_OFFSET, LATEST_OFFSET } = require('../constants')\n\nconst { CONNECT, DISCONNECT } = events\n\nconst NO_CONTROLLER_ID = -1\n\nconst { values, keys, entries } = Object\nconst eventNames = values(events)\nconst eventKeys = keys(events)\n  .map(key => `admin.events.${key}`)\n  .join(', ')\n\nconst retryOnLeaderNotAvailable = (fn, opts = {}) => {\n  const callback = async () => {\n    try {\n      return await fn()\n    } catch (e) {\n      if (e.type !== 'LEADER_NOT_AVAILABLE') {\n        throw e\n      }\n      return false\n    }\n  }\n\n  return waitFor(callback, opts)\n}\n\nconst isConsumerGroupRunning = description => ['Empty', 'Dead'].includes(description.state)\nconst findTopicPartitions = async (cluster, topic) => {\n  await cluster.addTargetTopic(topic)\n  await cluster.refreshMetadataIfNecessary()\n\n  return cluster\n    .findTopicPartitionMetadata(topic)\n    .map(({ partitionId }) => partitionId)\n    .sort()\n}\nconst indexByPartition = array =>\n  array.reduce(\n    (obj, { partition, ...props }) => Object.assign(obj, { [partition]: { ...props } }),\n    {}\n  )\n\n/**\n *\n * @param {Object} params\n * @param {import(\"../../types\").Logger} params.logger\n * @param {InstrumentationEventEmitter} [params.instrumentationEmitter]\n * @param {import('../../types').RetryOptions} params.retry\n * @param {import(\"../../types\").Cluster} params.cluster\n *\n * @returns {import(\"../../types\").Admin}\n */\nmodule.exports = ({\n  logger: rootLogger,\n  instrumentationEmitter: rootInstrumentationEmitter,\n  retry,\n  cluster,\n}) => {\n  const logger = rootLogger.namespace('Admin')\n  const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter()\n\n  /**\n   * @returns {Promise}\n   */\n  const connect = async () => {\n    await cluster.connect()\n    instrumentationEmitter.emit(CONNECT)\n  }\n\n  /**\n   * @return {Promise}\n   */\n  const disconnect = async () => {\n    await cluster.disconnect()\n    instrumentationEmitter.emit(DISCONNECT)\n  }\n\n  /**\n   * @return {Promise}\n   */\n  const listTopics = async () => {\n    const { topicMetadata } = await cluster.metadata()\n    const topics = topicMetadata.map(t => t.topic)\n    return topics\n  }\n\n  /**\n   * @param {Object} request\n   * @param {array} request.topics\n   * @param {boolean} [request.validateOnly=false]\n   * @param {number} [request.timeout=5000]\n   * @param {boolean} [request.waitForLeaders=true]\n   * @return {Promise}\n   */\n  const createTopics = async ({ topics, validateOnly, timeout, waitForLeaders = true }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n    }\n\n    if (topics.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, the topic names have to be a valid string'\n      )\n    }\n\n    const topicNames = new Set(topics.map(({ topic }) => topic))\n    if (topicNames.size < topics.length) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, it cannot have multiple entries for the same topic'\n      )\n    }\n\n    for (const { topic, configEntries } of topics) {\n      if (configEntries == null) {\n        continue\n      }\n\n      if (!Array.isArray(configEntries)) {\n        throw new KafkaJSNonRetriableError(\n          `Invalid configEntries for topic \"${topic}\", must be an array`\n        )\n      }\n\n      configEntries.forEach((entry, index) => {\n        if (typeof entry !== 'object' || entry == null) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid configEntries for topic \"${topic}\". Entry ${index} must be an object`\n          )\n        }\n\n        for (const requiredProperty of ['name', 'value']) {\n          if (\n            !Object.prototype.hasOwnProperty.call(entry, requiredProperty) ||\n            typeof entry[requiredProperty] !== 'string'\n          ) {\n            throw new KafkaJSNonRetriableError(\n              `Invalid configEntries for topic \"${topic}\". Entry ${index} must have a valid \"${requiredProperty}\" property`\n            )\n          }\n        }\n      })\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createTopics({ topics, validateOnly, timeout })\n\n        if (waitForLeaders) {\n          const topicNamesArray = Array.from(topicNames.values())\n          await retryOnLeaderNotAvailable(async () => await broker.metadata(topicNamesArray), {\n            delay: 100,\n            maxWait: timeout,\n            timeoutMessage: 'Timed out while waiting for topic leaders',\n          })\n        }\n\n        return true\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        if (e instanceof KafkaJSAggregateError) {\n          if (e.errors.every(error => error.type === 'TOPIC_ALREADY_EXISTS')) {\n            return false\n          }\n        }\n\n        bail(e)\n      }\n    })\n  }\n  /**\n   * @param {array} topicPartitions\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @return {Promise<void>}\n   */\n  const createPartitions = async ({ topicPartitions, validateOnly, timeout }) => {\n    if (!topicPartitions || !Array.isArray(topicPartitions)) {\n      throw new KafkaJSNonRetriableError(`Invalid topic partitions array ${topicPartitions}`)\n    }\n    if (topicPartitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Empty topic partitions array`)\n    }\n\n    if (topicPartitions.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topic partitions array, the topic names have to be a valid string'\n      )\n    }\n\n    const topicNames = new Set(topicPartitions.map(({ topic }) => topic))\n    if (topicNames.size < topicPartitions.length) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topic partitions array, it cannot have multiple entries for the same topic'\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createPartitions({ topicPartitions, validateOnly, timeout })\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string[]} topics\n   * @param {number} [timeout=5000]\n   * @return {Promise}\n   */\n  const deleteTopics = async ({ topics, timeout }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n    }\n\n    if (topics.filter(topic => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError('Invalid topics array, the names must be a valid string')\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.deleteTopics({ topics, timeout })\n\n        // Remove deleted topics\n        for (const topic of topics) {\n          cluster.targetTopics.delete(topic)\n        }\n\n        await cluster.refreshMetadata()\n      } catch (e) {\n        if (['NOT_CONTROLLER', 'UNKNOWN_TOPIC_OR_PARTITION'].includes(e.type)) {\n          logger.warn('Could not delete topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        if (e.type === 'REQUEST_TIMED_OUT') {\n          logger.error(\n            'Could not delete topics, check if \"delete.topic.enable\" is set to \"true\" (the default value is \"false\") or increase the timeout',\n            {\n              error: e.message,\n              retryCount,\n              retryTime,\n            }\n          )\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} topic\n   */\n\n  const fetchTopicOffsets = async topic => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic)\n        await cluster.refreshMetadataIfNecessary()\n\n        const metadata = cluster.findTopicPartitionMetadata(topic)\n        const high = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: false,\n            partitions: metadata.map(p => ({ partition: p.partitionId })),\n          },\n        ])\n\n        const low = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: true,\n            partitions: metadata.map(p => ({ partition: p.partitionId })),\n          },\n        ])\n\n        const { partitions: highPartitions } = high.pop()\n        const { partitions: lowPartitions } = low.pop()\n        return highPartitions.map(({ partition, offset }) => ({\n          partition,\n          offset,\n          high: offset,\n          low: lowPartitions.find(({ partition: lowPartition }) => lowPartition === partition)\n            .offset,\n        }))\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} [timestamp]\n   */\n\n  const fetchTopicOffsetsByTimestamp = async (topic, timestamp) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic)\n        await cluster.refreshMetadataIfNecessary()\n\n        const metadata = cluster.findTopicPartitionMetadata(topic)\n        const partitions = metadata.map(p => ({ partition: p.partitionId }))\n\n        const high = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: false,\n            partitions,\n          },\n        ])\n        const { partitions: highPartitions } = high.pop()\n\n        const offsets = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromTimestamp: timestamp,\n            partitions,\n          },\n        ])\n        const { partitions: lowPartitions } = offsets.pop()\n\n        return lowPartitions.map(({ partition, offset }) => ({\n          partition,\n          offset:\n            parseInt(offset, 10) >= 0\n              ? offset\n              : highPartitions.find(({ partition: highPartition }) => highPartition === partition)\n                  .offset,\n        }))\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Fetch offsets for a topic or multiple topics\n   *\n   * Note: set either topic or topics but not both.\n   *\n   * @param {string} groupId\n   * @param {string[]} topics - list of topics to fetch offsets for, defaults to `[]` which fetches all topics for `groupId`.\n   * @param {boolean} [resolveOffsets=false]\n   * @return {Promise}\n   */\n  const fetchOffsets = async ({ groupId, topics, resolveOffsets = false }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topics) {\n      topics = []\n    }\n\n    if (!Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError('Expected topics array to be set')\n    }\n\n    const coordinator = await cluster.findGroupCoordinator({ groupId })\n    const topicsToFetch = await Promise.all(\n      topics.map(async topic => {\n        const partitions = await findTopicPartitions(cluster, topic)\n        const partitionsToFetch = partitions.map(partition => ({ partition }))\n        return { topic, partitions: partitionsToFetch }\n      })\n    )\n    let { responses: consumerOffsets } = await coordinator.offsetFetch({\n      groupId,\n      topics: topicsToFetch,\n    })\n\n    if (resolveOffsets) {\n      consumerOffsets = await Promise.all(\n        consumerOffsets.map(async ({ topic, partitions }) => {\n          const indexedOffsets = indexByPartition(await fetchTopicOffsets(topic))\n          const recalculatedPartitions = partitions.map(({ offset, partition, ...props }) => {\n            let resolvedOffset = offset\n            if (Number(offset) === EARLIEST_OFFSET) {\n              resolvedOffset = indexedOffsets[partition].low\n            }\n            if (Number(offset) === LATEST_OFFSET) {\n              resolvedOffset = indexedOffsets[partition].high\n            }\n            return {\n              partition,\n              offset: resolvedOffset,\n              ...props,\n            }\n          })\n\n          await setOffsets({ groupId, topic, partitions: recalculatedPartitions })\n\n          return {\n            topic,\n            partitions: recalculatedPartitions,\n          }\n        })\n      )\n    }\n\n    return consumerOffsets.map(({ topic, partitions }) => {\n      const completePartitions = partitions.map(({ partition, offset, metadata }) => ({\n        partition,\n        offset,\n        metadata: metadata || null,\n      }))\n\n      return { topic, partitions: completePartitions }\n    })\n  }\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [earliest=false]\n   * @return {Promise}\n   */\n  const resetOffsets = async ({ groupId, topic, earliest = false }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const partitions = await findTopicPartitions(cluster, topic)\n    const partitionsToSeek = partitions.map(partition => ({\n      partition,\n      offset: cluster.defaultOffset({ fromBeginning: earliest }),\n    }))\n\n    return setOffsets({ groupId, topic, partitions: partitionsToSeek })\n  }\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const setOffsets = async ({ groupId, topic, partitions }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`)\n    }\n\n    const consumer = createConsumer({\n      logger: rootLogger.namespace('Admin', LEVELS.NOTHING),\n      cluster,\n      groupId,\n    })\n\n    await consumer.subscribe({ topic, fromBeginning: true })\n    const description = await consumer.describeGroup()\n\n    if (!isConsumerGroupRunning(description)) {\n      throw new KafkaJSNonRetriableError(\n        `The consumer group must have no running instances, current state: ${description.state}`\n      )\n    }\n\n    return new Promise((resolve, reject) => {\n      consumer.on(consumer.events.FETCH, async () =>\n        consumer\n          .stop()\n          .then(resolve)\n          .catch(reject)\n      )\n\n      consumer\n        .run({\n          eachBatchAutoResolve: false,\n          eachBatch: async () => true,\n        })\n        .catch(reject)\n\n      // This consumer doesn't need to consume any data\n      consumer.pause([{ topic }])\n\n      for (const seekData of partitions) {\n        consumer.seek({ topic, ...seekData })\n      }\n    })\n  }\n\n  const isBrokerConfig = type =>\n    [CONFIG_RESOURCE_TYPES.BROKER, CONFIG_RESOURCE_TYPES.BROKER_LOGGER].includes(type)\n\n  /**\n   * Broker configs can only be returned by the target broker\n   *\n   * @see\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3783\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2027\n   *\n   * @param {Broker} defaultBroker. Broker used in case the configuration is not a broker config\n   */\n  const groupResourcesByBroker = ({ resources, defaultBroker }) =>\n    groupBy(resources, async ({ type, name: nodeId }) => {\n      return isBrokerConfig(type)\n        ? await cluster.findBroker({ nodeId: String(nodeId) })\n        : defaultBroker\n    })\n\n  /**\n   * @param {Array<ResourceConfigQuery>} resources\n   * @param {boolean} [includeSynonyms=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfigQuery\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<String>} [configNames=[]]\n   */\n  const describeConfigs = async ({ resources, includeSynonyms }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`)\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty')\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES)\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string')\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`\n      )\n    }\n\n    const invalidConfigs = resources.find(\n      r => !Array.isArray(r.configNames) && r.configNames != null\n    )\n\n    if (invalidConfigs) {\n      const { configNames } = invalidConfigs\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const controller = await cluster.findControllerBroker()\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller,\n        })\n\n        const describeConfigsAction = async broker => {\n          const targetBroker = broker || controller\n          return targetBroker.describeConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            includeSynonyms,\n          })\n        }\n\n        const brokers = Array.from(resourcerByBroker.keys())\n        const responses = await Promise.all(brokers.map(describeConfigsAction))\n        const responseResources = responses.reduce(\n          (result, { resources }) => [...result, ...resources],\n          []\n        )\n\n        return { resources: responseResources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe configs', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ResourceConfig>} resources\n   * @param {boolean} [validateOnly=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfig\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<ResourceConfigEntry>} configEntries\n   *\n   * @typedef {Object} ResourceConfigEntry\n   * @property {string} name\n   * @property {string} value\n   */\n  const alterConfigs = async ({ resources, validateOnly }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`)\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty')\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES)\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string')\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`\n      )\n    }\n\n    const invalidConfigs = resources.find(r => !Array.isArray(r.configEntries))\n\n    if (invalidConfigs) {\n      const { configEntries } = invalidConfigs\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`\n      )\n    }\n\n    const invalidConfigValue = resources.find(r =>\n      r.configEntries.some(e => typeof e.name !== 'string' || typeof e.value !== 'string')\n    )\n\n    if (invalidConfigValue) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const controller = await cluster.findControllerBroker()\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller,\n        })\n\n        const alterConfigsAction = async broker => {\n          const targetBroker = broker || controller\n          return targetBroker.alterConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            validateOnly: !!validateOnly,\n          })\n        }\n\n        const brokers = Array.from(resourcerByBroker.keys())\n        const responses = await Promise.all(brokers.map(alterConfigsAction))\n        const responseResources = responses.reduce(\n          (result, { resources }) => [...result, ...resources],\n          []\n        )\n\n        return { resources: responseResources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not alter configs', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n  const fetchTopicMetadata = async ({ topics = [] } = {}) => {\n    if (topics) {\n      topics.forEach(topic => {\n        if (!topic || typeof topic !== 'string') {\n          throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n        }\n      })\n    }\n\n    const metadata = await cluster.metadata({ topics })\n\n    return {\n      topics: metadata.topicMetadata.map(topicMetadata => ({\n        name: topicMetadata.topic,\n        partitions: topicMetadata.partitionMetadata,\n      })),\n    }\n  }\n\n  /**\n   * Describe cluster\n   *\n   * @return {Promise<ClusterMetadata>}\n   *\n   * @typedef {Object} ClusterMetadata\n   * @property {Array<Broker>} brokers\n   * @property {Number} controller Current controller id. Returns null if unknown.\n   * @property {String} clusterId\n   *\n   * @typedef {Object} Broker\n   * @property {Number} nodeId\n   * @property {String} host\n   * @property {Number} port\n   */\n  const describeCluster = async () => {\n    const { brokers: nodes, clusterId, controllerId } = await cluster.metadata({ topics: [] })\n    const brokers = nodes.map(({ nodeId, host, port }) => ({\n      nodeId,\n      host,\n      port,\n    }))\n    const controller =\n      controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId\n\n    return {\n      brokers,\n      controller,\n      clusterId,\n    }\n  }\n\n  /**\n   * List groups in a broker\n   *\n   * @return {Promise<ListGroups>}\n   *\n   * @typedef {Object} ListGroups\n   * @property {Array<ListGroup>} groups\n   *\n   * @typedef {Object} ListGroup\n   * @property {string} groupId\n   * @property {string} protocolType\n   */\n  const listGroups = async () => {\n    await cluster.refreshMetadata()\n    let groups = []\n    for (var nodeId in cluster.brokerPool.brokers) {\n      const broker = await cluster.findBroker({ nodeId })\n      const response = await broker.listGroups()\n      groups = groups.concat(response.groups)\n    }\n\n    return { groups }\n  }\n\n  /**\n   * Describe groups by group ids\n   * @param {Array<string>} groupIds\n   *\n   * @typedef {Object} GroupDescriptions\n   * @property {Array<GroupDescription>} groups\n   *\n   * @return {Promise<GroupDescriptions>}\n   */\n  const describeGroups = async groupIds => {\n    const coordinatorsForGroup = await Promise.all(\n      groupIds.map(async groupId => {\n        const coordinator = await cluster.findGroupCoordinator({ groupId })\n        return {\n          coordinator,\n          groupId,\n        }\n      })\n    )\n\n    const groupsByCoordinator = Object.values(\n      coordinatorsForGroup.reduce((coordinators, { coordinator, groupId }) => {\n        const group = coordinators[coordinator.nodeId]\n\n        if (group) {\n          coordinators[coordinator.nodeId] = {\n            ...group,\n            groupIds: [...group.groupIds, groupId],\n          }\n        } else {\n          coordinators[coordinator.nodeId] = { coordinator, groupIds: [groupId] }\n        }\n        return coordinators\n      }, {})\n    )\n\n    const responses = await Promise.all(\n      groupsByCoordinator.map(async ({ coordinator, groupIds }) => {\n        const retrier = createRetry(retry)\n        const { groups } = await retrier(() => coordinator.describeGroups({ groupIds }))\n        return groups\n      })\n    )\n\n    const groups = [].concat.apply([], responses)\n\n    return { groups }\n  }\n\n  /**\n   * Delete groups in a broker\n   *\n   * @param {string[]} [groupIds]\n   * @return {Promise<DeleteGroups>}\n   *\n   * @typedef {Array} DeleteGroups\n   * @property {string} groupId\n   * @property {number} errorCode\n   */\n  const deleteGroups = async groupIds => {\n    if (!groupIds || !Array.isArray(groupIds)) {\n      throw new KafkaJSNonRetriableError(`Invalid groupIds array ${groupIds}`)\n    }\n\n    const invalidGroupId = groupIds.some(g => typeof g !== 'string')\n\n    if (invalidGroupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    let results = []\n\n    let clonedGroupIds = groupIds.slice()\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        if (clonedGroupIds.length === 0) return []\n\n        await cluster.refreshMetadata()\n\n        const brokersPerGroups = {}\n        const brokersPerNode = {}\n        for (const groupId of clonedGroupIds) {\n          const broker = await cluster.findGroupCoordinator({ groupId })\n          if (brokersPerGroups[broker.nodeId] === undefined) brokersPerGroups[broker.nodeId] = []\n          brokersPerGroups[broker.nodeId].push(groupId)\n          brokersPerNode[broker.nodeId] = broker\n        }\n\n        const res = await Promise.all(\n          Object.keys(brokersPerNode).map(\n            async nodeId => await brokersPerNode[nodeId].deleteGroups(brokersPerGroups[nodeId])\n          )\n        )\n\n        const errors = res\n          .flatMap(({ results }) =>\n            results.map(({ groupId, errorCode, error }) => {\n              return { groupId, errorCode, error }\n            })\n          )\n          .filter(({ errorCode }) => errorCode !== 0)\n\n        clonedGroupIds = errors.map(({ groupId }) => groupId)\n\n        if (errors.length > 0) throw new KafkaJSDeleteGroupsError('Error in DeleteGroups', errors)\n\n        results = res.flatMap(({ results }) => results)\n\n        return results\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER' || e.type === 'COORDINATOR_NOT_AVAILABLE') {\n          logger.warn('Could not delete groups', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Delete topic records up to the selected partition offsets\n   *\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const deleteTopicRecords = async ({ topic, partitions }) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic \"${topic}\"`)\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`)\n    }\n\n    const partitionsByBroker = cluster.findLeaderForPartitions(\n      topic,\n      partitions.map(p => p.partition)\n    )\n\n    const partitionsFound = values(partitionsByBroker).flat()\n    const topicOffsets = await fetchTopicOffsets(topic)\n\n    const leaderNotFoundErrors = []\n    partitions.forEach(({ partition, offset }) => {\n      // throw if no leader found for partition\n      if (!partitionsFound.includes(partition)) {\n        leaderNotFoundErrors.push({\n          partition,\n          offset,\n          error: new KafkaJSBrokerNotFound('Could not find the leader for the partition', {\n            retriable: false,\n          }),\n        })\n        return\n      }\n      const { low } = topicOffsets.find(p => p.partition === partition) || {\n        high: undefined,\n        low: undefined,\n      }\n      // warn in case of offset below low watermark\n      if (parseInt(offset) < parseInt(low) && parseInt(offset) !== -1) {\n        logger.warn(\n          'The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition',\n          {\n            topic,\n            partition,\n            offset,\n          }\n        )\n      }\n    })\n\n    if (leaderNotFoundErrors.length > 0) {\n      throw new KafkaJSDeleteTopicRecordsError({ topic, partitions: leaderNotFoundErrors })\n    }\n\n    const seekEntriesByBroker = entries(partitionsByBroker).reduce(\n      (obj, [nodeId, nodePartitions]) => {\n        obj[nodeId] = {\n          topic,\n          partitions: partitions.filter(p => nodePartitions.includes(p.partition)),\n        }\n        return obj\n      },\n      {}\n    )\n\n    const retrier = createRetry(retry)\n    return retrier(async bail => {\n      try {\n        const partitionErrors = []\n\n        const brokerRequests = entries(seekEntriesByBroker).map(\n          ([nodeId, { topic, partitions }]) => async () => {\n            const broker = await cluster.findBroker({ nodeId })\n            await broker.deleteRecords({ topics: [{ topic, partitions }] })\n            // remove successful entry so it's ignored on retry\n            delete seekEntriesByBroker[nodeId]\n          }\n        )\n\n        await Promise.all(\n          brokerRequests.map(request =>\n            request().catch(e => {\n              if (e.name === 'KafkaJSDeleteTopicRecordsError') {\n                e.partitions.forEach(({ partition, offset, error }) => {\n                  partitionErrors.push({\n                    partition,\n                    offset,\n                    error,\n                  })\n                })\n              } else {\n                // then it's an unknown error, not from the broker response\n                throw e\n              }\n            })\n          )\n        )\n\n        if (partitionErrors.length > 0) {\n          throw new KafkaJSDeleteTopicRecordsError({\n            topic,\n            partitions: partitionErrors,\n          })\n        }\n      } catch (e) {\n        if (\n          e.retriable &&\n          e.partitions.some(\n            ({ error }) => staleMetadata(error) || error.name === 'KafkaJSMetadataNotLoaded'\n          )\n        ) {\n          await cluster.refreshMetadata()\n        }\n        throw e\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ACLEntry>} acl\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLEntry\n   */\n  const createAcls = async ({ acl }) => {\n    if (!acl || !Array.isArray(acl)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL array ${acl}`)\n    }\n    if (acl.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL array')\n    }\n\n    // Validate principal\n    if (acl.some(({ principal }) => typeof principal !== 'string')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL array, the principals have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (acl.some(({ host }) => typeof host !== 'string')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL array, the hosts have to be a valid string')\n    }\n\n    // Validate resourceName\n    if (acl.some(({ resourceName }) => typeof resourceName !== 'string')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL array, the resourceNames have to be a valid string'\n      )\n    }\n\n    let invalidType\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    invalidType = acl.find(i => !validOperationTypes.includes(i.operation))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourcePatternTypes\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    invalidType = acl.find(i => !validResourcePatternTypes.includes(i.resourcePatternType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(\n          invalidType\n        )}`\n      )\n    }\n\n    // Validate permissionTypes\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    invalidType = acl.find(i => !validPermissionTypes.includes(i.permissionType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourceTypes\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    invalidType = acl.find(i => !validResourceTypes.includes(i.resourceType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createAcls({ acl })\n\n        return true\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {ACLResourceTypes} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {ACLResourcePatternTypes} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {ACLOperationTypes} operation The type of operation\n   * @param {ACLPermissionTypes} permissionType The type of permission\n   * @return {Promise<void>}\n   *\n   * @typedef {number} ACLResourceTypes\n   * @typedef {number} ACLResourcePatternTypes\n   * @typedef {number} ACLOperationTypes\n   * @typedef {number} ACLPermissionTypes\n   */\n  const describeAcls = async ({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType,\n  }) => {\n    // Validate principal\n    if (typeof principal !== 'string' && typeof principal !== 'undefined') {\n      throw new KafkaJSNonRetriableError(\n        'Invalid principal, the principal have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (typeof host !== 'string' && typeof host !== 'undefined') {\n      throw new KafkaJSNonRetriableError('Invalid host, the host have to be a valid string')\n    }\n\n    // Validate resourceName\n    if (typeof resourceName !== 'string' && typeof resourceName !== 'undefined') {\n      throw new KafkaJSNonRetriableError(\n        'Invalid resourceName, the resourceName have to be a valid string'\n      )\n    }\n\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    if (!validOperationTypes.includes(operation)) {\n      throw new KafkaJSNonRetriableError(`Invalid operation type ${operation}`)\n    }\n\n    // Validate resourcePatternType\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    if (!validResourcePatternTypes.includes(resourcePatternType)) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern filter type ${resourcePatternType}`\n      )\n    }\n\n    // Validate permissionType\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    if (!validPermissionTypes.includes(permissionType)) {\n      throw new KafkaJSNonRetriableError(`Invalid permission type ${permissionType}`)\n    }\n\n    // Validate resourceType\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    if (!validResourceTypes.includes(resourceType)) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${resourceType}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        const { resources } = await broker.describeAcls({\n          resourceType,\n          resourceName,\n          resourcePatternType,\n          principal,\n          host,\n          operation,\n          permissionType,\n        })\n        return { resources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ACLFilter>} filters\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLFilter\n   */\n  const deleteAcls = async ({ filters }) => {\n    if (!filters || !Array.isArray(filters)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL Filter array ${filters}`)\n    }\n\n    if (filters.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL Filter array')\n    }\n\n    // Validate principal\n    if (\n      filters.some(\n        ({ principal }) => typeof principal !== 'string' && typeof principal !== 'undefined'\n      )\n    ) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the principals have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (filters.some(({ host }) => typeof host !== 'string' && typeof host !== 'undefined')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the hosts have to be a valid string'\n      )\n    }\n\n    // Validate resourceName\n    if (\n      filters.some(\n        ({ resourceName }) =>\n          typeof resourceName !== 'string' && typeof resourceName !== 'undefined'\n      )\n    ) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the resourceNames have to be a valid string'\n      )\n    }\n\n    let invalidType\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    invalidType = filters.find(i => !validOperationTypes.includes(i.operation))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourcePatternTypes\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    invalidType = filters.find(i => !validResourcePatternTypes.includes(i.resourcePatternType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(\n          invalidType\n        )}`\n      )\n    }\n\n    // Validate permissionTypes\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    invalidType = filters.find(i => !validPermissionTypes.includes(i.permissionType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourceTypes\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    invalidType = filters.find(i => !validResourceTypes.includes(i.resourceType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        const { filterResponses } = await broker.deleteAcls({ filters })\n        return { filterResponses }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not delete ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Alter the replicas partitions are assigned to for a topic\n   * @param {Object} request\n   * @param {import(\"../../types\").IPartitionReassignment[]} request.topics topics and the paritions to be reassigned\n   * @param {number} [request.timeout]\n   * @returns {Promise}\n   */\n  const alterPartitionReassignments = async ({ topics, timeout }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n    }\n\n    if (topics.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, the topic names have to be a valid string'\n      )\n    }\n\n    const topicNames = new Set(topics.map(({ topic }) => topic))\n    if (topicNames.size < topics.length) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, it cannot have multiple entries for the same topic'\n      )\n    }\n\n    for (const { topic, partitionAssignment } of topics) {\n      if (!partitionAssignment || !Array.isArray(partitionAssignment)) {\n        throw new KafkaJSNonRetriableError(\n          `Invalid partitions array: ${partitionAssignment} for topic: ${topic}`\n        )\n      }\n\n      for (const { partition, replicas } of partitionAssignment) {\n        if (\n          partition === null ||\n          partition === undefined ||\n          typeof partition !== 'number' ||\n          partition < 0\n        ) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid partitions index: ${partition} for topic: ${topic}`\n          )\n        }\n\n        if (!replicas || !Array.isArray(replicas)) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}`\n          )\n        }\n\n        if (replicas.filter(replica => typeof replica !== 'number' || replica < 0).length >= 1) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}. Replicas must be a non negative number`\n          )\n        }\n      }\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.alterPartitionReassignments({ topics, timeout })\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not reassign partitions', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * List the partition reassignments in progress.\n   * If a partition is not going through a reassignment, its AddingReplicas and RemovingReplicas fields will simply be empty.\n   * If a partition doesn't exist, no response will be returned for it.\n   * @param {Object} request\n   * @param {import(\"../../types\").TopicPartitions[]} request.topics topics and the paritions to be returned, if this is null will return all the topics.\n   * @param {number} [request.timeout]\n   * @returns {Promise<import(\"../../types\").ListPartitionReassignmentsResponse>}\n   */\n  const listPartitionReassignments = async ({ topics = null, timeout }) => {\n    if (topics) {\n      if (!Array.isArray(topics)) {\n        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n      }\n\n      if (topics.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n        throw new KafkaJSNonRetriableError(\n          'Invalid topics array, the topic names have to be a valid string'\n        )\n      }\n\n      const topicNames = new Set(topics.map(({ topic }) => topic))\n      if (topicNames.size < topics.length) {\n        throw new KafkaJSNonRetriableError(\n          'Invalid topics array, it cannot have multiple entries for the same topic'\n        )\n      }\n\n      for (const { topic, partitions } of topics) {\n        if (!partitions || !Array.isArray(partitions)) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid partition array: ${partitions} for topic: ${topic}`\n          )\n        }\n\n        if (\n          partitions.filter(partition => typeof partition !== 'number' || partition < 0).length >= 1\n        ) {\n          throw new KafkaJSNonRetriableError(\n            `Invalid partition array: ${partitions} for topic: ${topic}. The partition indices have to be a valid number greater than 0.`\n          )\n        }\n      }\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        const response = await broker.listPartitionReassignments({ topics, timeout })\n\n        return { topics: response.topics }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not reassign partitions', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /** @type {import(\"../../types\").Admin[\"on\"]} */\n  const on = (eventName, listener) => {\n    if (!eventNames.includes(eventName)) {\n      throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`)\n    }\n\n    return instrumentationEmitter.addListener(unwrapEvent(eventName), event => {\n      event.type = wrapEvent(event.type)\n      Promise.resolve(listener(event)).catch(e => {\n        logger.error(`Failed to execute listener: ${e.message}`, {\n          eventName,\n          stack: e.stack,\n        })\n      })\n    })\n  }\n\n  /**\n   * @return {Object} logger\n   */\n  const getLogger = () => logger\n\n  return {\n    connect,\n    disconnect,\n    listTopics,\n    createTopics,\n    deleteTopics,\n    createPartitions,\n    fetchTopicMetadata,\n    describeCluster,\n    events,\n    fetchOffsets,\n    fetchTopicOffsets,\n    fetchTopicOffsetsByTimestamp,\n    setOffsets,\n    resetOffsets,\n    describeConfigs,\n    alterConfigs,\n    on,\n    logger: getLogger,\n    listGroups,\n    describeGroups,\n    deleteGroups,\n    describeAcls,\n    deleteAcls,\n    createAcls,\n    deleteTopicRecords,\n    alterPartitionReassignments,\n    listPartitionReassignments,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}