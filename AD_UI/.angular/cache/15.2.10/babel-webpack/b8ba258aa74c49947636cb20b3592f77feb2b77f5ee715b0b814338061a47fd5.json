{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Decoder = require('../../../decoder');\nconst Encoder = require('../../../encoder');\nconst {\n  failure,\n  createErrorFromCode,\n  failIfVersionNotSupported,\n  errorCodes\n} = require('../../../error');\nconst {\n  KafkaJSProtocolError\n} = require('../../../../errors');\nconst SASL_AUTHENTICATION_FAILED = 58;\nconst protocolAuthError = errorCodes.find(e => e.code === SASL_AUTHENTICATION_FAILED);\n\n/**\n * SaslAuthenticate Response (Version: 0) => error_code error_message sasl_auth_bytes\n *   error_code => INT16\n *   error_message => NULLABLE_STRING\n *   sasl_auth_bytes => BYTES\n */\n\nconst decode = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (rawData) {\n    const decoder = new Decoder(rawData);\n    const errorCode = decoder.readInt16();\n    failIfVersionNotSupported(errorCode);\n    const errorMessage = decoder.readString();\n\n    // This is necessary to make the response compatible with the original\n    // mechanism protocols. They expect a byte response, which starts with\n    // the size\n    const authBytesEncoder = new Encoder().writeBytes(decoder.readBytes());\n    const authBytes = authBytesEncoder.buffer;\n    return {\n      errorCode,\n      errorMessage,\n      authBytes\n    };\n  });\n  return function decode(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst parse = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (data) {\n    if (data.errorCode === SASL_AUTHENTICATION_FAILED && data.errorMessage) {\n      throw new KafkaJSProtocolError({\n        ...protocolAuthError,\n        message: data.errorMessage\n      });\n    }\n    if (failure(data.errorCode)) {\n      throw createErrorFromCode(data.errorCode);\n    }\n    return data;\n  });\n  return function parse(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nmodule.exports = {\n  decode,\n  parse\n};","map":{"version":3,"names":["Decoder","require","Encoder","failure","createErrorFromCode","failIfVersionNotSupported","errorCodes","KafkaJSProtocolError","SASL_AUTHENTICATION_FAILED","protocolAuthError","find","e","code","decode","rawData","decoder","errorCode","readInt16","errorMessage","readString","authBytesEncoder","writeBytes","readBytes","authBytes","buffer","parse","data","message","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/requests/saslAuthenticate/v0/response.js"],"sourcesContent":["const Decoder = require('../../../decoder')\nconst Encoder = require('../../../encoder')\nconst {\n  failure,\n  createErrorFromCode,\n  failIfVersionNotSupported,\n  errorCodes,\n} = require('../../../error')\n\nconst { KafkaJSProtocolError } = require('../../../../errors')\nconst SASL_AUTHENTICATION_FAILED = 58\nconst protocolAuthError = errorCodes.find(e => e.code === SASL_AUTHENTICATION_FAILED)\n\n/**\n * SaslAuthenticate Response (Version: 0) => error_code error_message sasl_auth_bytes\n *   error_code => INT16\n *   error_message => NULLABLE_STRING\n *   sasl_auth_bytes => BYTES\n */\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData)\n  const errorCode = decoder.readInt16()\n\n  failIfVersionNotSupported(errorCode)\n  const errorMessage = decoder.readString()\n\n  // This is necessary to make the response compatible with the original\n  // mechanism protocols. They expect a byte response, which starts with\n  // the size\n  const authBytesEncoder = new Encoder().writeBytes(decoder.readBytes())\n  const authBytes = authBytesEncoder.buffer\n\n  return {\n    errorCode,\n    errorMessage,\n    authBytes,\n  }\n}\n\nconst parse = async data => {\n  if (data.errorCode === SASL_AUTHENTICATION_FAILED && data.errorMessage) {\n    throw new KafkaJSProtocolError({\n      ...protocolAuthError,\n      message: data.errorMessage,\n    })\n  }\n\n  if (failure(data.errorCode)) {\n    throw createErrorFromCode(data.errorCode)\n  }\n\n  return data\n}\n\nmodule.exports = {\n  decode,\n  parse,\n}\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAM;EACJE,OAAO;EACPC,mBAAmB;EACnBC,yBAAyB;EACzBC;AACF,CAAC,GAAGL,OAAO,CAAC,gBAAgB,CAAC;AAE7B,MAAM;EAAEM;AAAqB,CAAC,GAAGN,OAAO,CAAC,oBAAoB,CAAC;AAC9D,MAAMO,0BAA0B,GAAG,EAAE;AACrC,MAAMC,iBAAiB,GAAGH,UAAU,CAACI,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKJ,0BAA0B,CAAC;;AAErF;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMK,MAAM;EAAA,6BAAG,WAAMC,OAAO,EAAI;IAC9B,MAAMC,OAAO,GAAG,IAAIf,OAAO,CAACc,OAAO,CAAC;IACpC,MAAME,SAAS,GAAGD,OAAO,CAACE,SAAS,EAAE;IAErCZ,yBAAyB,CAACW,SAAS,CAAC;IACpC,MAAME,YAAY,GAAGH,OAAO,CAACI,UAAU,EAAE;;IAEzC;IACA;IACA;IACA,MAAMC,gBAAgB,GAAG,IAAIlB,OAAO,EAAE,CAACmB,UAAU,CAACN,OAAO,CAACO,SAAS,EAAE,CAAC;IACtE,MAAMC,SAAS,GAAGH,gBAAgB,CAACI,MAAM;IAEzC,OAAO;MACLR,SAAS;MACTE,YAAY;MACZK;IACF,CAAC;EACH,CAAC;EAAA,gBAlBKV,MAAM;IAAA;EAAA;AAAA,GAkBX;AAED,MAAMY,KAAK;EAAA,8BAAG,WAAMC,IAAI,EAAI;IAC1B,IAAIA,IAAI,CAACV,SAAS,KAAKR,0BAA0B,IAAIkB,IAAI,CAACR,YAAY,EAAE;MACtE,MAAM,IAAIX,oBAAoB,CAAC;QAC7B,GAAGE,iBAAiB;QACpBkB,OAAO,EAAED,IAAI,CAACR;MAChB,CAAC,CAAC;IACJ;IAEA,IAAIf,OAAO,CAACuB,IAAI,CAACV,SAAS,CAAC,EAAE;MAC3B,MAAMZ,mBAAmB,CAACsB,IAAI,CAACV,SAAS,CAAC;IAC3C;IAEA,OAAOU,IAAI;EACb,CAAC;EAAA,gBAbKD,KAAK;IAAA;EAAA;AAAA,GAaV;AAEDG,MAAM,CAACC,OAAO,GAAG;EACfhB,MAAM;EACNY;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}