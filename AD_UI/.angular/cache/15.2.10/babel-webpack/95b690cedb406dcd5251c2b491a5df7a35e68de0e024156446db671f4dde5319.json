{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst createRetry = require('../../retry');\nconst Lock = require('../../utils/lock');\nconst {\n  KafkaJSNonRetriableError\n} = require('../../errors');\nconst COORDINATOR_TYPES = require('../../protocol/coordinatorTypes');\nconst createStateMachine = require('./transactionStateMachine');\nconst {\n  INT_32_MAX_VALUE\n} = require('../../constants');\nconst assert = require('assert');\nconst STATES = require('./transactionStates');\nconst NO_PRODUCER_ID = -1;\nconst SEQUENCE_START = 0;\nconst INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = ['NOT_COORDINATOR_FOR_GROUP', 'GROUP_COORDINATOR_NOT_AVAILABLE', 'GROUP_LOAD_IN_PROGRESS',\n/**\n * The producer might have crashed and never committed the transaction; retry the\n * request so Kafka can abort the current transaction\n * @see https://github.com/apache/kafka/blob/201da0542726472d954080d54bc585b111aaf86f/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1001-L1002\n */\n'CONCURRENT_TRANSACTIONS'];\nconst COMMIT_RETRIABLE_PROTOCOL_ERRORS = ['UNKNOWN_TOPIC_OR_PARTITION', 'COORDINATOR_LOAD_IN_PROGRESS'];\nconst COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = ['COORDINATOR_NOT_AVAILABLE', 'NOT_COORDINATOR'];\n\n/**\n * @typedef {Object} EosManager\n */\n\n/**\n * Manage behavior for an idempotent producer and transactions.\n *\n * @returns {EosManager}\n */\nmodule.exports = ({\n  logger,\n  cluster,\n  transactionTimeout = 60000,\n  transactional,\n  transactionalId\n}) => {\n  if (transactional && !transactionalId) {\n    throw new KafkaJSNonRetriableError('Cannot manage transactions without a transactionalId');\n  }\n  const retrier = createRetry(cluster.retry);\n\n  /**\n   * Current producer ID\n   */\n  let producerId = NO_PRODUCER_ID;\n\n  /**\n   * Current producer epoch\n   */\n  let producerEpoch = 0;\n\n  /**\n   * Idempotent production requires that the producer track the sequence number of messages.\n   *\n   * Sequences are sent with every Record Batch and tracked per Topic-Partition\n   */\n  let producerSequence = {};\n\n  /**\n   * Idempotent production requires a mutex lock per broker to serialize requests with sequence number handling\n   */\n  let brokerMutexLocks = {};\n\n  /**\n   * Topic partitions already participating in the transaction\n   */\n  let transactionTopicPartitions = {};\n\n  /**\n   * Offsets have been added to the transaction\n   */\n  let hasOffsetsAddedToTransaction = false;\n  const stateMachine = createStateMachine({\n    logger\n  });\n  stateMachine.on('transition', ({\n    to\n  }) => {\n    if (to === STATES.READY) {\n      transactionTopicPartitions = {};\n      hasOffsetsAddedToTransaction = false;\n    }\n  });\n  const findTransactionCoordinator = () => {\n    return cluster.findGroupCoordinator({\n      groupId: transactionalId,\n      coordinatorType: COORDINATOR_TYPES.TRANSACTION\n    });\n  };\n  const transactionalGuard = () => {\n    if (!transactional) {\n      throw new KafkaJSNonRetriableError('Method unavailable if non-transactional');\n    }\n  };\n\n  /**\n   * A transaction is ongoing when offsets or partitions added to it\n   *\n   * @returns {boolean}\n   */\n  const isOngoing = () => {\n    return hasOffsetsAddedToTransaction || Object.entries(transactionTopicPartitions).some(([, partitions]) => {\n      return Object.entries(partitions).some(([, isPartitionAddedToTransaction]) => isPartitionAddedToTransaction);\n    });\n  };\n  const eosManager = stateMachine.createGuarded({\n    /**\n     * Get the current producer id\n     * @returns {number}\n     */\n    getProducerId() {\n      return producerId;\n    },\n    /**\n     * Get the current producer epoch\n     * @returns {number}\n     */\n    getProducerEpoch() {\n      return producerEpoch;\n    },\n    getTransactionalId() {\n      return transactionalId;\n    },\n    /**\n     * Initialize the idempotent producer by making an `InitProducerId` request.\n     * Overwrites any existing state in this transaction manager\n     */\n    initProducerId() {\n      return _asyncToGenerator(function* () {\n        return retrier( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n            try {\n              yield cluster.refreshMetadataIfNecessary();\n\n              // If non-transactional we can request the PID from any broker\n              const broker = yield transactional ? findTransactionCoordinator() : cluster.findControllerBroker();\n              const result = yield broker.initProducerId({\n                transactionalId: transactional ? transactionalId : undefined,\n                transactionTimeout\n              });\n              stateMachine.transitionTo(STATES.READY);\n              producerId = result.producerId;\n              producerEpoch = result.producerEpoch;\n              producerSequence = {};\n              brokerMutexLocks = {};\n              logger.debug('Initialized producer id & epoch', {\n                producerId,\n                producerEpoch\n              });\n            } catch (e) {\n              if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n                if (e.type === 'CONCURRENT_TRANSACTIONS') {\n                  logger.debug('There is an ongoing transaction on this transactionId, retrying', {\n                    error: e.message,\n                    stack: e.stack,\n                    transactionalId,\n                    retryCount,\n                    retryTime\n                  });\n                }\n                throw e;\n              }\n              bail(e);\n            }\n          });\n          return function (_x, _x2, _x3) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      })();\n    },\n    /**\n     * Get the current sequence for a given Topic-Partition. Defaults to 0.\n     *\n     * @param {string} topic\n     * @param {string} partition\n     * @returns {number}\n     */\n    getSequence(topic, partition) {\n      if (!eosManager.isInitialized()) {\n        return SEQUENCE_START;\n      }\n      producerSequence[topic] = producerSequence[topic] || {};\n      producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START;\n      return producerSequence[topic][partition];\n    },\n    /**\n     * Update the sequence for a given Topic-Partition.\n     *\n     * Do nothing if not yet initialized (not idempotent)\n     * @param {string} topic\n     * @param {string} partition\n     * @param {number} increment\n     */\n    updateSequence(topic, partition, increment) {\n      if (!eosManager.isInitialized()) {\n        return;\n      }\n      const previous = eosManager.getSequence(topic, partition);\n      let sequence = previous + increment;\n\n      // Sequence is defined as Int32 in the Record Batch,\n      // so theoretically should need to rotate here\n      if (sequence >= INT_32_MAX_VALUE) {\n        logger.debug(`Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`);\n        sequence = 0;\n      }\n      producerSequence[topic][partition] = sequence;\n    },\n    /**\n     * Begin a transaction\n     */\n    beginTransaction() {\n      transactionalGuard();\n      stateMachine.transitionTo(STATES.TRANSACTING);\n    },\n    /**\n     * Add partitions to a transaction if they are not already marked as participating.\n     *\n     * Should be called prior to sending any messages during a transaction\n     * @param {TopicData[]} topicData\n     *\n     * @typedef {Object} TopicData\n     * @property {string} topic\n     * @property {object[]} partitions\n     * @property {number} partitions[].partition\n     */\n    addPartitionsToTransaction(topicData) {\n      return _asyncToGenerator(function* () {\n        transactionalGuard();\n        const newTopicPartitions = {};\n        topicData.forEach(({\n          topic,\n          partitions\n        }) => {\n          transactionTopicPartitions[topic] = transactionTopicPartitions[topic] || {};\n          partitions.forEach(({\n            partition\n          }) => {\n            if (!transactionTopicPartitions[topic][partition]) {\n              newTopicPartitions[topic] = newTopicPartitions[topic] || [];\n              newTopicPartitions[topic].push(partition);\n            }\n          });\n        });\n        const topics = Object.keys(newTopicPartitions).map(topic => ({\n          topic,\n          partitions: newTopicPartitions[topic]\n        }));\n        if (topics.length) {\n          const broker = yield findTransactionCoordinator();\n          yield broker.addPartitionsToTxn({\n            transactionalId,\n            producerId,\n            producerEpoch,\n            topics\n          });\n        }\n        topics.forEach(({\n          topic,\n          partitions\n        }) => {\n          partitions.forEach(partition => {\n            transactionTopicPartitions[topic][partition] = true;\n          });\n        });\n      })();\n    },\n    /**\n     * Commit the ongoing transaction\n     */\n    commit() {\n      return _asyncToGenerator(function* () {\n        transactionalGuard();\n        stateMachine.transitionTo(STATES.COMMITTING);\n        if (!isOngoing()) {\n          logger.debug('No partitions or offsets registered, not sending EndTxn');\n          stateMachine.transitionTo(STATES.READY);\n          return;\n        }\n        const broker = yield findTransactionCoordinator();\n        yield broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: true\n        });\n        stateMachine.transitionTo(STATES.READY);\n      })();\n    },\n    /**\n     * Abort the ongoing transaction\n     */\n    abort() {\n      return _asyncToGenerator(function* () {\n        transactionalGuard();\n        stateMachine.transitionTo(STATES.ABORTING);\n        if (!isOngoing()) {\n          logger.debug('No partitions or offsets registered, not sending EndTxn');\n          stateMachine.transitionTo(STATES.READY);\n          return;\n        }\n        const broker = yield findTransactionCoordinator();\n        yield broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: false\n        });\n        stateMachine.transitionTo(STATES.READY);\n      })();\n    },\n    /**\n     * Whether the producer id has already been initialized\n     */\n    isInitialized() {\n      return producerId !== NO_PRODUCER_ID;\n    },\n    isTransactional() {\n      return transactional;\n    },\n    isInTransaction() {\n      return stateMachine.state() === STATES.TRANSACTING;\n    },\n    acquireBrokerLock(broker) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (_this.isInitialized()) {\n          brokerMutexLocks[broker.nodeId] = brokerMutexLocks[broker.nodeId] || new Lock({\n            timeout: 0xffff\n          });\n          yield brokerMutexLocks[broker.nodeId].acquire();\n        }\n      })();\n    },\n    releaseBrokerLock(broker) {\n      if (this.isInitialized()) brokerMutexLocks[broker.nodeId].release();\n    },\n    /**\n     * Mark the provided offsets as participating in the transaction for the given consumer group.\n     *\n     * This allows us to commit an offset as consumed only if the transaction passes.\n     * @param {string} consumerGroupId The unique group identifier\n     * @param {OffsetCommitTopic[]} topics The unique group identifier\n     * @returns {Promise}\n     *\n     * @typedef {Object} OffsetCommitTopic\n     * @property {string} topic\n     * @property {OffsetCommitTopicPartition[]} partitions\n     *\n     * @typedef {Object} OffsetCommitTopicPartition\n     * @property {number} partition\n     * @property {number} offset\n     */\n    sendOffsets({\n      consumerGroupId,\n      topics\n    }) {\n      return _asyncToGenerator(function* () {\n        assert(consumerGroupId, 'Missing consumerGroupId');\n        assert(topics, 'Missing offset topics');\n        const transactionCoordinator = yield findTransactionCoordinator();\n\n        // Do we need to add offsets if we've already done so for this consumer group?\n        yield transactionCoordinator.addOffsetsToTxn({\n          transactionalId,\n          producerId,\n          producerEpoch,\n          groupId: consumerGroupId\n        });\n        hasOffsetsAddedToTransaction = true;\n        let groupCoordinator = yield cluster.findGroupCoordinator({\n          groupId: consumerGroupId,\n          coordinatorType: COORDINATOR_TYPES.GROUP\n        });\n        return retrier( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n            try {\n              yield groupCoordinator.txnOffsetCommit({\n                transactionalId,\n                producerId,\n                producerEpoch,\n                groupId: consumerGroupId,\n                topics\n              });\n            } catch (e) {\n              if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n                logger.debug('Group coordinator is not ready yet, retrying', {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime\n                });\n                throw e;\n              }\n              if (COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e.type) || e.code === 'ECONNREFUSED') {\n                logger.debug('Invalid group coordinator, finding new group coordinator and retrying', {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime\n                });\n                groupCoordinator = yield cluster.findGroupCoordinator({\n                  groupId: consumerGroupId,\n                  coordinatorType: COORDINATOR_TYPES.GROUP\n                });\n                throw e;\n              }\n              bail(e);\n            }\n          });\n          return function (_x4, _x5, _x6) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n  },\n  /**\n   * Transaction state guards\n   */\n  {\n    initProducerId: {\n      legalStates: [STATES.UNINITIALIZED, STATES.READY]\n    },\n    beginTransaction: {\n      legalStates: [STATES.READY],\n      async: false\n    },\n    addPartitionsToTransaction: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    sendOffsets: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    commit: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    abort: {\n      legalStates: [STATES.TRANSACTING]\n    }\n  });\n  return eosManager;\n};","map":{"version":3,"names":["createRetry","require","Lock","KafkaJSNonRetriableError","COORDINATOR_TYPES","createStateMachine","INT_32_MAX_VALUE","assert","STATES","NO_PRODUCER_ID","SEQUENCE_START","INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS","COMMIT_RETRIABLE_PROTOCOL_ERRORS","COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS","module","exports","logger","cluster","transactionTimeout","transactional","transactionalId","retrier","retry","producerId","producerEpoch","producerSequence","brokerMutexLocks","transactionTopicPartitions","hasOffsetsAddedToTransaction","stateMachine","on","to","READY","findTransactionCoordinator","findGroupCoordinator","groupId","coordinatorType","TRANSACTION","transactionalGuard","isOngoing","Object","entries","some","partitions","isPartitionAddedToTransaction","eosManager","createGuarded","getProducerId","getProducerEpoch","getTransactionalId","initProducerId","bail","retryCount","retryTime","refreshMetadataIfNecessary","broker","findControllerBroker","result","undefined","transitionTo","debug","e","includes","type","error","message","stack","getSequence","topic","partition","isInitialized","updateSequence","increment","previous","sequence","beginTransaction","TRANSACTING","addPartitionsToTransaction","topicData","newTopicPartitions","forEach","push","topics","keys","map","length","addPartitionsToTxn","commit","COMMITTING","endTxn","transactionResult","abort","ABORTING","isTransactional","isInTransaction","state","acquireBrokerLock","nodeId","timeout","acquire","releaseBrokerLock","release","sendOffsets","consumerGroupId","transactionCoordinator","addOffsetsToTxn","groupCoordinator","GROUP","txnOffsetCommit","code","legalStates","UNINITIALIZED","async"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/producer/eosManager/index.js"],"sourcesContent":["const createRetry = require('../../retry')\nconst Lock = require('../../utils/lock')\nconst { KafkaJSNonRetriableError } = require('../../errors')\nconst COORDINATOR_TYPES = require('../../protocol/coordinatorTypes')\nconst createStateMachine = require('./transactionStateMachine')\nconst { INT_32_MAX_VALUE } = require('../../constants')\nconst assert = require('assert')\n\nconst STATES = require('./transactionStates')\nconst NO_PRODUCER_ID = -1\nconst SEQUENCE_START = 0\nconst INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = [\n  'NOT_COORDINATOR_FOR_GROUP',\n  'GROUP_COORDINATOR_NOT_AVAILABLE',\n  'GROUP_LOAD_IN_PROGRESS',\n  /**\n   * The producer might have crashed and never committed the transaction; retry the\n   * request so Kafka can abort the current transaction\n   * @see https://github.com/apache/kafka/blob/201da0542726472d954080d54bc585b111aaf86f/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1001-L1002\n   */\n  'CONCURRENT_TRANSACTIONS',\n]\nconst COMMIT_RETRIABLE_PROTOCOL_ERRORS = [\n  'UNKNOWN_TOPIC_OR_PARTITION',\n  'COORDINATOR_LOAD_IN_PROGRESS',\n]\nconst COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = ['COORDINATOR_NOT_AVAILABLE', 'NOT_COORDINATOR']\n\n/**\n * @typedef {Object} EosManager\n */\n\n/**\n * Manage behavior for an idempotent producer and transactions.\n *\n * @returns {EosManager}\n */\nmodule.exports = ({\n  logger,\n  cluster,\n  transactionTimeout = 60000,\n  transactional,\n  transactionalId,\n}) => {\n  if (transactional && !transactionalId) {\n    throw new KafkaJSNonRetriableError('Cannot manage transactions without a transactionalId')\n  }\n\n  const retrier = createRetry(cluster.retry)\n\n  /**\n   * Current producer ID\n   */\n  let producerId = NO_PRODUCER_ID\n\n  /**\n   * Current producer epoch\n   */\n  let producerEpoch = 0\n\n  /**\n   * Idempotent production requires that the producer track the sequence number of messages.\n   *\n   * Sequences are sent with every Record Batch and tracked per Topic-Partition\n   */\n  let producerSequence = {}\n\n  /**\n   * Idempotent production requires a mutex lock per broker to serialize requests with sequence number handling\n   */\n  let brokerMutexLocks = {}\n\n  /**\n   * Topic partitions already participating in the transaction\n   */\n  let transactionTopicPartitions = {}\n\n  /**\n   * Offsets have been added to the transaction\n   */\n  let hasOffsetsAddedToTransaction = false\n\n  const stateMachine = createStateMachine({ logger })\n  stateMachine.on('transition', ({ to }) => {\n    if (to === STATES.READY) {\n      transactionTopicPartitions = {}\n      hasOffsetsAddedToTransaction = false\n    }\n  })\n\n  const findTransactionCoordinator = () => {\n    return cluster.findGroupCoordinator({\n      groupId: transactionalId,\n      coordinatorType: COORDINATOR_TYPES.TRANSACTION,\n    })\n  }\n\n  const transactionalGuard = () => {\n    if (!transactional) {\n      throw new KafkaJSNonRetriableError('Method unavailable if non-transactional')\n    }\n  }\n\n  /**\n   * A transaction is ongoing when offsets or partitions added to it\n   *\n   * @returns {boolean}\n   */\n  const isOngoing = () => {\n    return (\n      hasOffsetsAddedToTransaction ||\n      Object.entries(transactionTopicPartitions).some(([, partitions]) => {\n        return Object.entries(partitions).some(\n          ([, isPartitionAddedToTransaction]) => isPartitionAddedToTransaction\n        )\n      })\n    )\n  }\n\n  const eosManager = stateMachine.createGuarded(\n    {\n      /**\n       * Get the current producer id\n       * @returns {number}\n       */\n      getProducerId() {\n        return producerId\n      },\n\n      /**\n       * Get the current producer epoch\n       * @returns {number}\n       */\n      getProducerEpoch() {\n        return producerEpoch\n      },\n\n      getTransactionalId() {\n        return transactionalId\n      },\n\n      /**\n       * Initialize the idempotent producer by making an `InitProducerId` request.\n       * Overwrites any existing state in this transaction manager\n       */\n      async initProducerId() {\n        return retrier(async (bail, retryCount, retryTime) => {\n          try {\n            await cluster.refreshMetadataIfNecessary()\n\n            // If non-transactional we can request the PID from any broker\n            const broker = await (transactional\n              ? findTransactionCoordinator()\n              : cluster.findControllerBroker())\n\n            const result = await broker.initProducerId({\n              transactionalId: transactional ? transactionalId : undefined,\n              transactionTimeout,\n            })\n\n            stateMachine.transitionTo(STATES.READY)\n            producerId = result.producerId\n            producerEpoch = result.producerEpoch\n            producerSequence = {}\n            brokerMutexLocks = {}\n\n            logger.debug('Initialized producer id & epoch', { producerId, producerEpoch })\n          } catch (e) {\n            if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n              if (e.type === 'CONCURRENT_TRANSACTIONS') {\n                logger.debug('There is an ongoing transaction on this transactionId, retrying', {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime,\n                })\n              }\n\n              throw e\n            }\n\n            bail(e)\n          }\n        })\n      },\n\n      /**\n       * Get the current sequence for a given Topic-Partition. Defaults to 0.\n       *\n       * @param {string} topic\n       * @param {string} partition\n       * @returns {number}\n       */\n      getSequence(topic, partition) {\n        if (!eosManager.isInitialized()) {\n          return SEQUENCE_START\n        }\n\n        producerSequence[topic] = producerSequence[topic] || {}\n        producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START\n\n        return producerSequence[topic][partition]\n      },\n\n      /**\n       * Update the sequence for a given Topic-Partition.\n       *\n       * Do nothing if not yet initialized (not idempotent)\n       * @param {string} topic\n       * @param {string} partition\n       * @param {number} increment\n       */\n      updateSequence(topic, partition, increment) {\n        if (!eosManager.isInitialized()) {\n          return\n        }\n\n        const previous = eosManager.getSequence(topic, partition)\n        let sequence = previous + increment\n\n        // Sequence is defined as Int32 in the Record Batch,\n        // so theoretically should need to rotate here\n        if (sequence >= INT_32_MAX_VALUE) {\n          logger.debug(\n            `Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`\n          )\n          sequence = 0\n        }\n\n        producerSequence[topic][partition] = sequence\n      },\n\n      /**\n       * Begin a transaction\n       */\n      beginTransaction() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.TRANSACTING)\n      },\n\n      /**\n       * Add partitions to a transaction if they are not already marked as participating.\n       *\n       * Should be called prior to sending any messages during a transaction\n       * @param {TopicData[]} topicData\n       *\n       * @typedef {Object} TopicData\n       * @property {string} topic\n       * @property {object[]} partitions\n       * @property {number} partitions[].partition\n       */\n      async addPartitionsToTransaction(topicData) {\n        transactionalGuard()\n        const newTopicPartitions = {}\n\n        topicData.forEach(({ topic, partitions }) => {\n          transactionTopicPartitions[topic] = transactionTopicPartitions[topic] || {}\n\n          partitions.forEach(({ partition }) => {\n            if (!transactionTopicPartitions[topic][partition]) {\n              newTopicPartitions[topic] = newTopicPartitions[topic] || []\n              newTopicPartitions[topic].push(partition)\n            }\n          })\n        })\n\n        const topics = Object.keys(newTopicPartitions).map(topic => ({\n          topic,\n          partitions: newTopicPartitions[topic],\n        }))\n\n        if (topics.length) {\n          const broker = await findTransactionCoordinator()\n          await broker.addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics })\n        }\n\n        topics.forEach(({ topic, partitions }) => {\n          partitions.forEach(partition => {\n            transactionTopicPartitions[topic][partition] = true\n          })\n        })\n      },\n\n      /**\n       * Commit the ongoing transaction\n       */\n      async commit() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.COMMITTING)\n\n        if (!isOngoing()) {\n          logger.debug('No partitions or offsets registered, not sending EndTxn')\n\n          stateMachine.transitionTo(STATES.READY)\n          return\n        }\n\n        const broker = await findTransactionCoordinator()\n        await broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: true,\n        })\n\n        stateMachine.transitionTo(STATES.READY)\n      },\n\n      /**\n       * Abort the ongoing transaction\n       */\n      async abort() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.ABORTING)\n\n        if (!isOngoing()) {\n          logger.debug('No partitions or offsets registered, not sending EndTxn')\n\n          stateMachine.transitionTo(STATES.READY)\n          return\n        }\n\n        const broker = await findTransactionCoordinator()\n        await broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: false,\n        })\n\n        stateMachine.transitionTo(STATES.READY)\n      },\n\n      /**\n       * Whether the producer id has already been initialized\n       */\n      isInitialized() {\n        return producerId !== NO_PRODUCER_ID\n      },\n\n      isTransactional() {\n        return transactional\n      },\n\n      isInTransaction() {\n        return stateMachine.state() === STATES.TRANSACTING\n      },\n\n      async acquireBrokerLock(broker) {\n        if (this.isInitialized()) {\n          brokerMutexLocks[broker.nodeId] =\n            brokerMutexLocks[broker.nodeId] || new Lock({ timeout: 0xffff })\n          await brokerMutexLocks[broker.nodeId].acquire()\n        }\n      },\n\n      releaseBrokerLock(broker) {\n        if (this.isInitialized()) brokerMutexLocks[broker.nodeId].release()\n      },\n\n      /**\n       * Mark the provided offsets as participating in the transaction for the given consumer group.\n       *\n       * This allows us to commit an offset as consumed only if the transaction passes.\n       * @param {string} consumerGroupId The unique group identifier\n       * @param {OffsetCommitTopic[]} topics The unique group identifier\n       * @returns {Promise}\n       *\n       * @typedef {Object} OffsetCommitTopic\n       * @property {string} topic\n       * @property {OffsetCommitTopicPartition[]} partitions\n       *\n       * @typedef {Object} OffsetCommitTopicPartition\n       * @property {number} partition\n       * @property {number} offset\n       */\n      async sendOffsets({ consumerGroupId, topics }) {\n        assert(consumerGroupId, 'Missing consumerGroupId')\n        assert(topics, 'Missing offset topics')\n\n        const transactionCoordinator = await findTransactionCoordinator()\n\n        // Do we need to add offsets if we've already done so for this consumer group?\n        await transactionCoordinator.addOffsetsToTxn({\n          transactionalId,\n          producerId,\n          producerEpoch,\n          groupId: consumerGroupId,\n        })\n\n        hasOffsetsAddedToTransaction = true\n\n        let groupCoordinator = await cluster.findGroupCoordinator({\n          groupId: consumerGroupId,\n          coordinatorType: COORDINATOR_TYPES.GROUP,\n        })\n\n        return retrier(async (bail, retryCount, retryTime) => {\n          try {\n            await groupCoordinator.txnOffsetCommit({\n              transactionalId,\n              producerId,\n              producerEpoch,\n              groupId: consumerGroupId,\n              topics,\n            })\n          } catch (e) {\n            if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n              logger.debug('Group coordinator is not ready yet, retrying', {\n                error: e.message,\n                stack: e.stack,\n                transactionalId,\n                retryCount,\n                retryTime,\n              })\n\n              throw e\n            }\n\n            if (\n              COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e.type) ||\n              e.code === 'ECONNREFUSED'\n            ) {\n              logger.debug(\n                'Invalid group coordinator, finding new group coordinator and retrying',\n                {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime,\n                }\n              )\n\n              groupCoordinator = await cluster.findGroupCoordinator({\n                groupId: consumerGroupId,\n                coordinatorType: COORDINATOR_TYPES.GROUP,\n              })\n\n              throw e\n            }\n\n            bail(e)\n          }\n        })\n      },\n    },\n\n    /**\n     * Transaction state guards\n     */\n    {\n      initProducerId: { legalStates: [STATES.UNINITIALIZED, STATES.READY] },\n      beginTransaction: { legalStates: [STATES.READY], async: false },\n      addPartitionsToTransaction: { legalStates: [STATES.TRANSACTING] },\n      sendOffsets: { legalStates: [STATES.TRANSACTING] },\n      commit: { legalStates: [STATES.TRANSACTING] },\n      abort: { legalStates: [STATES.TRANSACTING] },\n    }\n  )\n\n  return eosManager\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}