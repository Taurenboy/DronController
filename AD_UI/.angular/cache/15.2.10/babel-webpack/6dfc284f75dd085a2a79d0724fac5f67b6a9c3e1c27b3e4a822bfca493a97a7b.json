{"ast":null,"code":"const randomBytes = require('./randomBytes');\n\n// Based on the java client 0.10.2\n// https://github.com/apache/kafka/blob/0.10.2/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java\n\n/**\n * A cheap way to deterministically convert a number to a positive value. When the input is\n * positive, the original value is returned. When the input number is negative, the returned\n * positive value is the original value bit AND against 0x7fffffff which is not its absolutely\n * value.\n */\nconst toPositive = x => x & 0x7fffffff;\n\n/**\n * The default partitioning strategy:\n *  - If a partition is specified in the message, use it\n *  - If no partition is specified but a key is present choose a partition based on a hash of the key\n *  - If no partition or key is present choose a partition in a round-robin fashion\n */\nmodule.exports = murmur2 => () => {\n  const counters = {};\n  return ({\n    topic,\n    partitionMetadata,\n    message\n  }) => {\n    if (!(topic in counters)) {\n      counters[topic] = randomBytes(32).readUInt32BE(0);\n    }\n    const numPartitions = partitionMetadata.length;\n    const availablePartitions = partitionMetadata.filter(p => p.leader >= 0);\n    const numAvailablePartitions = availablePartitions.length;\n    if (message.partition !== null && message.partition !== undefined) {\n      return message.partition;\n    }\n    if (message.key !== null && message.key !== undefined) {\n      return toPositive(murmur2(message.key)) % numPartitions;\n    }\n    if (numAvailablePartitions > 0) {\n      const i = toPositive(++counters[topic]) % numAvailablePartitions;\n      return availablePartitions[i].partitionId;\n    }\n\n    // no partitions are available, give a non-available partition\n    return toPositive(++counters[topic]) % numPartitions;\n  };\n};","map":{"version":3,"names":["randomBytes","require","toPositive","x","module","exports","murmur2","counters","topic","partitionMetadata","message","readUInt32BE","numPartitions","length","availablePartitions","filter","p","leader","numAvailablePartitions","partition","undefined","key","i","partitionId"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/producer/partitioners/legacy/partitioner.js"],"sourcesContent":["const randomBytes = require('./randomBytes')\n\n// Based on the java client 0.10.2\n// https://github.com/apache/kafka/blob/0.10.2/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java\n\n/**\n * A cheap way to deterministically convert a number to a positive value. When the input is\n * positive, the original value is returned. When the input number is negative, the returned\n * positive value is the original value bit AND against 0x7fffffff which is not its absolutely\n * value.\n */\nconst toPositive = x => x & 0x7fffffff\n\n/**\n * The default partitioning strategy:\n *  - If a partition is specified in the message, use it\n *  - If no partition is specified but a key is present choose a partition based on a hash of the key\n *  - If no partition or key is present choose a partition in a round-robin fashion\n */\nmodule.exports = murmur2 => () => {\n  const counters = {}\n\n  return ({ topic, partitionMetadata, message }) => {\n    if (!(topic in counters)) {\n      counters[topic] = randomBytes(32).readUInt32BE(0)\n    }\n    const numPartitions = partitionMetadata.length\n    const availablePartitions = partitionMetadata.filter(p => p.leader >= 0)\n    const numAvailablePartitions = availablePartitions.length\n\n    if (message.partition !== null && message.partition !== undefined) {\n      return message.partition\n    }\n\n    if (message.key !== null && message.key !== undefined) {\n      return toPositive(murmur2(message.key)) % numPartitions\n    }\n\n    if (numAvailablePartitions > 0) {\n      const i = toPositive(++counters[topic]) % numAvailablePartitions\n      return availablePartitions[i].partitionId\n    }\n\n    // no partitions are available, give a non-available partition\n    return toPositive(++counters[topic]) % numPartitions\n  }\n}\n"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAGC,CAAC,IAAIA,CAAC,GAAG,UAAU;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGC,OAAO,IAAI,MAAM;EAChC,MAAMC,QAAQ,GAAG,CAAC,CAAC;EAEnB,OAAO,CAAC;IAAEC,KAAK;IAAEC,iBAAiB;IAAEC;EAAQ,CAAC,KAAK;IAChD,IAAI,EAAEF,KAAK,IAAID,QAAQ,CAAC,EAAE;MACxBA,QAAQ,CAACC,KAAK,CAAC,GAAGR,WAAW,CAAC,EAAE,CAAC,CAACW,YAAY,CAAC,CAAC,CAAC;IACnD;IACA,MAAMC,aAAa,GAAGH,iBAAiB,CAACI,MAAM;IAC9C,MAAMC,mBAAmB,GAAGL,iBAAiB,CAACM,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,IAAI,CAAC,CAAC;IACxE,MAAMC,sBAAsB,GAAGJ,mBAAmB,CAACD,MAAM;IAEzD,IAAIH,OAAO,CAACS,SAAS,KAAK,IAAI,IAAIT,OAAO,CAACS,SAAS,KAAKC,SAAS,EAAE;MACjE,OAAOV,OAAO,CAACS,SAAS;IAC1B;IAEA,IAAIT,OAAO,CAACW,GAAG,KAAK,IAAI,IAAIX,OAAO,CAACW,GAAG,KAAKD,SAAS,EAAE;MACrD,OAAOlB,UAAU,CAACI,OAAO,CAACI,OAAO,CAACW,GAAG,CAAC,CAAC,GAAGT,aAAa;IACzD;IAEA,IAAIM,sBAAsB,GAAG,CAAC,EAAE;MAC9B,MAAMI,CAAC,GAAGpB,UAAU,CAAC,EAAEK,QAAQ,CAACC,KAAK,CAAC,CAAC,GAAGU,sBAAsB;MAChE,OAAOJ,mBAAmB,CAACQ,CAAC,CAAC,CAACC,WAAW;IAC3C;;IAEA;IACA,OAAOrB,UAAU,CAAC,EAAEK,QAAQ,CAACC,KAAK,CAAC,CAAC,GAAGI,aAAa;EACtD,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}