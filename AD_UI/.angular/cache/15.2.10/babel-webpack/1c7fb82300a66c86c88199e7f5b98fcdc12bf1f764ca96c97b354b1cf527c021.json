{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Long = require('../../utils/long');\nconst isInvalidOffset = require('./isInvalidOffset');\nconst initializeConsumerOffsets = require('./initializeConsumerOffsets');\nconst {\n  events: {\n    COMMIT_OFFSETS\n  }\n} = require('../instrumentationEvents');\nconst {\n  keys,\n  assign\n} = Object;\nconst indexTopics = topics => topics.reduce((obj, topic) => assign(obj, {\n  [topic]: {}\n}), {});\nconst PRIVATE = {\n  COMMITTED_OFFSETS: Symbol('private:OffsetManager:committedOffsets')\n};\nmodule.exports = class OffsetManager {\n  /**\n   * @param {Object} options\n   * @param {import(\"../../../types\").Cluster} options.cluster\n   * @param {import(\"../../../types\").Broker} options.coordinator\n   * @param {import(\"../../../types\").IMemberAssignment} options.memberAssignment\n   * @param {boolean} options.autoCommit\n   * @param {number | null} options.autoCommitInterval\n   * @param {number | null} options.autoCommitThreshold\n   * @param {{[topic: string]: { fromBeginning: boolean }}} options.topicConfigurations\n   * @param {import(\"../../instrumentation/emitter\")} options.instrumentationEmitter\n   * @param {string} options.groupId\n   * @param {number} options.generationId\n   * @param {string} options.memberId\n   */\n  constructor({\n    cluster,\n    coordinator,\n    memberAssignment,\n    autoCommit,\n    autoCommitInterval,\n    autoCommitThreshold,\n    topicConfigurations,\n    instrumentationEmitter,\n    groupId,\n    generationId,\n    memberId\n  }) {\n    this.cluster = cluster;\n    this.coordinator = coordinator;\n\n    // memberAssignment format:\n    // {\n    //   'topic1': [0, 1, 2, 3],\n    //   'topic2': [0, 1, 2, 3, 4, 5],\n    // }\n    this.memberAssignment = memberAssignment;\n    this.topicConfigurations = topicConfigurations;\n    this.instrumentationEmitter = instrumentationEmitter;\n    this.groupId = groupId;\n    this.generationId = generationId;\n    this.memberId = memberId;\n    this.autoCommit = autoCommit;\n    this.autoCommitInterval = autoCommitInterval;\n    this.autoCommitThreshold = autoCommitThreshold;\n    this.lastCommit = Date.now();\n    this.topics = keys(memberAssignment);\n    this.clearAllOffsets();\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @returns {Long}\n   */\n  nextOffset(topic, partition) {\n    if (!this.resolvedOffsets[topic][partition]) {\n      this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];\n    }\n    let offset = this.resolvedOffsets[topic][partition];\n    if (isInvalidOffset(offset)) {\n      offset = '0';\n    }\n    return Long.fromValue(offset);\n  }\n\n  /**\n   * @returns {Promise<import(\"../../../types\").Broker>}\n   */\n  getCoordinator() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.coordinator.isConnected()) {\n        _this.coordinator = yield _this.cluster.findBroker(_this.coordinator);\n      }\n      return _this.coordinator;\n    })();\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  resetOffset({\n    topic,\n    partition\n  }) {\n    this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartitionOffset} topicPartitionOffset\n   */\n  resolveOffset({\n    topic,\n    partition,\n    offset\n  }) {\n    this.resolvedOffsets[topic][partition] = Long.fromValue(offset).add(1).toString();\n  }\n\n  /**\n   * @returns {Long}\n   */\n  countResolvedOffsets() {\n    const committedOffsets = this.committedOffsets();\n    const subtractOffsets = (resolvedOffset, committedOffset) => {\n      const resolvedOffsetLong = Long.fromValue(resolvedOffset);\n      return isInvalidOffset(committedOffset) ? resolvedOffsetLong : resolvedOffsetLong.subtract(Long.fromValue(committedOffset));\n    };\n    const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) => keys(resolvedTopicOffsets).map(partition => subtractOffsets(resolvedTopicOffsets[partition], committedTopicOffsets[partition]));\n    const subtractTopicOffsets = topic => subtractPartitionOffsets(this.resolvedOffsets[topic], committedOffsets[topic]);\n    const offsetsDiff = this.topics.flatMap(subtractTopicOffsets);\n    return offsetsDiff.reduce((sum, offset) => sum.add(offset), Long.fromValue(0));\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  setDefaultOffset({\n    topic,\n    partition\n  }) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        groupId,\n        generationId,\n        memberId\n      } = _this2;\n      const defaultOffset = _this2.cluster.defaultOffset(_this2.topicConfigurations[topic]);\n      const coordinator = yield _this2.getCoordinator();\n      yield coordinator.offsetCommit({\n        groupId,\n        memberId,\n        groupGenerationId: generationId,\n        topics: [{\n          topic,\n          partitions: [{\n            partition,\n            offset: defaultOffset\n          }]\n        }]\n      });\n      _this2.clearOffsets({\n        topic,\n        partition\n      });\n    })();\n  }\n\n  /**\n   * Commit the given offset to the topic/partition. If the consumer isn't assigned to the given\n   * topic/partition this method will be a NO-OP.\n   *\n   * @param {import(\"../../../types\").TopicPartitionOffset} topicPartitionOffset\n   */\n  seek({\n    topic,\n    partition,\n    offset\n  }) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.memberAssignment[topic] || !_this3.memberAssignment[topic].includes(partition)) {\n        return;\n      }\n      if (!_this3.autoCommit) {\n        _this3.resolveOffset({\n          topic,\n          partition,\n          offset: Long.fromValue(offset).subtract(1).toString()\n        });\n        return;\n      }\n      const {\n        groupId,\n        generationId,\n        memberId\n      } = _this3;\n      const coordinator = yield _this3.getCoordinator();\n      yield coordinator.offsetCommit({\n        groupId,\n        memberId,\n        groupGenerationId: generationId,\n        topics: [{\n          topic,\n          partitions: [{\n            partition,\n            offset\n          }]\n        }]\n      });\n      _this3.clearOffsets({\n        topic,\n        partition\n      });\n    })();\n  }\n  commitOffsetsIfNecessary() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const now = Date.now();\n      const timeoutReached = _this4.autoCommitInterval != null && now >= _this4.lastCommit + _this4.autoCommitInterval;\n      const thresholdReached = _this4.autoCommitThreshold != null && _this4.countResolvedOffsets().gte(Long.fromValue(_this4.autoCommitThreshold));\n      if (timeoutReached || thresholdReached) {\n        return _this4.commitOffsets();\n      }\n    })();\n  }\n\n  /**\n   * Return all locally resolved offsets which are not marked as committed, by topic-partition.\n   * @returns {import('../../../types').OffsetsByTopicPartition}\n   */\n  uncommittedOffsets() {\n    const offsets = topic => keys(this.resolvedOffsets[topic]);\n    const emptyPartitions = ({\n      partitions\n    }) => partitions.length > 0;\n    const toPartitions = topic => partition => ({\n      partition,\n      offset: this.resolvedOffsets[topic][partition]\n    });\n    const changedOffsets = topic => ({\n      partition,\n      offset\n    }) => {\n      return offset !== this.committedOffsets()[topic][partition] && Long.fromValue(offset).greaterThanOrEqual(0);\n    };\n\n    // Select and format updated partitions\n    const topicsWithPartitionsToCommit = this.topics.map(topic => ({\n      topic,\n      partitions: offsets(topic).map(toPartitions(topic)).filter(changedOffsets(topic))\n    })).filter(emptyPartitions);\n    return {\n      topics: topicsWithPartitionsToCommit\n    };\n  }\n  commitOffsets(offsets = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        groupId,\n        generationId,\n        memberId\n      } = _this5;\n      const {\n        topics = _this5.uncommittedOffsets().topics\n      } = offsets;\n      if (topics.length === 0) {\n        _this5.lastCommit = Date.now();\n        return;\n      }\n      const payload = {\n        groupId,\n        memberId,\n        groupGenerationId: generationId,\n        topics\n      };\n      try {\n        const coordinator = yield _this5.getCoordinator();\n        yield coordinator.offsetCommit(payload);\n        _this5.instrumentationEmitter.emit(COMMIT_OFFSETS, payload);\n\n        // Update local reference of committed offsets\n        topics.forEach(({\n          topic,\n          partitions\n        }) => {\n          const updatedOffsets = partitions.reduce((obj, {\n            partition,\n            offset\n          }) => assign(obj, {\n            [partition]: offset\n          }), {});\n          _this5[PRIVATE.COMMITTED_OFFSETS][topic] = assign({}, _this5.committedOffsets()[topic], updatedOffsets);\n        });\n        _this5.lastCommit = Date.now();\n      } catch (e) {\n        // metadata is stale, the coordinator has changed due to a restart or\n        // broker reassignment\n        if (e.type === 'NOT_COORDINATOR_FOR_GROUP') {\n          yield _this5.cluster.refreshMetadata();\n        }\n        throw e;\n      }\n    })();\n  }\n  resolveOffsets() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        groupId\n      } = _this6;\n      const invalidOffset = topic => partition => {\n        return isInvalidOffset(_this6.committedOffsets()[topic][partition]);\n      };\n      const pendingPartitions = _this6.topics.map(topic => ({\n        topic,\n        partitions: _this6.memberAssignment[topic].filter(invalidOffset(topic)).map(partition => ({\n          partition\n        }))\n      })).filter(t => t.partitions.length > 0);\n      if (pendingPartitions.length === 0) {\n        return;\n      }\n      const coordinator = yield _this6.getCoordinator();\n      const {\n        responses: consumerOffsets\n      } = yield coordinator.offsetFetch({\n        groupId,\n        topics: pendingPartitions\n      });\n      const unresolvedPartitions = consumerOffsets.map(({\n        topic,\n        partitions\n      }) => assign({\n        topic,\n        partitions: partitions.filter(({\n          offset\n        }) => isInvalidOffset(offset)).map(({\n          partition\n        }) => assign({\n          partition\n        }))\n      }, _this6.topicConfigurations[topic]));\n      const indexPartitions = (obj, {\n        partition,\n        offset\n      }) => {\n        return assign(obj, {\n          [partition]: offset\n        });\n      };\n      const hasUnresolvedPartitions = () => unresolvedPartitions.some(t => t.partitions.length > 0);\n      let offsets = consumerOffsets;\n      if (hasUnresolvedPartitions()) {\n        const topicOffsets = yield _this6.cluster.fetchTopicsOffset(unresolvedPartitions);\n        offsets = initializeConsumerOffsets(consumerOffsets, topicOffsets);\n      }\n      offsets.forEach(({\n        topic,\n        partitions\n      }) => {\n        _this6.committedOffsets()[topic] = partitions.reduce(indexPartitions, {\n          ..._this6.committedOffsets()[topic]\n        });\n      });\n    })();\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  clearOffsets({\n    topic,\n    partition\n  }) {\n    delete this.committedOffsets()[topic][partition];\n    delete this.resolvedOffsets[topic][partition];\n  }\n\n  /**\n   * @private\n   */\n  clearAllOffsets() {\n    const committedOffsets = this.committedOffsets();\n    for (const topic in committedOffsets) {\n      delete committedOffsets[topic];\n    }\n    for (const topic of this.topics) {\n      committedOffsets[topic] = {};\n    }\n    this.resolvedOffsets = indexTopics(this.topics);\n  }\n  committedOffsets() {\n    if (!this[PRIVATE.COMMITTED_OFFSETS]) {\n      this[PRIVATE.COMMITTED_OFFSETS] = this.groupId ? this.cluster.committedOffsets({\n        groupId: this.groupId\n      }) : {};\n    }\n    return this[PRIVATE.COMMITTED_OFFSETS];\n  }\n};","map":{"version":3,"names":["Long","require","isInvalidOffset","initializeConsumerOffsets","events","COMMIT_OFFSETS","keys","assign","Object","indexTopics","topics","reduce","obj","topic","PRIVATE","COMMITTED_OFFSETS","Symbol","module","exports","OffsetManager","constructor","cluster","coordinator","memberAssignment","autoCommit","autoCommitInterval","autoCommitThreshold","topicConfigurations","instrumentationEmitter","groupId","generationId","memberId","lastCommit","Date","now","clearAllOffsets","nextOffset","partition","resolvedOffsets","committedOffsets","offset","fromValue","getCoordinator","isConnected","findBroker","resetOffset","resolveOffset","add","toString","countResolvedOffsets","subtractOffsets","resolvedOffset","committedOffset","resolvedOffsetLong","subtract","subtractPartitionOffsets","resolvedTopicOffsets","committedTopicOffsets","map","subtractTopicOffsets","offsetsDiff","flatMap","sum","setDefaultOffset","defaultOffset","offsetCommit","groupGenerationId","partitions","clearOffsets","seek","includes","commitOffsetsIfNecessary","timeoutReached","thresholdReached","gte","commitOffsets","uncommittedOffsets","offsets","emptyPartitions","length","toPartitions","changedOffsets","greaterThanOrEqual","topicsWithPartitionsToCommit","filter","payload","emit","forEach","updatedOffsets","e","type","refreshMetadata","resolveOffsets","invalidOffset","pendingPartitions","t","responses","consumerOffsets","offsetFetch","unresolvedPartitions","indexPartitions","hasUnresolvedPartitions","some","topicOffsets","fetchTopicsOffset"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/offsetManager/index.js"],"sourcesContent":["const Long = require('../../utils/long')\nconst isInvalidOffset = require('./isInvalidOffset')\nconst initializeConsumerOffsets = require('./initializeConsumerOffsets')\nconst {\n  events: { COMMIT_OFFSETS },\n} = require('../instrumentationEvents')\n\nconst { keys, assign } = Object\nconst indexTopics = topics => topics.reduce((obj, topic) => assign(obj, { [topic]: {} }), {})\n\nconst PRIVATE = {\n  COMMITTED_OFFSETS: Symbol('private:OffsetManager:committedOffsets'),\n}\nmodule.exports = class OffsetManager {\n  /**\n   * @param {Object} options\n   * @param {import(\"../../../types\").Cluster} options.cluster\n   * @param {import(\"../../../types\").Broker} options.coordinator\n   * @param {import(\"../../../types\").IMemberAssignment} options.memberAssignment\n   * @param {boolean} options.autoCommit\n   * @param {number | null} options.autoCommitInterval\n   * @param {number | null} options.autoCommitThreshold\n   * @param {{[topic: string]: { fromBeginning: boolean }}} options.topicConfigurations\n   * @param {import(\"../../instrumentation/emitter\")} options.instrumentationEmitter\n   * @param {string} options.groupId\n   * @param {number} options.generationId\n   * @param {string} options.memberId\n   */\n  constructor({\n    cluster,\n    coordinator,\n    memberAssignment,\n    autoCommit,\n    autoCommitInterval,\n    autoCommitThreshold,\n    topicConfigurations,\n    instrumentationEmitter,\n    groupId,\n    generationId,\n    memberId,\n  }) {\n    this.cluster = cluster\n    this.coordinator = coordinator\n\n    // memberAssignment format:\n    // {\n    //   'topic1': [0, 1, 2, 3],\n    //   'topic2': [0, 1, 2, 3, 4, 5],\n    // }\n    this.memberAssignment = memberAssignment\n\n    this.topicConfigurations = topicConfigurations\n    this.instrumentationEmitter = instrumentationEmitter\n    this.groupId = groupId\n    this.generationId = generationId\n    this.memberId = memberId\n\n    this.autoCommit = autoCommit\n    this.autoCommitInterval = autoCommitInterval\n    this.autoCommitThreshold = autoCommitThreshold\n    this.lastCommit = Date.now()\n\n    this.topics = keys(memberAssignment)\n    this.clearAllOffsets()\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @returns {Long}\n   */\n  nextOffset(topic, partition) {\n    if (!this.resolvedOffsets[topic][partition]) {\n      this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition]\n    }\n\n    let offset = this.resolvedOffsets[topic][partition]\n    if (isInvalidOffset(offset)) {\n      offset = '0'\n    }\n\n    return Long.fromValue(offset)\n  }\n\n  /**\n   * @returns {Promise<import(\"../../../types\").Broker>}\n   */\n  async getCoordinator() {\n    if (!this.coordinator.isConnected()) {\n      this.coordinator = await this.cluster.findBroker(this.coordinator)\n    }\n\n    return this.coordinator\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  resetOffset({ topic, partition }) {\n    this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition]\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartitionOffset} topicPartitionOffset\n   */\n  resolveOffset({ topic, partition, offset }) {\n    this.resolvedOffsets[topic][partition] = Long.fromValue(offset)\n      .add(1)\n      .toString()\n  }\n\n  /**\n   * @returns {Long}\n   */\n  countResolvedOffsets() {\n    const committedOffsets = this.committedOffsets()\n\n    const subtractOffsets = (resolvedOffset, committedOffset) => {\n      const resolvedOffsetLong = Long.fromValue(resolvedOffset)\n      return isInvalidOffset(committedOffset)\n        ? resolvedOffsetLong\n        : resolvedOffsetLong.subtract(Long.fromValue(committedOffset))\n    }\n\n    const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) =>\n      keys(resolvedTopicOffsets).map(partition =>\n        subtractOffsets(resolvedTopicOffsets[partition], committedTopicOffsets[partition])\n      )\n\n    const subtractTopicOffsets = topic =>\n      subtractPartitionOffsets(this.resolvedOffsets[topic], committedOffsets[topic])\n\n    const offsetsDiff = this.topics.flatMap(subtractTopicOffsets)\n    return offsetsDiff.reduce((sum, offset) => sum.add(offset), Long.fromValue(0))\n  }\n\n  /**\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  async setDefaultOffset({ topic, partition }) {\n    const { groupId, generationId, memberId } = this\n    const defaultOffset = this.cluster.defaultOffset(this.topicConfigurations[topic])\n    const coordinator = await this.getCoordinator()\n\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [\n        {\n          topic,\n          partitions: [{ partition, offset: defaultOffset }],\n        },\n      ],\n    })\n\n    this.clearOffsets({ topic, partition })\n  }\n\n  /**\n   * Commit the given offset to the topic/partition. If the consumer isn't assigned to the given\n   * topic/partition this method will be a NO-OP.\n   *\n   * @param {import(\"../../../types\").TopicPartitionOffset} topicPartitionOffset\n   */\n  async seek({ topic, partition, offset }) {\n    if (!this.memberAssignment[topic] || !this.memberAssignment[topic].includes(partition)) {\n      return\n    }\n\n    if (!this.autoCommit) {\n      this.resolveOffset({\n        topic,\n        partition,\n        offset: Long.fromValue(offset)\n          .subtract(1)\n          .toString(),\n      })\n      return\n    }\n\n    const { groupId, generationId, memberId } = this\n    const coordinator = await this.getCoordinator()\n\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [\n        {\n          topic,\n          partitions: [{ partition, offset }],\n        },\n      ],\n    })\n\n    this.clearOffsets({ topic, partition })\n  }\n\n  async commitOffsetsIfNecessary() {\n    const now = Date.now()\n\n    const timeoutReached =\n      this.autoCommitInterval != null && now >= this.lastCommit + this.autoCommitInterval\n\n    const thresholdReached =\n      this.autoCommitThreshold != null &&\n      this.countResolvedOffsets().gte(Long.fromValue(this.autoCommitThreshold))\n\n    if (timeoutReached || thresholdReached) {\n      return this.commitOffsets()\n    }\n  }\n\n  /**\n   * Return all locally resolved offsets which are not marked as committed, by topic-partition.\n   * @returns {import('../../../types').OffsetsByTopicPartition}\n   */\n  uncommittedOffsets() {\n    const offsets = topic => keys(this.resolvedOffsets[topic])\n    const emptyPartitions = ({ partitions }) => partitions.length > 0\n    const toPartitions = topic => partition => ({\n      partition,\n      offset: this.resolvedOffsets[topic][partition],\n    })\n    const changedOffsets = topic => ({ partition, offset }) => {\n      return (\n        offset !== this.committedOffsets()[topic][partition] &&\n        Long.fromValue(offset).greaterThanOrEqual(0)\n      )\n    }\n\n    // Select and format updated partitions\n    const topicsWithPartitionsToCommit = this.topics\n      .map(topic => ({\n        topic,\n        partitions: offsets(topic)\n          .map(toPartitions(topic))\n          .filter(changedOffsets(topic)),\n      }))\n      .filter(emptyPartitions)\n\n    return { topics: topicsWithPartitionsToCommit }\n  }\n\n  async commitOffsets(offsets = {}) {\n    const { groupId, generationId, memberId } = this\n    const { topics = this.uncommittedOffsets().topics } = offsets\n\n    if (topics.length === 0) {\n      this.lastCommit = Date.now()\n      return\n    }\n\n    const payload = {\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics,\n    }\n\n    try {\n      const coordinator = await this.getCoordinator()\n      await coordinator.offsetCommit(payload)\n      this.instrumentationEmitter.emit(COMMIT_OFFSETS, payload)\n\n      // Update local reference of committed offsets\n      topics.forEach(({ topic, partitions }) => {\n        const updatedOffsets = partitions.reduce(\n          (obj, { partition, offset }) => assign(obj, { [partition]: offset }),\n          {}\n        )\n\n        this[PRIVATE.COMMITTED_OFFSETS][topic] = assign(\n          {},\n          this.committedOffsets()[topic],\n          updatedOffsets\n        )\n      })\n\n      this.lastCommit = Date.now()\n    } catch (e) {\n      // metadata is stale, the coordinator has changed due to a restart or\n      // broker reassignment\n      if (e.type === 'NOT_COORDINATOR_FOR_GROUP') {\n        await this.cluster.refreshMetadata()\n      }\n\n      throw e\n    }\n  }\n\n  async resolveOffsets() {\n    const { groupId } = this\n    const invalidOffset = topic => partition => {\n      return isInvalidOffset(this.committedOffsets()[topic][partition])\n    }\n\n    const pendingPartitions = this.topics\n      .map(topic => ({\n        topic,\n        partitions: this.memberAssignment[topic]\n          .filter(invalidOffset(topic))\n          .map(partition => ({ partition })),\n      }))\n      .filter(t => t.partitions.length > 0)\n\n    if (pendingPartitions.length === 0) {\n      return\n    }\n\n    const coordinator = await this.getCoordinator()\n    const { responses: consumerOffsets } = await coordinator.offsetFetch({\n      groupId,\n      topics: pendingPartitions,\n    })\n\n    const unresolvedPartitions = consumerOffsets.map(({ topic, partitions }) =>\n      assign(\n        {\n          topic,\n          partitions: partitions\n            .filter(({ offset }) => isInvalidOffset(offset))\n            .map(({ partition }) => assign({ partition })),\n        },\n        this.topicConfigurations[topic]\n      )\n    )\n\n    const indexPartitions = (obj, { partition, offset }) => {\n      return assign(obj, { [partition]: offset })\n    }\n\n    const hasUnresolvedPartitions = () => unresolvedPartitions.some(t => t.partitions.length > 0)\n\n    let offsets = consumerOffsets\n    if (hasUnresolvedPartitions()) {\n      const topicOffsets = await this.cluster.fetchTopicsOffset(unresolvedPartitions)\n      offsets = initializeConsumerOffsets(consumerOffsets, topicOffsets)\n    }\n\n    offsets.forEach(({ topic, partitions }) => {\n      this.committedOffsets()[topic] = partitions.reduce(indexPartitions, {\n        ...this.committedOffsets()[topic],\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../../types\").TopicPartition} topicPartition\n   */\n  clearOffsets({ topic, partition }) {\n    delete this.committedOffsets()[topic][partition]\n    delete this.resolvedOffsets[topic][partition]\n  }\n\n  /**\n   * @private\n   */\n  clearAllOffsets() {\n    const committedOffsets = this.committedOffsets()\n\n    for (const topic in committedOffsets) {\n      delete committedOffsets[topic]\n    }\n\n    for (const topic of this.topics) {\n      committedOffsets[topic] = {}\n    }\n\n    this.resolvedOffsets = indexTopics(this.topics)\n  }\n\n  committedOffsets() {\n    if (!this[PRIVATE.COMMITTED_OFFSETS]) {\n      this[PRIVATE.COMMITTED_OFFSETS] = this.groupId\n        ? this.cluster.committedOffsets({ groupId: this.groupId })\n        : {}\n    }\n\n    return this[PRIVATE.COMMITTED_OFFSETS]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}