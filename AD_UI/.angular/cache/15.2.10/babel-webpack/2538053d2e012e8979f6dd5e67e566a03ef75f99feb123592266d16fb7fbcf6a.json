{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst crypto = require('crypto');\nconst scram = require('../../protocol/sasl/scram');\nconst {\n  KafkaJSSASLAuthenticationError,\n  KafkaJSNonRetriableError\n} = require('../../errors');\nconst GS2_HEADER = 'n,,';\nconst EQUAL_SIGN_REGEX = /=/g;\nconst COMMA_SIGN_REGEX = /,/g;\nconst URLSAFE_BASE64_PLUS_REGEX = /\\+/g;\nconst URLSAFE_BASE64_SLASH_REGEX = /\\//g;\nconst URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/;\nconst HMAC_CLIENT_KEY = 'Client Key';\nconst HMAC_SERVER_KEY = 'Server Key';\nconst DIGESTS = {\n  SHA256: {\n    length: 32,\n    type: 'sha256',\n    minIterations: 4096\n  },\n  SHA512: {\n    length: 64,\n    type: 'sha512',\n    minIterations: 4096\n  }\n};\nconst encode64 = str => Buffer.from(str).toString('base64');\nclass SCRAM {\n  /**\n   * From https://tools.ietf.org/html/rfc5802#section-5.1\n   *\n   * The characters ',' or '=' in usernames are sent as '=2C' and\n   * '=3D' respectively.  If the server receives a username that\n   * contains '=' not followed by either '2C' or '3D', then the\n   * server MUST fail the authentication.\n   *\n   * @returns {String}\n   */\n  static sanitizeString(str) {\n    return str.replace(EQUAL_SIGN_REGEX, '=3D').replace(COMMA_SIGN_REGEX, '=2C');\n  }\n\n  /**\n   * In cryptography, a nonce is an arbitrary number that can be used just once.\n   * It is similar in spirit to a nonce * word, hence the name. It is often a random or pseudo-random\n   * number issued in an authentication protocol to * ensure that old communications cannot be reused\n   * in replay attacks.\n   *\n   * @returns {String}\n   */\n  static nonce() {\n    return crypto.randomBytes(16).toString('base64').replace(URLSAFE_BASE64_PLUS_REGEX, '-') // make it url safe\n    .replace(URLSAFE_BASE64_SLASH_REGEX, '_').replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, '').toString('ascii');\n  }\n\n  /**\n   * Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n   * pseudorandom function (PRF) and with dkLen == output length of\n   * HMAC() == output length of H()\n   *\n   * @returns {Promise<Buffer>}\n   */\n  static hi(password, salt, iterations, digestDefinition) {\n    return new Promise((resolve, reject) => {\n      crypto.pbkdf2(password, salt, iterations, digestDefinition.length, digestDefinition.type, (err, derivedKey) => err ? reject(err) : resolve(derivedKey));\n    });\n  }\n\n  /**\n   * Apply the exclusive-or operation to combine the octet string\n   * on the left of this operator with the octet string on the right of\n   * this operator.  The length of the output and each of the two\n   * inputs will be the same for this use\n   *\n   * @returns {Buffer}\n   */\n  static xor(left, right) {\n    const bufferA = Buffer.from(left);\n    const bufferB = Buffer.from(right);\n    const length = Buffer.byteLength(bufferA);\n    if (length !== Buffer.byteLength(bufferB)) {\n      throw new KafkaJSNonRetriableError('Buffers must be of the same length');\n    }\n    const result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(bufferA[i] ^ bufferB[i]);\n    }\n    return Buffer.from(result);\n  }\n\n  /**\n   * @param {SASLOptions} sasl\n   * @param {Logger} logger\n   * @param {Function} saslAuthenticate\n   * @param {DigestDefinition} digestDefinition\n   */\n  constructor(sasl, host, port, logger, saslAuthenticate, digestDefinition) {\n    this.sasl = sasl;\n    this.host = host;\n    this.port = port;\n    this.logger = logger;\n    this.saslAuthenticate = saslAuthenticate;\n    this.digestDefinition = digestDefinition;\n    const digestType = digestDefinition.type.toUpperCase();\n    this.PREFIX = `SASL SCRAM ${digestType} authentication`;\n    this.currentNonce = SCRAM.nonce();\n  }\n  authenticate() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        PREFIX\n      } = _this;\n      const broker = `${_this.host}:${_this.port}`;\n      if (_this.sasl.username == null || _this.sasl.password == null) {\n        throw new KafkaJSSASLAuthenticationError(`${_this.PREFIX}: Invalid username or password`);\n      }\n      try {\n        _this.logger.debug('Exchanging first client message', {\n          broker\n        });\n        const clientMessageResponse = yield _this.sendClientFirstMessage();\n        _this.logger.debug('Sending final message', {\n          broker\n        });\n        const finalResponse = yield _this.sendClientFinalMessage(clientMessageResponse);\n        if (finalResponse.e) {\n          throw new Error(finalResponse.e);\n        }\n        const serverKey = yield _this.serverKey(clientMessageResponse);\n        const serverSignature = _this.serverSignature(serverKey, clientMessageResponse);\n        if (finalResponse.v !== serverSignature) {\n          throw new Error('Invalid server signature in server final message');\n        }\n        _this.logger.debug(`${PREFIX} successful`, {\n          broker\n        });\n      } catch (e) {\n        const error = new KafkaJSSASLAuthenticationError(`${PREFIX} failed: ${e.message}`);\n        _this.logger.error(error.message, {\n          broker\n        });\n        throw error;\n      }\n    })();\n  }\n\n  /**\n   * @private\n   */\n  sendClientFirstMessage() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const clientFirstMessage = `${GS2_HEADER}${_this2.firstMessageBare()}`;\n      const request = scram.firstMessage.request({\n        clientFirstMessage\n      });\n      const response = scram.firstMessage.response;\n      return _this2.saslAuthenticate({\n        request,\n        response\n      });\n    })();\n  }\n\n  /**\n   * @private\n   */\n  sendClientFinalMessage(clientMessageResponse) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        PREFIX\n      } = _this3;\n      const iterations = parseInt(clientMessageResponse.i, 10);\n      const {\n        minIterations\n      } = _this3.digestDefinition;\n      if (!clientMessageResponse.r.startsWith(_this3.currentNonce)) {\n        throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`);\n      }\n      if (iterations < minIterations) {\n        throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`);\n      }\n      const finalMessageWithoutProof = _this3.finalMessageWithoutProof(clientMessageResponse);\n      const clientProof = yield _this3.clientProof(clientMessageResponse);\n      const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`;\n      const request = scram.finalMessage.request({\n        finalMessage\n      });\n      const response = scram.finalMessage.response;\n      return _this3.saslAuthenticate({\n        request,\n        response\n      });\n    })();\n  }\n\n  /**\n   * @private\n   */\n  clientProof(clientMessageResponse) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const clientKey = yield _this4.clientKey(clientMessageResponse);\n      const storedKey = _this4.H(clientKey);\n      const clientSignature = _this4.clientSignature(storedKey, clientMessageResponse);\n      return encode64(SCRAM.xor(clientKey, clientSignature));\n    })();\n  }\n\n  /**\n   * @private\n   */\n  clientKey(clientMessageResponse) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const saltedPassword = yield _this5.saltPassword(clientMessageResponse);\n      return _this5.HMAC(saltedPassword, HMAC_CLIENT_KEY);\n    })();\n  }\n\n  /**\n   * @private\n   */\n  serverKey(clientMessageResponse) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const saltedPassword = yield _this6.saltPassword(clientMessageResponse);\n      return _this6.HMAC(saltedPassword, HMAC_SERVER_KEY);\n    })();\n  }\n\n  /**\n   * @private\n   */\n  clientSignature(storedKey, clientMessageResponse) {\n    return this.HMAC(storedKey, this.authMessage(clientMessageResponse));\n  }\n\n  /**\n   * @private\n   */\n  serverSignature(serverKey, clientMessageResponse) {\n    return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)));\n  }\n\n  /**\n   * @private\n   */\n  authMessage(clientMessageResponse) {\n    return [this.firstMessageBare(), clientMessageResponse.original, this.finalMessageWithoutProof(clientMessageResponse)].join(',');\n  }\n\n  /**\n   * @private\n   */\n  saltPassword(clientMessageResponse) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const salt = Buffer.from(clientMessageResponse.s, 'base64');\n      const iterations = parseInt(clientMessageResponse.i, 10);\n      return SCRAM.hi(_this7.encodedPassword(), salt, iterations, _this7.digestDefinition);\n    })();\n  }\n\n  /**\n   * @private\n   */\n  firstMessageBare() {\n    return `n=${this.encodedUsername()},r=${this.currentNonce}`;\n  }\n\n  /**\n   * @private\n   */\n  finalMessageWithoutProof(clientMessageResponse) {\n    const rnonce = clientMessageResponse.r;\n    return `c=${encode64(GS2_HEADER)},r=${rnonce}`;\n  }\n\n  /**\n   * @private\n   */\n  encodedUsername() {\n    const {\n      username\n    } = this.sasl;\n    return SCRAM.sanitizeString(username).toString('utf-8');\n  }\n\n  /**\n   * @private\n   */\n  encodedPassword() {\n    const {\n      password\n    } = this.sasl;\n    return password.toString('utf-8');\n  }\n\n  /**\n   * @private\n   */\n  H(data) {\n    return crypto.createHash(this.digestDefinition.type).update(data).digest();\n  }\n\n  /**\n   * @private\n   */\n  HMAC(key, data) {\n    return crypto.createHmac(this.digestDefinition.type, key).update(data).digest();\n  }\n}\nmodule.exports = {\n  DIGESTS,\n  SCRAM\n};","map":{"version":3,"names":["crypto","require","scram","KafkaJSSASLAuthenticationError","KafkaJSNonRetriableError","GS2_HEADER","EQUAL_SIGN_REGEX","COMMA_SIGN_REGEX","URLSAFE_BASE64_PLUS_REGEX","URLSAFE_BASE64_SLASH_REGEX","URLSAFE_BASE64_TRAILING_EQUAL_REGEX","HMAC_CLIENT_KEY","HMAC_SERVER_KEY","DIGESTS","SHA256","length","type","minIterations","SHA512","encode64","str","Buffer","from","toString","SCRAM","sanitizeString","replace","nonce","randomBytes","hi","password","salt","iterations","digestDefinition","Promise","resolve","reject","pbkdf2","err","derivedKey","xor","left","right","bufferA","bufferB","byteLength","result","i","push","constructor","sasl","host","port","logger","saslAuthenticate","digestType","toUpperCase","PREFIX","currentNonce","authenticate","broker","username","debug","clientMessageResponse","sendClientFirstMessage","finalResponse","sendClientFinalMessage","e","Error","serverKey","serverSignature","v","error","message","clientFirstMessage","firstMessageBare","request","firstMessage","response","parseInt","r","startsWith","finalMessageWithoutProof","clientProof","finalMessage","clientKey","storedKey","H","clientSignature","saltedPassword","saltPassword","HMAC","authMessage","original","join","s","encodedPassword","encodedUsername","rnonce","data","createHash","update","digest","key","createHmac","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/broker/saslAuthenticator/scram.js"],"sourcesContent":["const crypto = require('crypto')\nconst scram = require('../../protocol/sasl/scram')\nconst { KafkaJSSASLAuthenticationError, KafkaJSNonRetriableError } = require('../../errors')\n\nconst GS2_HEADER = 'n,,'\n\nconst EQUAL_SIGN_REGEX = /=/g\nconst COMMA_SIGN_REGEX = /,/g\n\nconst URLSAFE_BASE64_PLUS_REGEX = /\\+/g\nconst URLSAFE_BASE64_SLASH_REGEX = /\\//g\nconst URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/\n\nconst HMAC_CLIENT_KEY = 'Client Key'\nconst HMAC_SERVER_KEY = 'Server Key'\n\nconst DIGESTS = {\n  SHA256: {\n    length: 32,\n    type: 'sha256',\n    minIterations: 4096,\n  },\n  SHA512: {\n    length: 64,\n    type: 'sha512',\n    minIterations: 4096,\n  },\n}\n\nconst encode64 = str => Buffer.from(str).toString('base64')\n\nclass SCRAM {\n  /**\n   * From https://tools.ietf.org/html/rfc5802#section-5.1\n   *\n   * The characters ',' or '=' in usernames are sent as '=2C' and\n   * '=3D' respectively.  If the server receives a username that\n   * contains '=' not followed by either '2C' or '3D', then the\n   * server MUST fail the authentication.\n   *\n   * @returns {String}\n   */\n  static sanitizeString(str) {\n    return str.replace(EQUAL_SIGN_REGEX, '=3D').replace(COMMA_SIGN_REGEX, '=2C')\n  }\n\n  /**\n   * In cryptography, a nonce is an arbitrary number that can be used just once.\n   * It is similar in spirit to a nonce * word, hence the name. It is often a random or pseudo-random\n   * number issued in an authentication protocol to * ensure that old communications cannot be reused\n   * in replay attacks.\n   *\n   * @returns {String}\n   */\n  static nonce() {\n    return crypto\n      .randomBytes(16)\n      .toString('base64')\n      .replace(URLSAFE_BASE64_PLUS_REGEX, '-') // make it url safe\n      .replace(URLSAFE_BASE64_SLASH_REGEX, '_')\n      .replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, '')\n      .toString('ascii')\n  }\n\n  /**\n   * Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n   * pseudorandom function (PRF) and with dkLen == output length of\n   * HMAC() == output length of H()\n   *\n   * @returns {Promise<Buffer>}\n   */\n  static hi(password, salt, iterations, digestDefinition) {\n    return new Promise((resolve, reject) => {\n      crypto.pbkdf2(\n        password,\n        salt,\n        iterations,\n        digestDefinition.length,\n        digestDefinition.type,\n        (err, derivedKey) => (err ? reject(err) : resolve(derivedKey))\n      )\n    })\n  }\n\n  /**\n   * Apply the exclusive-or operation to combine the octet string\n   * on the left of this operator with the octet string on the right of\n   * this operator.  The length of the output and each of the two\n   * inputs will be the same for this use\n   *\n   * @returns {Buffer}\n   */\n  static xor(left, right) {\n    const bufferA = Buffer.from(left)\n    const bufferB = Buffer.from(right)\n    const length = Buffer.byteLength(bufferA)\n\n    if (length !== Buffer.byteLength(bufferB)) {\n      throw new KafkaJSNonRetriableError('Buffers must be of the same length')\n    }\n\n    const result = []\n    for (let i = 0; i < length; i++) {\n      result.push(bufferA[i] ^ bufferB[i])\n    }\n\n    return Buffer.from(result)\n  }\n\n  /**\n   * @param {SASLOptions} sasl\n   * @param {Logger} logger\n   * @param {Function} saslAuthenticate\n   * @param {DigestDefinition} digestDefinition\n   */\n  constructor(sasl, host, port, logger, saslAuthenticate, digestDefinition) {\n    this.sasl = sasl\n    this.host = host\n    this.port = port\n    this.logger = logger\n    this.saslAuthenticate = saslAuthenticate\n    this.digestDefinition = digestDefinition\n\n    const digestType = digestDefinition.type.toUpperCase()\n    this.PREFIX = `SASL SCRAM ${digestType} authentication`\n\n    this.currentNonce = SCRAM.nonce()\n  }\n\n  async authenticate() {\n    const { PREFIX } = this\n    const broker = `${this.host}:${this.port}`\n\n    if (this.sasl.username == null || this.sasl.password == null) {\n      throw new KafkaJSSASLAuthenticationError(`${this.PREFIX}: Invalid username or password`)\n    }\n\n    try {\n      this.logger.debug('Exchanging first client message', { broker })\n      const clientMessageResponse = await this.sendClientFirstMessage()\n\n      this.logger.debug('Sending final message', { broker })\n      const finalResponse = await this.sendClientFinalMessage(clientMessageResponse)\n\n      if (finalResponse.e) {\n        throw new Error(finalResponse.e)\n      }\n\n      const serverKey = await this.serverKey(clientMessageResponse)\n      const serverSignature = this.serverSignature(serverKey, clientMessageResponse)\n\n      if (finalResponse.v !== serverSignature) {\n        throw new Error('Invalid server signature in server final message')\n      }\n\n      this.logger.debug(`${PREFIX} successful`, { broker })\n    } catch (e) {\n      const error = new KafkaJSSASLAuthenticationError(`${PREFIX} failed: ${e.message}`)\n      this.logger.error(error.message, { broker })\n      throw error\n    }\n  }\n\n  /**\n   * @private\n   */\n  async sendClientFirstMessage() {\n    const clientFirstMessage = `${GS2_HEADER}${this.firstMessageBare()}`\n    const request = scram.firstMessage.request({ clientFirstMessage })\n    const response = scram.firstMessage.response\n\n    return this.saslAuthenticate({\n      request,\n      response,\n    })\n  }\n\n  /**\n   * @private\n   */\n  async sendClientFinalMessage(clientMessageResponse) {\n    const { PREFIX } = this\n    const iterations = parseInt(clientMessageResponse.i, 10)\n    const { minIterations } = this.digestDefinition\n\n    if (!clientMessageResponse.r.startsWith(this.currentNonce)) {\n      throw new KafkaJSSASLAuthenticationError(\n        `${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`\n      )\n    }\n\n    if (iterations < minIterations) {\n      throw new KafkaJSSASLAuthenticationError(\n        `${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`\n      )\n    }\n\n    const finalMessageWithoutProof = this.finalMessageWithoutProof(clientMessageResponse)\n    const clientProof = await this.clientProof(clientMessageResponse)\n    const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`\n    const request = scram.finalMessage.request({ finalMessage })\n    const response = scram.finalMessage.response\n\n    return this.saslAuthenticate({\n      request,\n      response,\n    })\n  }\n\n  /**\n   * @private\n   */\n  async clientProof(clientMessageResponse) {\n    const clientKey = await this.clientKey(clientMessageResponse)\n    const storedKey = this.H(clientKey)\n    const clientSignature = this.clientSignature(storedKey, clientMessageResponse)\n    return encode64(SCRAM.xor(clientKey, clientSignature))\n  }\n\n  /**\n   * @private\n   */\n  async clientKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse)\n    return this.HMAC(saltedPassword, HMAC_CLIENT_KEY)\n  }\n\n  /**\n   * @private\n   */\n  async serverKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse)\n    return this.HMAC(saltedPassword, HMAC_SERVER_KEY)\n  }\n\n  /**\n   * @private\n   */\n  clientSignature(storedKey, clientMessageResponse) {\n    return this.HMAC(storedKey, this.authMessage(clientMessageResponse))\n  }\n\n  /**\n   * @private\n   */\n  serverSignature(serverKey, clientMessageResponse) {\n    return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)))\n  }\n\n  /**\n   * @private\n   */\n  authMessage(clientMessageResponse) {\n    return [\n      this.firstMessageBare(),\n      clientMessageResponse.original,\n      this.finalMessageWithoutProof(clientMessageResponse),\n    ].join(',')\n  }\n\n  /**\n   * @private\n   */\n  async saltPassword(clientMessageResponse) {\n    const salt = Buffer.from(clientMessageResponse.s, 'base64')\n    const iterations = parseInt(clientMessageResponse.i, 10)\n    return SCRAM.hi(this.encodedPassword(), salt, iterations, this.digestDefinition)\n  }\n\n  /**\n   * @private\n   */\n  firstMessageBare() {\n    return `n=${this.encodedUsername()},r=${this.currentNonce}`\n  }\n\n  /**\n   * @private\n   */\n  finalMessageWithoutProof(clientMessageResponse) {\n    const rnonce = clientMessageResponse.r\n    return `c=${encode64(GS2_HEADER)},r=${rnonce}`\n  }\n\n  /**\n   * @private\n   */\n  encodedUsername() {\n    const { username } = this.sasl\n    return SCRAM.sanitizeString(username).toString('utf-8')\n  }\n\n  /**\n   * @private\n   */\n  encodedPassword() {\n    const { password } = this.sasl\n    return password.toString('utf-8')\n  }\n\n  /**\n   * @private\n   */\n  H(data) {\n    return crypto\n      .createHash(this.digestDefinition.type)\n      .update(data)\n      .digest()\n  }\n\n  /**\n   * @private\n   */\n  HMAC(key, data) {\n    return crypto\n      .createHmac(this.digestDefinition.type, key)\n      .update(data)\n      .digest()\n  }\n}\n\nmodule.exports = {\n  DIGESTS,\n  SCRAM,\n}\n"],"mappings":";AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,KAAK,GAAGD,OAAO,CAAC,2BAA2B,CAAC;AAClD,MAAM;EAAEE,8BAA8B;EAAEC;AAAyB,CAAC,GAAGH,OAAO,CAAC,cAAc,CAAC;AAE5F,MAAMI,UAAU,GAAG,KAAK;AAExB,MAAMC,gBAAgB,GAAG,IAAI;AAC7B,MAAMC,gBAAgB,GAAG,IAAI;AAE7B,MAAMC,yBAAyB,GAAG,KAAK;AACvC,MAAMC,0BAA0B,GAAG,KAAK;AACxC,MAAMC,mCAAmC,GAAG,KAAK;AAEjD,MAAMC,eAAe,GAAG,YAAY;AACpC,MAAMC,eAAe,GAAG,YAAY;AAEpC,MAAMC,OAAO,GAAG;EACdC,MAAM,EAAE;IACNC,MAAM,EAAE,EAAE;IACVC,IAAI,EAAE,QAAQ;IACdC,aAAa,EAAE;EACjB,CAAC;EACDC,MAAM,EAAE;IACNH,MAAM,EAAE,EAAE;IACVC,IAAI,EAAE,QAAQ;IACdC,aAAa,EAAE;EACjB;AACF,CAAC;AAED,MAAME,QAAQ,GAAGC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACG,QAAQ,CAAC,QAAQ,CAAC;AAE3D,MAAMC,KAAK,CAAC;EACV;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,cAAc,CAACL,GAAG,EAAE;IACzB,OAAOA,GAAG,CAACM,OAAO,CAACpB,gBAAgB,EAAE,KAAK,CAAC,CAACoB,OAAO,CAACnB,gBAAgB,EAAE,KAAK,CAAC;EAC9E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOoB,KAAK,GAAG;IACb,OAAO3B,MAAM,CACV4B,WAAW,CAAC,EAAE,CAAC,CACfL,QAAQ,CAAC,QAAQ,CAAC,CAClBG,OAAO,CAAClB,yBAAyB,EAAE,GAAG,CAAC,CAAC;IAAA,CACxCkB,OAAO,CAACjB,0BAA0B,EAAE,GAAG,CAAC,CACxCiB,OAAO,CAAChB,mCAAmC,EAAE,EAAE,CAAC,CAChDa,QAAQ,CAAC,OAAO,CAAC;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOM,EAAE,CAACC,QAAQ,EAAEC,IAAI,EAAEC,UAAU,EAAEC,gBAAgB,EAAE;IACtD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCpC,MAAM,CAACqC,MAAM,CACXP,QAAQ,EACRC,IAAI,EACJC,UAAU,EACVC,gBAAgB,CAAClB,MAAM,EACvBkB,gBAAgB,CAACjB,IAAI,EACrB,CAACsB,GAAG,EAAEC,UAAU,KAAMD,GAAG,GAAGF,MAAM,CAACE,GAAG,CAAC,GAAGH,OAAO,CAACI,UAAU,CAAE,CAC/D;IACH,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAE;IACtB,MAAMC,OAAO,GAAGtB,MAAM,CAACC,IAAI,CAACmB,IAAI,CAAC;IACjC,MAAMG,OAAO,GAAGvB,MAAM,CAACC,IAAI,CAACoB,KAAK,CAAC;IAClC,MAAM3B,MAAM,GAAGM,MAAM,CAACwB,UAAU,CAACF,OAAO,CAAC;IAEzC,IAAI5B,MAAM,KAAKM,MAAM,CAACwB,UAAU,CAACD,OAAO,CAAC,EAAE;MACzC,MAAM,IAAIxC,wBAAwB,CAAC,oCAAoC,CAAC;IAC1E;IAEA,MAAM0C,MAAM,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,MAAM,EAAEgC,CAAC,EAAE,EAAE;MAC/BD,MAAM,CAACE,IAAI,CAACL,OAAO,CAACI,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC,CAAC;IACtC;IAEA,OAAO1B,MAAM,CAACC,IAAI,CAACwB,MAAM,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,WAAW,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAEC,gBAAgB,EAAErB,gBAAgB,EAAE;IACxE,IAAI,CAACiB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACrB,gBAAgB,GAAGA,gBAAgB;IAExC,MAAMsB,UAAU,GAAGtB,gBAAgB,CAACjB,IAAI,CAACwC,WAAW,EAAE;IACtD,IAAI,CAACC,MAAM,GAAI,cAAaF,UAAW,iBAAgB;IAEvD,IAAI,CAACG,YAAY,GAAGlC,KAAK,CAACG,KAAK,EAAE;EACnC;EAEMgC,YAAY,GAAG;IAAA;IAAA;MACnB,MAAM;QAAEF;MAAO,CAAC,GAAG,KAAI;MACvB,MAAMG,MAAM,GAAI,GAAE,KAAI,CAACT,IAAK,IAAG,KAAI,CAACC,IAAK,EAAC;MAE1C,IAAI,KAAI,CAACF,IAAI,CAACW,QAAQ,IAAI,IAAI,IAAI,KAAI,CAACX,IAAI,CAACpB,QAAQ,IAAI,IAAI,EAAE;QAC5D,MAAM,IAAI3B,8BAA8B,CAAE,GAAE,KAAI,CAACsD,MAAO,gCAA+B,CAAC;MAC1F;MAEA,IAAI;QACF,KAAI,CAACJ,MAAM,CAACS,KAAK,CAAC,iCAAiC,EAAE;UAAEF;QAAO,CAAC,CAAC;QAChE,MAAMG,qBAAqB,SAAS,KAAI,CAACC,sBAAsB,EAAE;QAEjE,KAAI,CAACX,MAAM,CAACS,KAAK,CAAC,uBAAuB,EAAE;UAAEF;QAAO,CAAC,CAAC;QACtD,MAAMK,aAAa,SAAS,KAAI,CAACC,sBAAsB,CAACH,qBAAqB,CAAC;QAE9E,IAAIE,aAAa,CAACE,CAAC,EAAE;UACnB,MAAM,IAAIC,KAAK,CAACH,aAAa,CAACE,CAAC,CAAC;QAClC;QAEA,MAAME,SAAS,SAAS,KAAI,CAACA,SAAS,CAACN,qBAAqB,CAAC;QAC7D,MAAMO,eAAe,GAAG,KAAI,CAACA,eAAe,CAACD,SAAS,EAAEN,qBAAqB,CAAC;QAE9E,IAAIE,aAAa,CAACM,CAAC,KAAKD,eAAe,EAAE;UACvC,MAAM,IAAIF,KAAK,CAAC,kDAAkD,CAAC;QACrE;QAEA,KAAI,CAACf,MAAM,CAACS,KAAK,CAAE,GAAEL,MAAO,aAAY,EAAE;UAAEG;QAAO,CAAC,CAAC;MACvD,CAAC,CAAC,OAAOO,CAAC,EAAE;QACV,MAAMK,KAAK,GAAG,IAAIrE,8BAA8B,CAAE,GAAEsD,MAAO,YAAWU,CAAC,CAACM,OAAQ,EAAC,CAAC;QAClF,KAAI,CAACpB,MAAM,CAACmB,KAAK,CAACA,KAAK,CAACC,OAAO,EAAE;UAAEb;QAAO,CAAC,CAAC;QAC5C,MAAMY,KAAK;MACb;IAAC;EACH;;EAEA;AACF;AACA;EACQR,sBAAsB,GAAG;IAAA;IAAA;MAC7B,MAAMU,kBAAkB,GAAI,GAAErE,UAAW,GAAE,MAAI,CAACsE,gBAAgB,EAAG,EAAC;MACpE,MAAMC,OAAO,GAAG1E,KAAK,CAAC2E,YAAY,CAACD,OAAO,CAAC;QAAEF;MAAmB,CAAC,CAAC;MAClE,MAAMI,QAAQ,GAAG5E,KAAK,CAAC2E,YAAY,CAACC,QAAQ;MAE5C,OAAO,MAAI,CAACxB,gBAAgB,CAAC;QAC3BsB,OAAO;QACPE;MACF,CAAC,CAAC;IAAA;EACJ;;EAEA;AACF;AACA;EACQZ,sBAAsB,CAACH,qBAAqB,EAAE;IAAA;IAAA;MAClD,MAAM;QAAEN;MAAO,CAAC,GAAG,MAAI;MACvB,MAAMzB,UAAU,GAAG+C,QAAQ,CAAChB,qBAAqB,CAAChB,CAAC,EAAE,EAAE,CAAC;MACxD,MAAM;QAAE9B;MAAc,CAAC,GAAG,MAAI,CAACgB,gBAAgB;MAE/C,IAAI,CAAC8B,qBAAqB,CAACiB,CAAC,CAACC,UAAU,CAAC,MAAI,CAACvB,YAAY,CAAC,EAAE;QAC1D,MAAM,IAAIvD,8BAA8B,CACrC,GAAEsD,MAAO,wEAAuE,CAClF;MACH;MAEA,IAAIzB,UAAU,GAAGf,aAAa,EAAE;QAC9B,MAAM,IAAId,8BAA8B,CACrC,GAAEsD,MAAO,iCAAgCzB,UAAW,6BAA4Bf,aAAc,EAAC,CACjG;MACH;MAEA,MAAMiE,wBAAwB,GAAG,MAAI,CAACA,wBAAwB,CAACnB,qBAAqB,CAAC;MACrF,MAAMoB,WAAW,SAAS,MAAI,CAACA,WAAW,CAACpB,qBAAqB,CAAC;MACjE,MAAMqB,YAAY,GAAI,GAAEF,wBAAyB,MAAKC,WAAY,EAAC;MACnE,MAAMP,OAAO,GAAG1E,KAAK,CAACkF,YAAY,CAACR,OAAO,CAAC;QAAEQ;MAAa,CAAC,CAAC;MAC5D,MAAMN,QAAQ,GAAG5E,KAAK,CAACkF,YAAY,CAACN,QAAQ;MAE5C,OAAO,MAAI,CAACxB,gBAAgB,CAAC;QAC3BsB,OAAO;QACPE;MACF,CAAC,CAAC;IAAA;EACJ;;EAEA;AACF;AACA;EACQK,WAAW,CAACpB,qBAAqB,EAAE;IAAA;IAAA;MACvC,MAAMsB,SAAS,SAAS,MAAI,CAACA,SAAS,CAACtB,qBAAqB,CAAC;MAC7D,MAAMuB,SAAS,GAAG,MAAI,CAACC,CAAC,CAACF,SAAS,CAAC;MACnC,MAAMG,eAAe,GAAG,MAAI,CAACA,eAAe,CAACF,SAAS,EAAEvB,qBAAqB,CAAC;MAC9E,OAAO5C,QAAQ,CAACK,KAAK,CAACgB,GAAG,CAAC6C,SAAS,EAAEG,eAAe,CAAC,CAAC;IAAA;EACxD;;EAEA;AACF;AACA;EACQH,SAAS,CAACtB,qBAAqB,EAAE;IAAA;IAAA;MACrC,MAAM0B,cAAc,SAAS,MAAI,CAACC,YAAY,CAAC3B,qBAAqB,CAAC;MACrE,OAAO,MAAI,CAAC4B,IAAI,CAACF,cAAc,EAAE9E,eAAe,CAAC;IAAA;EACnD;;EAEA;AACF;AACA;EACQ0D,SAAS,CAACN,qBAAqB,EAAE;IAAA;IAAA;MACrC,MAAM0B,cAAc,SAAS,MAAI,CAACC,YAAY,CAAC3B,qBAAqB,CAAC;MACrE,OAAO,MAAI,CAAC4B,IAAI,CAACF,cAAc,EAAE7E,eAAe,CAAC;IAAA;EACnD;;EAEA;AACF;AACA;EACE4E,eAAe,CAACF,SAAS,EAAEvB,qBAAqB,EAAE;IAChD,OAAO,IAAI,CAAC4B,IAAI,CAACL,SAAS,EAAE,IAAI,CAACM,WAAW,CAAC7B,qBAAqB,CAAC,CAAC;EACtE;;EAEA;AACF;AACA;EACEO,eAAe,CAACD,SAAS,EAAEN,qBAAqB,EAAE;IAChD,OAAO5C,QAAQ,CAAC,IAAI,CAACwE,IAAI,CAACtB,SAAS,EAAE,IAAI,CAACuB,WAAW,CAAC7B,qBAAqB,CAAC,CAAC,CAAC;EAChF;;EAEA;AACF;AACA;EACE6B,WAAW,CAAC7B,qBAAqB,EAAE;IACjC,OAAO,CACL,IAAI,CAACY,gBAAgB,EAAE,EACvBZ,qBAAqB,CAAC8B,QAAQ,EAC9B,IAAI,CAACX,wBAAwB,CAACnB,qBAAqB,CAAC,CACrD,CAAC+B,IAAI,CAAC,GAAG,CAAC;EACb;;EAEA;AACF;AACA;EACQJ,YAAY,CAAC3B,qBAAqB,EAAE;IAAA;IAAA;MACxC,MAAMhC,IAAI,GAAGV,MAAM,CAACC,IAAI,CAACyC,qBAAqB,CAACgC,CAAC,EAAE,QAAQ,CAAC;MAC3D,MAAM/D,UAAU,GAAG+C,QAAQ,CAAChB,qBAAqB,CAAChB,CAAC,EAAE,EAAE,CAAC;MACxD,OAAOvB,KAAK,CAACK,EAAE,CAAC,MAAI,CAACmE,eAAe,EAAE,EAAEjE,IAAI,EAAEC,UAAU,EAAE,MAAI,CAACC,gBAAgB,CAAC;IAAA;EAClF;;EAEA;AACF;AACA;EACE0C,gBAAgB,GAAG;IACjB,OAAQ,KAAI,IAAI,CAACsB,eAAe,EAAG,MAAK,IAAI,CAACvC,YAAa,EAAC;EAC7D;;EAEA;AACF;AACA;EACEwB,wBAAwB,CAACnB,qBAAqB,EAAE;IAC9C,MAAMmC,MAAM,GAAGnC,qBAAqB,CAACiB,CAAC;IACtC,OAAQ,KAAI7D,QAAQ,CAACd,UAAU,CAAE,MAAK6F,MAAO,EAAC;EAChD;;EAEA;AACF;AACA;EACED,eAAe,GAAG;IAChB,MAAM;MAAEpC;IAAS,CAAC,GAAG,IAAI,CAACX,IAAI;IAC9B,OAAO1B,KAAK,CAACC,cAAc,CAACoC,QAAQ,CAAC,CAACtC,QAAQ,CAAC,OAAO,CAAC;EACzD;;EAEA;AACF;AACA;EACEyE,eAAe,GAAG;IAChB,MAAM;MAAElE;IAAS,CAAC,GAAG,IAAI,CAACoB,IAAI;IAC9B,OAAOpB,QAAQ,CAACP,QAAQ,CAAC,OAAO,CAAC;EACnC;;EAEA;AACF;AACA;EACEgE,CAAC,CAACY,IAAI,EAAE;IACN,OAAOnG,MAAM,CACVoG,UAAU,CAAC,IAAI,CAACnE,gBAAgB,CAACjB,IAAI,CAAC,CACtCqF,MAAM,CAACF,IAAI,CAAC,CACZG,MAAM,EAAE;EACb;;EAEA;AACF;AACA;EACEX,IAAI,CAACY,GAAG,EAAEJ,IAAI,EAAE;IACd,OAAOnG,MAAM,CACVwG,UAAU,CAAC,IAAI,CAACvE,gBAAgB,CAACjB,IAAI,EAAEuF,GAAG,CAAC,CAC3CF,MAAM,CAACF,IAAI,CAAC,CACZG,MAAM,EAAE;EACb;AACF;AAEAG,MAAM,CAACC,OAAO,GAAG;EACf7F,OAAO;EACPW;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}