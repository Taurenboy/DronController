{"ast":null,"code":"const Long = require('../utils/long');\nconst ABORTED_MESSAGE_KEY = Buffer.from([0, 0, 0, 0]);\nconst isAbortMarker = ({\n  key\n}) => {\n  // Handle null/undefined keys.\n  if (!key) return false;\n  // Cast key to buffer defensively\n  return Buffer.from(key).equals(ABORTED_MESSAGE_KEY);\n};\n\n/**\n * Remove messages marked as aborted according to the aborted transactions list.\n *\n * Start of an aborted transaction is determined by message offset.\n * End of an aborted transaction is determined by control messages.\n * @param {Message[]} messages\n * @param {Transaction[]} [abortedTransactions]\n * @returns {Message[]} Messages which did not participate in an aborted transaction\n *\n * @typedef {object} Message\n * @param {Buffer} key\n * @param {lastOffset} key  Int64\n * @param {RecordBatch}  batchContext\n *\n * @typedef {object} Transaction\n * @param {string} firstOffset  Int64\n * @param {string} producerId  Int64\n *\n * @typedef {object} RecordBatch\n * @param {string}  producerId  Int64\n * @param {boolean}  inTransaction\n */\nmodule.exports = ({\n  messages,\n  abortedTransactions\n}) => {\n  const currentAbortedTransactions = new Map();\n  if (!abortedTransactions || !abortedTransactions.length) {\n    return messages;\n  }\n  const remainingAbortedTransactions = [...abortedTransactions];\n  return messages.filter(message => {\n    // If the message offset is GTE the first offset of the next aborted transaction\n    // then we have stepped into an aborted transaction.\n    if (remainingAbortedTransactions.length && Long.fromValue(message.offset).gte(remainingAbortedTransactions[0].firstOffset)) {\n      const {\n        producerId\n      } = remainingAbortedTransactions.shift();\n      currentAbortedTransactions.set(producerId, true);\n    }\n    const {\n      producerId,\n      inTransaction\n    } = message.batchContext;\n    if (isAbortMarker(message)) {\n      // Transaction is over, we no longer need to ignore messages from this producer\n      currentAbortedTransactions.delete(producerId);\n    } else if (currentAbortedTransactions.has(producerId) && inTransaction) {\n      return false;\n    }\n    return true;\n  });\n};","map":{"version":3,"names":["Long","require","ABORTED_MESSAGE_KEY","Buffer","from","isAbortMarker","key","equals","module","exports","messages","abortedTransactions","currentAbortedTransactions","Map","length","remainingAbortedTransactions","filter","message","fromValue","offset","gte","firstOffset","producerId","shift","set","inTransaction","batchContext","delete","has"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/filterAbortedMessages.js"],"sourcesContent":["const Long = require('../utils/long')\nconst ABORTED_MESSAGE_KEY = Buffer.from([0, 0, 0, 0])\n\nconst isAbortMarker = ({ key }) => {\n  // Handle null/undefined keys.\n  if (!key) return false\n  // Cast key to buffer defensively\n  return Buffer.from(key).equals(ABORTED_MESSAGE_KEY)\n}\n\n/**\n * Remove messages marked as aborted according to the aborted transactions list.\n *\n * Start of an aborted transaction is determined by message offset.\n * End of an aborted transaction is determined by control messages.\n * @param {Message[]} messages\n * @param {Transaction[]} [abortedTransactions]\n * @returns {Message[]} Messages which did not participate in an aborted transaction\n *\n * @typedef {object} Message\n * @param {Buffer} key\n * @param {lastOffset} key  Int64\n * @param {RecordBatch}  batchContext\n *\n * @typedef {object} Transaction\n * @param {string} firstOffset  Int64\n * @param {string} producerId  Int64\n *\n * @typedef {object} RecordBatch\n * @param {string}  producerId  Int64\n * @param {boolean}  inTransaction\n */\nmodule.exports = ({ messages, abortedTransactions }) => {\n  const currentAbortedTransactions = new Map()\n\n  if (!abortedTransactions || !abortedTransactions.length) {\n    return messages\n  }\n\n  const remainingAbortedTransactions = [...abortedTransactions]\n\n  return messages.filter(message => {\n    // If the message offset is GTE the first offset of the next aborted transaction\n    // then we have stepped into an aborted transaction.\n    if (\n      remainingAbortedTransactions.length &&\n      Long.fromValue(message.offset).gte(remainingAbortedTransactions[0].firstOffset)\n    ) {\n      const { producerId } = remainingAbortedTransactions.shift()\n      currentAbortedTransactions.set(producerId, true)\n    }\n\n    const { producerId, inTransaction } = message.batchContext\n\n    if (isAbortMarker(message)) {\n      // Transaction is over, we no longer need to ignore messages from this producer\n      currentAbortedTransactions.delete(producerId)\n    } else if (currentAbortedTransactions.has(producerId) && inTransaction) {\n      return false\n    }\n\n    return true\n  })\n}\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAe,CAAC;AACrC,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAErD,MAAMC,aAAa,GAAG,CAAC;EAAEC;AAAI,CAAC,KAAK;EACjC;EACA,IAAI,CAACA,GAAG,EAAE,OAAO,KAAK;EACtB;EACA,OAAOH,MAAM,CAACC,IAAI,CAACE,GAAG,CAAC,CAACC,MAAM,CAACL,mBAAmB,CAAC;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAM,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC,QAAQ;EAAEC;AAAoB,CAAC,KAAK;EACtD,MAAMC,0BAA0B,GAAG,IAAIC,GAAG,EAAE;EAE5C,IAAI,CAACF,mBAAmB,IAAI,CAACA,mBAAmB,CAACG,MAAM,EAAE;IACvD,OAAOJ,QAAQ;EACjB;EAEA,MAAMK,4BAA4B,GAAG,CAAC,GAAGJ,mBAAmB,CAAC;EAE7D,OAAOD,QAAQ,CAACM,MAAM,CAACC,OAAO,IAAI;IAChC;IACA;IACA,IACEF,4BAA4B,CAACD,MAAM,IACnCd,IAAI,CAACkB,SAAS,CAACD,OAAO,CAACE,MAAM,CAAC,CAACC,GAAG,CAACL,4BAA4B,CAAC,CAAC,CAAC,CAACM,WAAW,CAAC,EAC/E;MACA,MAAM;QAAEC;MAAW,CAAC,GAAGP,4BAA4B,CAACQ,KAAK,EAAE;MAC3DX,0BAA0B,CAACY,GAAG,CAACF,UAAU,EAAE,IAAI,CAAC;IAClD;IAEA,MAAM;MAAEA,UAAU;MAAEG;IAAc,CAAC,GAAGR,OAAO,CAACS,YAAY;IAE1D,IAAIrB,aAAa,CAACY,OAAO,CAAC,EAAE;MAC1B;MACAL,0BAA0B,CAACe,MAAM,CAACL,UAAU,CAAC;IAC/C,CAAC,MAAM,IAAIV,0BAA0B,CAACgB,GAAG,CAACN,UAAU,CAAC,IAAIG,aAAa,EAAE;MACtE,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}