{"ast":null,"code":"const Encoder = require('../../../encoder');\nconst Header = require('../../header/v0');\n\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\n/**\n * @param [offsetDelta=0] {Integer}\n * @param [timestampDelta=0] {Long}\n * @param key {Buffer}\n * @param value {Buffer}\n * @param [headers={}] {Object}\n */\nmodule.exports = ({\n  offsetDelta = 0,\n  timestampDelta = 0,\n  key,\n  value,\n  headers = {}\n}) => {\n  const headersArray = Object.keys(headers).flatMap(headerKey => !Array.isArray(headers[headerKey]) ? [{\n    key: headerKey,\n    value: headers[headerKey]\n  }] : headers[headerKey].map(headerValue => ({\n    key: headerKey,\n    value: headerValue\n  })));\n  const sizeOfBody = 1 +\n  // always one byte for attributes\n  Encoder.sizeOfVarLong(timestampDelta) + Encoder.sizeOfVarInt(offsetDelta) + Encoder.sizeOfVarIntBytes(key) + Encoder.sizeOfVarIntBytes(value) + sizeOfHeaders(headersArray);\n  return new Encoder().writeVarInt(sizeOfBody).writeInt8(0) // no used record attributes at the moment\n  .writeVarLong(timestampDelta).writeVarInt(offsetDelta).writeVarIntBytes(key).writeVarIntBytes(value).writeVarIntArray(headersArray.map(Header));\n};\nconst sizeOfHeaders = headersArray => {\n  let size = Encoder.sizeOfVarInt(headersArray.length);\n  for (const header of headersArray) {\n    const keySize = Buffer.byteLength(header.key);\n    const valueSize = Buffer.byteLength(header.value);\n    size += Encoder.sizeOfVarInt(keySize) + keySize;\n    if (header.value === null) {\n      size += Encoder.sizeOfVarInt(-1);\n    } else {\n      size += Encoder.sizeOfVarInt(valueSize) + valueSize;\n    }\n  }\n  return size;\n};","map":{"version":3,"names":["Encoder","require","Header","module","exports","offsetDelta","timestampDelta","key","value","headers","headersArray","Object","keys","flatMap","headerKey","Array","isArray","map","headerValue","sizeOfBody","sizeOfVarLong","sizeOfVarInt","sizeOfVarIntBytes","sizeOfHeaders","writeVarInt","writeInt8","writeVarLong","writeVarIntBytes","writeVarIntArray","size","length","header","keySize","Buffer","byteLength","valueSize"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/recordBatch/record/v0/index.js"],"sourcesContent":["const Encoder = require('../../../encoder')\nconst Header = require('../../header/v0')\n\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\n/**\n * @param [offsetDelta=0] {Integer}\n * @param [timestampDelta=0] {Long}\n * @param key {Buffer}\n * @param value {Buffer}\n * @param [headers={}] {Object}\n */\nmodule.exports = ({ offsetDelta = 0, timestampDelta = 0, key, value, headers = {} }) => {\n  const headersArray = Object.keys(headers).flatMap(headerKey =>\n    !Array.isArray(headers[headerKey])\n      ? [{ key: headerKey, value: headers[headerKey] }]\n      : headers[headerKey].map(headerValue => ({ key: headerKey, value: headerValue }))\n  )\n\n  const sizeOfBody =\n    1 + // always one byte for attributes\n    Encoder.sizeOfVarLong(timestampDelta) +\n    Encoder.sizeOfVarInt(offsetDelta) +\n    Encoder.sizeOfVarIntBytes(key) +\n    Encoder.sizeOfVarIntBytes(value) +\n    sizeOfHeaders(headersArray)\n\n  return new Encoder()\n    .writeVarInt(sizeOfBody)\n    .writeInt8(0) // no used record attributes at the moment\n    .writeVarLong(timestampDelta)\n    .writeVarInt(offsetDelta)\n    .writeVarIntBytes(key)\n    .writeVarIntBytes(value)\n    .writeVarIntArray(headersArray.map(Header))\n}\n\nconst sizeOfHeaders = headersArray => {\n  let size = Encoder.sizeOfVarInt(headersArray.length)\n\n  for (const header of headersArray) {\n    const keySize = Buffer.byteLength(header.key)\n    const valueSize = Buffer.byteLength(header.value)\n\n    size += Encoder.sizeOfVarInt(keySize) + keySize\n\n    if (header.value === null) {\n      size += Encoder.sizeOfVarInt(-1)\n    } else {\n      size += Encoder.sizeOfVarInt(valueSize) + valueSize\n    }\n  }\n\n  return size\n}\n"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAMC,MAAM,GAAGD,OAAO,CAAC,iBAAiB,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC,WAAW,GAAG,CAAC;EAAEC,cAAc,GAAG,CAAC;EAAEC,GAAG;EAAEC,KAAK;EAAEC,OAAO,GAAG,CAAC;AAAE,CAAC,KAAK;EACtF,MAAMC,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACH,OAAO,CAAC,CAACI,OAAO,CAACC,SAAS,IACzD,CAACC,KAAK,CAACC,OAAO,CAACP,OAAO,CAACK,SAAS,CAAC,CAAC,GAC9B,CAAC;IAAEP,GAAG,EAAEO,SAAS;IAAEN,KAAK,EAAEC,OAAO,CAACK,SAAS;EAAE,CAAC,CAAC,GAC/CL,OAAO,CAACK,SAAS,CAAC,CAACG,GAAG,CAACC,WAAW,KAAK;IAAEX,GAAG,EAAEO,SAAS;IAAEN,KAAK,EAAEU;EAAY,CAAC,CAAC,CAAC,CACpF;EAED,MAAMC,UAAU,GACd,CAAC;EAAG;EACJnB,OAAO,CAACoB,aAAa,CAACd,cAAc,CAAC,GACrCN,OAAO,CAACqB,YAAY,CAAChB,WAAW,CAAC,GACjCL,OAAO,CAACsB,iBAAiB,CAACf,GAAG,CAAC,GAC9BP,OAAO,CAACsB,iBAAiB,CAACd,KAAK,CAAC,GAChCe,aAAa,CAACb,YAAY,CAAC;EAE7B,OAAO,IAAIV,OAAO,EAAE,CACjBwB,WAAW,CAACL,UAAU,CAAC,CACvBM,SAAS,CAAC,CAAC,CAAC,CAAC;EAAA,CACbC,YAAY,CAACpB,cAAc,CAAC,CAC5BkB,WAAW,CAACnB,WAAW,CAAC,CACxBsB,gBAAgB,CAACpB,GAAG,CAAC,CACrBoB,gBAAgB,CAACnB,KAAK,CAAC,CACvBoB,gBAAgB,CAAClB,YAAY,CAACO,GAAG,CAACf,MAAM,CAAC,CAAC;AAC/C,CAAC;AAED,MAAMqB,aAAa,GAAGb,YAAY,IAAI;EACpC,IAAImB,IAAI,GAAG7B,OAAO,CAACqB,YAAY,CAACX,YAAY,CAACoB,MAAM,CAAC;EAEpD,KAAK,MAAMC,MAAM,IAAIrB,YAAY,EAAE;IACjC,MAAMsB,OAAO,GAAGC,MAAM,CAACC,UAAU,CAACH,MAAM,CAACxB,GAAG,CAAC;IAC7C,MAAM4B,SAAS,GAAGF,MAAM,CAACC,UAAU,CAACH,MAAM,CAACvB,KAAK,CAAC;IAEjDqB,IAAI,IAAI7B,OAAO,CAACqB,YAAY,CAACW,OAAO,CAAC,GAAGA,OAAO;IAE/C,IAAID,MAAM,CAACvB,KAAK,KAAK,IAAI,EAAE;MACzBqB,IAAI,IAAI7B,OAAO,CAACqB,YAAY,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM;MACLQ,IAAI,IAAI7B,OAAO,CAACqB,YAAY,CAACc,SAAS,CAAC,GAAGA,SAAS;IACrD;EACF;EAEA,OAAON,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}