{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n/**\n * @typedef {ReturnType<typeof createWorkerQueue>} WorkerQueue\n */\n\n/**\n * @param {object} options\n * @param {import('./worker').Worker<T>[]} options.workers\n * @template T\n */\nconst createWorkerQueue = ({\n  workers\n}) => {\n  /** @type {{ batch: T, resolve: (value?: any) => void, reject: (e: Error) => void}[]} */\n  const queue = [];\n  const getWorkers = () => workers;\n\n  /**\n   * Waits until workers have processed all batches in the queue.\n   *\n   * @param {...T} batches\n   * @returns {Promise<void>}\n   */\n  const push = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (...batches) {\n      const promises = batches.map(batch => new Promise((resolve, reject) => queue.push({\n        batch,\n        resolve,\n        reject\n      })));\n      workers.forEach(worker => worker.run({\n        next: () => queue.shift()\n      }));\n      const results = yield Promise.allSettled(promises);\n      const rejected = results.find(result => result.status === 'rejected');\n      if (rejected) {\n        // @ts-ignore\n        throw rejected.reason;\n      }\n    });\n    return function push() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return {\n    push,\n    getWorkers\n  };\n};\nmodule.exports = createWorkerQueue;","map":{"version":3,"names":["createWorkerQueue","workers","queue","getWorkers","push","batches","promises","map","batch","Promise","resolve","reject","forEach","worker","run","next","shift","results","allSettled","rejected","find","result","status","reason","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/workerQueue.js"],"sourcesContent":["/**\n * @typedef {ReturnType<typeof createWorkerQueue>} WorkerQueue\n */\n\n/**\n * @param {object} options\n * @param {import('./worker').Worker<T>[]} options.workers\n * @template T\n */\nconst createWorkerQueue = ({ workers }) => {\n  /** @type {{ batch: T, resolve: (value?: any) => void, reject: (e: Error) => void}[]} */\n  const queue = []\n\n  const getWorkers = () => workers\n\n  /**\n   * Waits until workers have processed all batches in the queue.\n   *\n   * @param {...T} batches\n   * @returns {Promise<void>}\n   */\n  const push = async (...batches) => {\n    const promises = batches.map(\n      batch => new Promise((resolve, reject) => queue.push({ batch, resolve, reject }))\n    )\n\n    workers.forEach(worker => worker.run({ next: () => queue.shift() }))\n\n    const results = await Promise.allSettled(promises)\n    const rejected = results.find(result => result.status === 'rejected')\n    if (rejected) {\n      // @ts-ignore\n      throw rejected.reason\n    }\n  }\n\n  return { push, getWorkers }\n}\n\nmodule.exports = createWorkerQueue\n"],"mappings":";AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMA,iBAAiB,GAAG,CAAC;EAAEC;AAAQ,CAAC,KAAK;EACzC;EACA,MAAMC,KAAK,GAAG,EAAE;EAEhB,MAAMC,UAAU,GAAG,MAAMF,OAAO;;EAEhC;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,IAAI;IAAA,6BAAG,WAAO,GAAGC,OAAO,EAAK;MACjC,MAAMC,QAAQ,GAAGD,OAAO,CAACE,GAAG,CAC1BC,KAAK,IAAI,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKT,KAAK,CAACE,IAAI,CAAC;QAAEI,KAAK;QAAEE,OAAO;QAAEC;MAAO,CAAC,CAAC,CAAC,CAClF;MAEDV,OAAO,CAACW,OAAO,CAACC,MAAM,IAAIA,MAAM,CAACC,GAAG,CAAC;QAAEC,IAAI,EAAE,MAAMb,KAAK,CAACc,KAAK;MAAG,CAAC,CAAC,CAAC;MAEpE,MAAMC,OAAO,SAASR,OAAO,CAACS,UAAU,CAACZ,QAAQ,CAAC;MAClD,MAAMa,QAAQ,GAAGF,OAAO,CAACG,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACC,MAAM,KAAK,UAAU,CAAC;MACrE,IAAIH,QAAQ,EAAE;QACZ;QACA,MAAMA,QAAQ,CAACI,MAAM;MACvB;IACF,CAAC;IAAA,gBAbKnB,IAAI;MAAA;IAAA;EAAA,GAaT;EAED,OAAO;IAAEA,IAAI;IAAED;EAAW,CAAC;AAC7B,CAAC;AAEDqB,MAAM,CAACC,OAAO,GAAGzB,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}