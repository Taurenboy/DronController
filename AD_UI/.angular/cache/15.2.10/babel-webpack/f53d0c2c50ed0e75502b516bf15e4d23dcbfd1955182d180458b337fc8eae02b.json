{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Encoder = require('../../../encoder');\nconst {\n  Produce: apiKey\n} = require('../../apiKeys');\nconst MessageSet = require('../../../messageSet');\nconst {\n  Types,\n  lookupCodec\n} = require('../../../message/compression');\n\n// Produce Request on or after v2 indicates the client can parse the timestamp field\n// in the produce Response.\n\nmodule.exports = ({\n  acks,\n  timeout,\n  compression = Types.None,\n  topicData\n}) => ({\n  apiKey,\n  apiVersion: 2,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: function () {\n    var _ref = _asyncToGenerator(function* () {\n      const encodeTopic = topicEncoder(compression);\n      const encodedTopicData = [];\n      for (const data of topicData) {\n        encodedTopicData.push(yield encodeTopic(data));\n      }\n      return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(encodedTopicData);\n    });\n    return function encode() {\n      return _ref.apply(this, arguments);\n    };\n  }()\n});\nconst topicEncoder = compression => {\n  const encodePartitions = partitionsEncoder(compression);\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* ({\n      topic,\n      partitions\n    }) {\n      const encodedPartitions = [];\n      for (const data of partitions) {\n        encodedPartitions.push(yield encodePartitions(data));\n      }\n      return new Encoder().writeString(topic).writeArray(encodedPartitions);\n    });\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n};\nconst partitionsEncoder = compression => /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* ({\n    partition,\n    messages\n  }) {\n    const messageSet = MessageSet({\n      messageVersion: 1,\n      compression,\n      entries: messages\n    });\n    if (compression === Types.None) {\n      return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);\n    }\n    const timestamp = messages[0].timestamp || Date.now();\n    const codec = lookupCodec(compression);\n    const compressedValue = yield codec.compress(messageSet);\n    const compressedMessageSet = MessageSet({\n      messageVersion: 1,\n      entries: [{\n        compression,\n        timestamp,\n        value: compressedValue\n      }]\n    });\n    return new Encoder().writeInt32(partition).writeInt32(compressedMessageSet.size()).writeEncoder(compressedMessageSet);\n  });\n  return function (_x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["Encoder","require","Produce","apiKey","MessageSet","Types","lookupCodec","module","exports","acks","timeout","compression","None","topicData","apiVersion","apiName","expectResponse","encode","encodeTopic","topicEncoder","encodedTopicData","data","push","writeInt16","writeInt32","writeArray","encodePartitions","partitionsEncoder","topic","partitions","encodedPartitions","writeString","partition","messages","messageSet","messageVersion","entries","size","writeEncoder","timestamp","Date","now","codec","compressedValue","compress","compressedMessageSet","value"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/requests/produce/v2/request.js"],"sourcesContent":["const Encoder = require('../../../encoder')\nconst { Produce: apiKey } = require('../../apiKeys')\nconst MessageSet = require('../../../messageSet')\nconst { Types, lookupCodec } = require('../../../message/compression')\n\n// Produce Request on or after v2 indicates the client can parse the timestamp field\n// in the produce Response.\n\nmodule.exports = ({ acks, timeout, compression = Types.None, topicData }) => ({\n  apiKey,\n  apiVersion: 2,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    const encodeTopic = topicEncoder(compression)\n    const encodedTopicData = []\n\n    for (const data of topicData) {\n      encodedTopicData.push(await encodeTopic(data))\n    }\n\n    return new Encoder()\n      .writeInt16(acks)\n      .writeInt32(timeout)\n      .writeArray(encodedTopicData)\n  },\n})\n\nconst topicEncoder = compression => {\n  const encodePartitions = partitionsEncoder(compression)\n\n  return async ({ topic, partitions }) => {\n    const encodedPartitions = []\n\n    for (const data of partitions) {\n      encodedPartitions.push(await encodePartitions(data))\n    }\n\n    return new Encoder().writeString(topic).writeArray(encodedPartitions)\n  }\n}\n\nconst partitionsEncoder = compression => async ({ partition, messages }) => {\n  const messageSet = MessageSet({ messageVersion: 1, compression, entries: messages })\n\n  if (compression === Types.None) {\n    return new Encoder()\n      .writeInt32(partition)\n      .writeInt32(messageSet.size())\n      .writeEncoder(messageSet)\n  }\n\n  const timestamp = messages[0].timestamp || Date.now()\n\n  const codec = lookupCodec(compression)\n  const compressedValue = await codec.compress(messageSet)\n  const compressedMessageSet = MessageSet({\n    messageVersion: 1,\n    entries: [{ compression, timestamp, value: compressedValue }],\n  })\n\n  return new Encoder()\n    .writeInt32(partition)\n    .writeInt32(compressedMessageSet.size())\n    .writeEncoder(compressedMessageSet)\n}\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAM;EAAEC,OAAO,EAAEC;AAAO,CAAC,GAAGF,OAAO,CAAC,eAAe,CAAC;AACpD,MAAMG,UAAU,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AACjD,MAAM;EAAEI,KAAK;EAAEC;AAAY,CAAC,GAAGL,OAAO,CAAC,8BAA8B,CAAC;;AAEtE;AACA;;AAEAM,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC,IAAI;EAAEC,OAAO;EAAEC,WAAW,GAAGN,KAAK,CAACO,IAAI;EAAEC;AAAU,CAAC,MAAM;EAC5EV,MAAM;EACNW,UAAU,EAAE,CAAC;EACbC,OAAO,EAAE,SAAS;EAClBC,cAAc,EAAE,MAAMP,IAAI,KAAK,CAAC;EAChCQ,MAAM;IAAA,6BAAE,aAAY;MAClB,MAAMC,WAAW,GAAGC,YAAY,CAACR,WAAW,CAAC;MAC7C,MAAMS,gBAAgB,GAAG,EAAE;MAE3B,KAAK,MAAMC,IAAI,IAAIR,SAAS,EAAE;QAC5BO,gBAAgB,CAACE,IAAI,OAAOJ,WAAW,CAACG,IAAI,CAAC,CAAC;MAChD;MAEA,OAAO,IAAIrB,OAAO,EAAE,CACjBuB,UAAU,CAACd,IAAI,CAAC,CAChBe,UAAU,CAACd,OAAO,CAAC,CACnBe,UAAU,CAACL,gBAAgB,CAAC;IACjC,CAAC;IAAA;MAAA;IAAA;EAAA;AACH,CAAC,CAAC;AAEF,MAAMD,YAAY,GAAGR,WAAW,IAAI;EAClC,MAAMe,gBAAgB,GAAGC,iBAAiB,CAAChB,WAAW,CAAC;EAEvD;IAAA,8BAAO,WAAO;MAAEiB,KAAK;MAAEC;IAAW,CAAC,EAAK;MACtC,MAAMC,iBAAiB,GAAG,EAAE;MAE5B,KAAK,MAAMT,IAAI,IAAIQ,UAAU,EAAE;QAC7BC,iBAAiB,CAACR,IAAI,OAAOI,gBAAgB,CAACL,IAAI,CAAC,CAAC;MACtD;MAEA,OAAO,IAAIrB,OAAO,EAAE,CAAC+B,WAAW,CAACH,KAAK,CAAC,CAACH,UAAU,CAACK,iBAAiB,CAAC;IACvE,CAAC;IAAA;MAAA;IAAA;EAAA;AACH,CAAC;AAED,MAAMH,iBAAiB,GAAGhB,WAAW;EAAA,8BAAI,WAAO;IAAEqB,SAAS;IAAEC;EAAS,CAAC,EAAK;IAC1E,MAAMC,UAAU,GAAG9B,UAAU,CAAC;MAAE+B,cAAc,EAAE,CAAC;MAAExB,WAAW;MAAEyB,OAAO,EAAEH;IAAS,CAAC,CAAC;IAEpF,IAAItB,WAAW,KAAKN,KAAK,CAACO,IAAI,EAAE;MAC9B,OAAO,IAAIZ,OAAO,EAAE,CACjBwB,UAAU,CAACQ,SAAS,CAAC,CACrBR,UAAU,CAACU,UAAU,CAACG,IAAI,EAAE,CAAC,CAC7BC,YAAY,CAACJ,UAAU,CAAC;IAC7B;IAEA,MAAMK,SAAS,GAAGN,QAAQ,CAAC,CAAC,CAAC,CAACM,SAAS,IAAIC,IAAI,CAACC,GAAG,EAAE;IAErD,MAAMC,KAAK,GAAGpC,WAAW,CAACK,WAAW,CAAC;IACtC,MAAMgC,eAAe,SAASD,KAAK,CAACE,QAAQ,CAACV,UAAU,CAAC;IACxD,MAAMW,oBAAoB,GAAGzC,UAAU,CAAC;MACtC+B,cAAc,EAAE,CAAC;MACjBC,OAAO,EAAE,CAAC;QAAEzB,WAAW;QAAE4B,SAAS;QAAEO,KAAK,EAAEH;MAAgB,CAAC;IAC9D,CAAC,CAAC;IAEF,OAAO,IAAI3C,OAAO,EAAE,CACjBwB,UAAU,CAACQ,SAAS,CAAC,CACrBR,UAAU,CAACqB,oBAAoB,CAACR,IAAI,EAAE,CAAC,CACvCC,YAAY,CAACO,oBAAoB,CAAC;EACvC,CAAC;EAAA;IAAA;EAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}