{"ast":null,"code":"const Long = require('../utils/long');\nconst filterAbortedMessages = require('./filterAbortedMessages');\n\n/**\n * A batch collects messages returned from a single fetch call.\n *\n * A batch could contain _multiple_ Kafka RecordBatches.\n */\nmodule.exports = class Batch {\n  constructor(topic, fetchedOffset, partitionData) {\n    this.fetchedOffset = fetchedOffset;\n    const longFetchedOffset = Long.fromValue(this.fetchedOffset);\n    const {\n      abortedTransactions,\n      messages\n    } = partitionData;\n    this.topic = topic;\n    this.partition = partitionData.partition;\n    this.highWatermark = partitionData.highWatermark;\n    this.rawMessages = messages;\n    // Apparently fetch can return different offsets than the target offset provided to the fetch API.\n    // Discard messages that are not in the requested offset\n    // https://github.com/apache/kafka/blob/bf237fa7c576bd141d78fdea9f17f65ea269c290/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L912\n    this.messagesWithinOffset = this.rawMessages.filter(message => Long.fromValue(message.offset).gte(longFetchedOffset));\n\n    // 1. Don't expose aborted messages\n    // 2. Don't expose control records\n    // @see https://kafka.apache.org/documentation/#controlbatch\n    this.messages = filterAbortedMessages({\n      messages: this.messagesWithinOffset,\n      abortedTransactions\n    }).filter(message => !message.isControlRecord);\n  }\n  isEmpty() {\n    return this.messages.length === 0;\n  }\n  isEmptyIncludingFiltered() {\n    return this.messagesWithinOffset.length === 0;\n  }\n\n  /**\n   * If the batch contained raw messages (i.e was not truly empty) but all messages were filtered out due to\n   * log compaction, control records or other reasons\n   */\n  isEmptyDueToFiltering() {\n    return this.isEmpty() && this.rawMessages.length > 0;\n  }\n  isEmptyControlRecord() {\n    return this.isEmpty() && this.messagesWithinOffset.some(({\n      isControlRecord\n    }) => isControlRecord);\n  }\n\n  /**\n   * With compressed messages, it's possible for the returned messages to have offsets smaller than the starting offset.\n   * These messages will be filtered out (i.e. they are not even included in this.messagesWithinOffset)\n   * If these are the only messages, the batch will appear as an empty batch.\n   *\n   * isEmpty() and isEmptyIncludingFiltered() will always return true if the batch is empty,\n   * but this method will only return true if the batch is empty due to log compacted messages.\n   *\n   * @returns boolean True if the batch is empty, because of log compacted messages in the partition.\n   */\n  isEmptyDueToLogCompactedMessages() {\n    const hasMessages = this.rawMessages.length > 0;\n    return hasMessages && this.isEmptyIncludingFiltered();\n  }\n  firstOffset() {\n    return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset;\n  }\n  lastOffset() {\n    if (this.isEmptyDueToLogCompactedMessages()) {\n      return this.fetchedOffset;\n    }\n    if (this.isEmptyIncludingFiltered()) {\n      return Long.fromValue(this.highWatermark).add(-1).toString();\n    }\n    return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset;\n  }\n\n  /**\n   * Returns the lag based on the last offset in the batch (also known as \"high\")\n   */\n  offsetLag() {\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);\n    const lastConsumedOffset = Long.fromValue(this.lastOffset());\n    return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString();\n  }\n\n  /**\n   * Returns the lag based on the first offset in the batch\n   */\n  offsetLagLow() {\n    if (this.isEmptyIncludingFiltered()) {\n      return '0';\n    }\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);\n    const firstConsumedOffset = Long.fromValue(this.firstOffset());\n    return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString();\n  }\n};","map":{"version":3,"names":["Long","require","filterAbortedMessages","module","exports","Batch","constructor","topic","fetchedOffset","partitionData","longFetchedOffset","fromValue","abortedTransactions","messages","partition","highWatermark","rawMessages","messagesWithinOffset","filter","message","offset","gte","isControlRecord","isEmpty","length","isEmptyIncludingFiltered","isEmptyDueToFiltering","isEmptyControlRecord","some","isEmptyDueToLogCompactedMessages","hasMessages","firstOffset","lastOffset","add","toString","offsetLag","lastOffsetOfPartition","lastConsumedOffset","multiply","offsetLagLow","firstConsumedOffset"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/batch.js"],"sourcesContent":["const Long = require('../utils/long')\nconst filterAbortedMessages = require('./filterAbortedMessages')\n\n/**\n * A batch collects messages returned from a single fetch call.\n *\n * A batch could contain _multiple_ Kafka RecordBatches.\n */\nmodule.exports = class Batch {\n  constructor(topic, fetchedOffset, partitionData) {\n    this.fetchedOffset = fetchedOffset\n    const longFetchedOffset = Long.fromValue(this.fetchedOffset)\n    const { abortedTransactions, messages } = partitionData\n\n    this.topic = topic\n    this.partition = partitionData.partition\n    this.highWatermark = partitionData.highWatermark\n\n    this.rawMessages = messages\n    // Apparently fetch can return different offsets than the target offset provided to the fetch API.\n    // Discard messages that are not in the requested offset\n    // https://github.com/apache/kafka/blob/bf237fa7c576bd141d78fdea9f17f65ea269c290/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L912\n    this.messagesWithinOffset = this.rawMessages.filter(message =>\n      Long.fromValue(message.offset).gte(longFetchedOffset)\n    )\n\n    // 1. Don't expose aborted messages\n    // 2. Don't expose control records\n    // @see https://kafka.apache.org/documentation/#controlbatch\n    this.messages = filterAbortedMessages({\n      messages: this.messagesWithinOffset,\n      abortedTransactions,\n    }).filter(message => !message.isControlRecord)\n  }\n\n  isEmpty() {\n    return this.messages.length === 0\n  }\n\n  isEmptyIncludingFiltered() {\n    return this.messagesWithinOffset.length === 0\n  }\n\n  /**\n   * If the batch contained raw messages (i.e was not truly empty) but all messages were filtered out due to\n   * log compaction, control records or other reasons\n   */\n  isEmptyDueToFiltering() {\n    return this.isEmpty() && this.rawMessages.length > 0\n  }\n\n  isEmptyControlRecord() {\n    return (\n      this.isEmpty() && this.messagesWithinOffset.some(({ isControlRecord }) => isControlRecord)\n    )\n  }\n\n  /**\n   * With compressed messages, it's possible for the returned messages to have offsets smaller than the starting offset.\n   * These messages will be filtered out (i.e. they are not even included in this.messagesWithinOffset)\n   * If these are the only messages, the batch will appear as an empty batch.\n   *\n   * isEmpty() and isEmptyIncludingFiltered() will always return true if the batch is empty,\n   * but this method will only return true if the batch is empty due to log compacted messages.\n   *\n   * @returns boolean True if the batch is empty, because of log compacted messages in the partition.\n   */\n  isEmptyDueToLogCompactedMessages() {\n    const hasMessages = this.rawMessages.length > 0\n    return hasMessages && this.isEmptyIncludingFiltered()\n  }\n\n  firstOffset() {\n    return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset\n  }\n\n  lastOffset() {\n    if (this.isEmptyDueToLogCompactedMessages()) {\n      return this.fetchedOffset\n    }\n\n    if (this.isEmptyIncludingFiltered()) {\n      return Long.fromValue(this.highWatermark)\n        .add(-1)\n        .toString()\n    }\n\n    return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset\n  }\n\n  /**\n   * Returns the lag based on the last offset in the batch (also known as \"high\")\n   */\n  offsetLag() {\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1)\n    const lastConsumedOffset = Long.fromValue(this.lastOffset())\n    return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString()\n  }\n\n  /**\n   * Returns the lag based on the first offset in the batch\n   */\n  offsetLagLow() {\n    if (this.isEmptyIncludingFiltered()) {\n      return '0'\n    }\n\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1)\n    const firstConsumedOffset = Long.fromValue(this.firstOffset())\n    return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}