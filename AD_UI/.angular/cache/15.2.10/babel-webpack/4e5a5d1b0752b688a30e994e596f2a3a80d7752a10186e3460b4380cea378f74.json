{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Encoder = require('../../../encoder');\nconst {\n  Produce: apiKey\n} = require('../../apiKeys');\nconst MessageSet = require('../../../messageSet');\n\n/**\n * Produce Request (Version: 0) => acks timeout [topic_data]\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set record_set_size\n *       partition => INT32\n *       record_set_size => INT32\n *       record_set => RECORDS\n */\n\n/**\n * MessageV0:\n * {\n *   key: bytes,\n *   value: bytes\n * }\n *\n * MessageSet:\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n *\n * TopicData:\n * [\n *   {\n *     topic: 'name1',\n *     partitions: [\n *       {\n *         partition: 0,\n *         messages: [<MessageSet>]\n *       }\n *     ]\n *   }\n * ]\n */\n\n/**\n * @param acks {Integer} This field indicates how many acknowledgements the servers should receive before\n *                       responding to the request. If it is 0 the server will not send any response\n *                       (this is the only case where the server will not reply to a request). If it is 1,\n *                       the server will wait the data is written to the local log before sending a response.\n *                       If it is -1 the server will block until the message is committed by all in sync replicas\n *                       before sending a response.\n *\n * @param timeout {Integer} This provides a maximum time in milliseconds the server can await the receipt of the number\n *                          of acknowledgements in RequiredAcks. The timeout is not an exact limit on the request time\n *                          for a few reasons:\n *                          (1) it does not include network latency,\n *                          (2) the timer begins at the beginning of the processing of this request so if many requests are\n *                              queued due to server overload that wait time will not be included,\n *                          (3) we will not terminate a local write so if the local write time exceeds this timeout it will not\n *                              be respected. To get a hard timeout of this type the client should use the socket timeout.\n *\n * @param topicData {Array}\n */\nmodule.exports = ({\n  acks,\n  timeout,\n  topicData\n}) => ({\n  apiKey,\n  apiVersion: 0,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: function () {\n    var _ref = _asyncToGenerator(function* () {\n      return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(topicData.map(encodeTopic));\n    });\n    return function encode() {\n      return _ref.apply(this, arguments);\n    };\n  }()\n});\nconst encodeTopic = ({\n  topic,\n  partitions\n}) => {\n  return new Encoder().writeString(topic).writeArray(partitions.map(encodePartitions));\n};\nconst encodePartitions = ({\n  partition,\n  messages\n}) => {\n  const messageSet = MessageSet({\n    messageVersion: 0,\n    entries: messages\n  });\n  return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);\n};","map":{"version":3,"names":["Encoder","require","Produce","apiKey","MessageSet","module","exports","acks","timeout","topicData","apiVersion","apiName","expectResponse","encode","writeInt16","writeInt32","writeArray","map","encodeTopic","topic","partitions","writeString","encodePartitions","partition","messages","messageSet","messageVersion","entries","size","writeEncoder"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/requests/produce/v0/request.js"],"sourcesContent":["const Encoder = require('../../../encoder')\nconst { Produce: apiKey } = require('../../apiKeys')\nconst MessageSet = require('../../../messageSet')\n\n/**\n * Produce Request (Version: 0) => acks timeout [topic_data]\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set record_set_size\n *       partition => INT32\n *       record_set_size => INT32\n *       record_set => RECORDS\n */\n\n/**\n * MessageV0:\n * {\n *   key: bytes,\n *   value: bytes\n * }\n *\n * MessageSet:\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n *\n * TopicData:\n * [\n *   {\n *     topic: 'name1',\n *     partitions: [\n *       {\n *         partition: 0,\n *         messages: [<MessageSet>]\n *       }\n *     ]\n *   }\n * ]\n */\n\n/**\n * @param acks {Integer} This field indicates how many acknowledgements the servers should receive before\n *                       responding to the request. If it is 0 the server will not send any response\n *                       (this is the only case where the server will not reply to a request). If it is 1,\n *                       the server will wait the data is written to the local log before sending a response.\n *                       If it is -1 the server will block until the message is committed by all in sync replicas\n *                       before sending a response.\n *\n * @param timeout {Integer} This provides a maximum time in milliseconds the server can await the receipt of the number\n *                          of acknowledgements in RequiredAcks. The timeout is not an exact limit on the request time\n *                          for a few reasons:\n *                          (1) it does not include network latency,\n *                          (2) the timer begins at the beginning of the processing of this request so if many requests are\n *                              queued due to server overload that wait time will not be included,\n *                          (3) we will not terminate a local write so if the local write time exceeds this timeout it will not\n *                              be respected. To get a hard timeout of this type the client should use the socket timeout.\n *\n * @param topicData {Array}\n */\nmodule.exports = ({ acks, timeout, topicData }) => ({\n  apiKey,\n  apiVersion: 0,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    return new Encoder()\n      .writeInt16(acks)\n      .writeInt32(timeout)\n      .writeArray(topicData.map(encodeTopic))\n  },\n})\n\nconst encodeTopic = ({ topic, partitions }) => {\n  return new Encoder().writeString(topic).writeArray(partitions.map(encodePartitions))\n}\n\nconst encodePartitions = ({ partition, messages }) => {\n  const messageSet = MessageSet({ messageVersion: 0, entries: messages })\n  return new Encoder()\n    .writeInt32(partition)\n    .writeInt32(messageSet.size())\n    .writeEncoder(messageSet)\n}\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAM;EAAEC,OAAO,EAAEC;AAAO,CAAC,GAAGF,OAAO,CAAC,eAAe,CAAC;AACpD,MAAMG,UAAU,GAAGH,OAAO,CAAC,qBAAqB,CAAC;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAI,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC,IAAI;EAAEC,OAAO;EAAEC;AAAU,CAAC,MAAM;EAClDN,MAAM;EACNO,UAAU,EAAE,CAAC;EACbC,OAAO,EAAE,SAAS;EAClBC,cAAc,EAAE,MAAML,IAAI,KAAK,CAAC;EAChCM,MAAM;IAAA,6BAAE,aAAY;MAClB,OAAO,IAAIb,OAAO,EAAE,CACjBc,UAAU,CAACP,IAAI,CAAC,CAChBQ,UAAU,CAACP,OAAO,CAAC,CACnBQ,UAAU,CAACP,SAAS,CAACQ,GAAG,CAACC,WAAW,CAAC,CAAC;IAC3C,CAAC;IAAA;MAAA;IAAA;EAAA;AACH,CAAC,CAAC;AAEF,MAAMA,WAAW,GAAG,CAAC;EAAEC,KAAK;EAAEC;AAAW,CAAC,KAAK;EAC7C,OAAO,IAAIpB,OAAO,EAAE,CAACqB,WAAW,CAACF,KAAK,CAAC,CAACH,UAAU,CAACI,UAAU,CAACH,GAAG,CAACK,gBAAgB,CAAC,CAAC;AACtF,CAAC;AAED,MAAMA,gBAAgB,GAAG,CAAC;EAAEC,SAAS;EAAEC;AAAS,CAAC,KAAK;EACpD,MAAMC,UAAU,GAAGrB,UAAU,CAAC;IAAEsB,cAAc,EAAE,CAAC;IAAEC,OAAO,EAAEH;EAAS,CAAC,CAAC;EACvE,OAAO,IAAIxB,OAAO,EAAE,CACjBe,UAAU,CAACQ,SAAS,CAAC,CACrBR,UAAU,CAACU,UAAU,CAACG,IAAI,EAAE,CAAC,CAC7BC,YAAY,CAACJ,UAAU,CAAC;AAC7B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}