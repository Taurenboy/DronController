{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Decoder = require('../../../decoder');\nconst {\n  KafkaJSDeleteTopicRecordsError\n} = require('../../../../errors');\nconst {\n  failure,\n  createErrorFromCode\n} = require('../../../error');\n\n/**\n * DeleteRecords Response (Version: 0) => throttle_time_ms [topics]\n *  throttle_time_ms => INT32\n *  topics => name [partitions]\n *    name => STRING\n *    partitions => partition low_watermark error_code\n *      partition => INT32\n *      low_watermark => INT64\n *      error_code => INT16\n */\n\nconst topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);\nconst decode = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (rawData) {\n    const decoder = new Decoder(rawData);\n    return {\n      throttleTime: decoder.readInt32(),\n      topics: decoder.readArray(decoder => ({\n        topic: decoder.readString(),\n        partitions: decoder.readArray(decoder => ({\n          partition: decoder.readInt32(),\n          lowWatermark: decoder.readInt64(),\n          errorCode: decoder.readInt16()\n        }))\n      })).sort(topicNameComparator)\n    };\n  });\n  return function decode(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst parse = requestTopics => /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (data) {\n    const topicsWithErrors = data.topics.map(({\n      partitions\n    }) => ({\n      partitionsWithErrors: partitions.filter(({\n        errorCode\n      }) => failure(errorCode))\n    })).filter(({\n      partitionsWithErrors\n    }) => partitionsWithErrors.length);\n    if (topicsWithErrors.length > 0) {\n      // at present we only ever request one topic at a time, so can destructure the arrays\n      const [{\n        topic\n      }] = data.topics; // topic name\n      const [{\n        partitions: requestPartitions\n      }] = requestTopics; // requested offset(s)\n      const [{\n        partitionsWithErrors\n      }] = topicsWithErrors; // partition(s) + error(s)\n\n      throw new KafkaJSDeleteTopicRecordsError({\n        topic,\n        partitions: partitionsWithErrors.map(({\n          partition,\n          errorCode\n        }) => ({\n          partition,\n          error: createErrorFromCode(errorCode),\n          // attach the original offset from the request, onto the error response\n          offset: requestPartitions.find(p => p.partition === partition).offset\n        }))\n      });\n    }\n    return data;\n  });\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nmodule.exports = ({\n  topics\n}) => ({\n  decode,\n  parse: parse(topics)\n});","map":{"version":3,"names":["Decoder","require","KafkaJSDeleteTopicRecordsError","failure","createErrorFromCode","topicNameComparator","a","b","topic","localeCompare","decode","rawData","decoder","throttleTime","readInt32","topics","readArray","readString","partitions","partition","lowWatermark","readInt64","errorCode","readInt16","sort","parse","requestTopics","data","topicsWithErrors","map","partitionsWithErrors","filter","length","requestPartitions","error","offset","find","p","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/requests/deleteRecords/v0/response.js"],"sourcesContent":["const Decoder = require('../../../decoder')\nconst { KafkaJSDeleteTopicRecordsError } = require('../../../../errors')\nconst { failure, createErrorFromCode } = require('../../../error')\n\n/**\n * DeleteRecords Response (Version: 0) => throttle_time_ms [topics]\n *  throttle_time_ms => INT32\n *  topics => name [partitions]\n *    name => STRING\n *    partitions => partition low_watermark error_code\n *      partition => INT32\n *      low_watermark => INT64\n *      error_code => INT16\n */\n\nconst topicNameComparator = (a, b) => a.topic.localeCompare(b.topic)\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData)\n  return {\n    throttleTime: decoder.readInt32(),\n    topics: decoder\n      .readArray(decoder => ({\n        topic: decoder.readString(),\n        partitions: decoder.readArray(decoder => ({\n          partition: decoder.readInt32(),\n          lowWatermark: decoder.readInt64(),\n          errorCode: decoder.readInt16(),\n        })),\n      }))\n      .sort(topicNameComparator),\n  }\n}\n\nconst parse = requestTopics => async data => {\n  const topicsWithErrors = data.topics\n    .map(({ partitions }) => ({\n      partitionsWithErrors: partitions.filter(({ errorCode }) => failure(errorCode)),\n    }))\n    .filter(({ partitionsWithErrors }) => partitionsWithErrors.length)\n\n  if (topicsWithErrors.length > 0) {\n    // at present we only ever request one topic at a time, so can destructure the arrays\n    const [{ topic }] = data.topics // topic name\n    const [{ partitions: requestPartitions }] = requestTopics // requested offset(s)\n    const [{ partitionsWithErrors }] = topicsWithErrors // partition(s) + error(s)\n\n    throw new KafkaJSDeleteTopicRecordsError({\n      topic,\n      partitions: partitionsWithErrors.map(({ partition, errorCode }) => ({\n        partition,\n        error: createErrorFromCode(errorCode),\n        // attach the original offset from the request, onto the error response\n        offset: requestPartitions.find(p => p.partition === partition).offset,\n      })),\n    })\n  }\n\n  return data\n}\n\nmodule.exports = ({ topics }) => ({\n  decode,\n  parse: parse(topics),\n})\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAM;EAAEC;AAA+B,CAAC,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AACxE,MAAM;EAAEE,OAAO;EAAEC;AAAoB,CAAC,GAAGH,OAAO,CAAC,gBAAgB,CAAC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMI,mBAAmB,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,KAAK,CAACC,aAAa,CAACF,CAAC,CAACC,KAAK,CAAC;AAEpE,MAAME,MAAM;EAAA,6BAAG,WAAMC,OAAO,EAAI;IAC9B,MAAMC,OAAO,GAAG,IAAIZ,OAAO,CAACW,OAAO,CAAC;IACpC,OAAO;MACLE,YAAY,EAAED,OAAO,CAACE,SAAS,EAAE;MACjCC,MAAM,EAAEH,OAAO,CACZI,SAAS,CAACJ,OAAO,KAAK;QACrBJ,KAAK,EAAEI,OAAO,CAACK,UAAU,EAAE;QAC3BC,UAAU,EAAEN,OAAO,CAACI,SAAS,CAACJ,OAAO,KAAK;UACxCO,SAAS,EAAEP,OAAO,CAACE,SAAS,EAAE;UAC9BM,YAAY,EAAER,OAAO,CAACS,SAAS,EAAE;UACjCC,SAAS,EAAEV,OAAO,CAACW,SAAS;QAC9B,CAAC,CAAC;MACJ,CAAC,CAAC,CAAC,CACFC,IAAI,CAACnB,mBAAmB;IAC7B,CAAC;EACH,CAAC;EAAA,gBAfKK,MAAM;IAAA;EAAA;AAAA,GAeX;AAED,MAAMe,KAAK,GAAGC,aAAa;EAAA,8BAAI,WAAMC,IAAI,EAAI;IAC3C,MAAMC,gBAAgB,GAAGD,IAAI,CAACZ,MAAM,CACjCc,GAAG,CAAC,CAAC;MAAEX;IAAW,CAAC,MAAM;MACxBY,oBAAoB,EAAEZ,UAAU,CAACa,MAAM,CAAC,CAAC;QAAET;MAAU,CAAC,KAAKnB,OAAO,CAACmB,SAAS,CAAC;IAC/E,CAAC,CAAC,CAAC,CACFS,MAAM,CAAC,CAAC;MAAED;IAAqB,CAAC,KAAKA,oBAAoB,CAACE,MAAM,CAAC;IAEpE,IAAIJ,gBAAgB,CAACI,MAAM,GAAG,CAAC,EAAE;MAC/B;MACA,MAAM,CAAC;QAAExB;MAAM,CAAC,CAAC,GAAGmB,IAAI,CAACZ,MAAM,EAAC;MAChC,MAAM,CAAC;QAAEG,UAAU,EAAEe;MAAkB,CAAC,CAAC,GAAGP,aAAa,EAAC;MAC1D,MAAM,CAAC;QAAEI;MAAqB,CAAC,CAAC,GAAGF,gBAAgB,EAAC;;MAEpD,MAAM,IAAI1B,8BAA8B,CAAC;QACvCM,KAAK;QACLU,UAAU,EAAEY,oBAAoB,CAACD,GAAG,CAAC,CAAC;UAAEV,SAAS;UAAEG;QAAU,CAAC,MAAM;UAClEH,SAAS;UACTe,KAAK,EAAE9B,mBAAmB,CAACkB,SAAS,CAAC;UACrC;UACAa,MAAM,EAAEF,iBAAiB,CAACG,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAClB,SAAS,KAAKA,SAAS,CAAC,CAACgB;QACjE,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IAEA,OAAOR,IAAI;EACb,CAAC;EAAA;IAAA;EAAA;AAAA;AAEDW,MAAM,CAACC,OAAO,GAAG,CAAC;EAAExB;AAAO,CAAC,MAAM;EAChCL,MAAM;EACNe,KAAK,EAAEA,KAAK,CAACV,MAAM;AACrB,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}