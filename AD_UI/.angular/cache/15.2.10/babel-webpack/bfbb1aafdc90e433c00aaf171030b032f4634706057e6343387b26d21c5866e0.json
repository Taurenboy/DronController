{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst EventEmitter = require('events');\n\n/**\n * Fetches data from all assigned nodes, waits for workerQueue to drain and repeats.\n *\n * @param {object} options\n * @param {number} options.nodeId\n * @param {import('./workerQueue').WorkerQueue} options.workerQueue\n * @param {Map<string, string[]>} options.partitionAssignments\n * @param {(nodeId: number) => Promise<T[]>} options.fetch\n * @param {import('../../types').Logger} options.logger\n * @template T\n */\nconst createFetcher = ({\n  nodeId,\n  workerQueue,\n  partitionAssignments,\n  fetch,\n  logger: rootLogger\n}) => {\n  const logger = rootLogger.namespace(`Fetcher ${nodeId}`);\n  const emitter = new EventEmitter();\n  let isRunning = false;\n  const getWorkerQueue = () => workerQueue;\n  const assignmentKey = ({\n    topic,\n    partition\n  }) => `${topic}|${partition}`;\n  const getAssignedFetcher = batch => partitionAssignments.get(assignmentKey(batch));\n  const assignTopicPartition = batch => partitionAssignments.set(assignmentKey(batch), nodeId);\n  const unassignTopicPartition = batch => partitionAssignments.delete(assignmentKey(batch));\n  const filterUnassignedBatches = batches => batches.filter(batch => {\n    const assignedFetcher = getAssignedFetcher(batch);\n    if (assignedFetcher != null && assignedFetcher !== nodeId) {\n      logger.info('Filtering out batch due to partition already being processed by another fetcher', {\n        topic: batch.topic,\n        partition: batch.partition,\n        assignedFetcher: assignedFetcher,\n        fetcher: nodeId\n      });\n      return false;\n    }\n    return true;\n  });\n  const start = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* () {\n      if (isRunning) return;\n      isRunning = true;\n      while (isRunning) {\n        try {\n          const batches = yield fetch(nodeId);\n          if (isRunning) {\n            const availableBatches = filterUnassignedBatches(batches);\n            if (availableBatches.length > 0) {\n              availableBatches.forEach(assignTopicPartition);\n              try {\n                yield workerQueue.push(...availableBatches);\n              } finally {\n                availableBatches.forEach(unassignTopicPartition);\n              }\n            }\n          }\n        } catch (error) {\n          isRunning = false;\n          emitter.emit('end');\n          throw error;\n        }\n      }\n      emitter.emit('end');\n    });\n    return function start() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  const stop = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* () {\n      if (!isRunning) return;\n      isRunning = false;\n      yield new Promise(resolve => emitter.once('end', () => resolve()));\n    });\n    return function stop() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  return {\n    start,\n    stop,\n    getWorkerQueue\n  };\n};\nmodule.exports = createFetcher;","map":{"version":3,"names":["EventEmitter","require","createFetcher","nodeId","workerQueue","partitionAssignments","fetch","logger","rootLogger","namespace","emitter","isRunning","getWorkerQueue","assignmentKey","topic","partition","getAssignedFetcher","batch","get","assignTopicPartition","set","unassignTopicPartition","delete","filterUnassignedBatches","batches","filter","assignedFetcher","info","fetcher","start","availableBatches","length","forEach","push","error","emit","stop","Promise","resolve","once","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/consumer/fetcher.js"],"sourcesContent":["const EventEmitter = require('events')\n\n/**\n * Fetches data from all assigned nodes, waits for workerQueue to drain and repeats.\n *\n * @param {object} options\n * @param {number} options.nodeId\n * @param {import('./workerQueue').WorkerQueue} options.workerQueue\n * @param {Map<string, string[]>} options.partitionAssignments\n * @param {(nodeId: number) => Promise<T[]>} options.fetch\n * @param {import('../../types').Logger} options.logger\n * @template T\n */\nconst createFetcher = ({\n  nodeId,\n  workerQueue,\n  partitionAssignments,\n  fetch,\n  logger: rootLogger,\n}) => {\n  const logger = rootLogger.namespace(`Fetcher ${nodeId}`)\n  const emitter = new EventEmitter()\n  let isRunning = false\n\n  const getWorkerQueue = () => workerQueue\n  const assignmentKey = ({ topic, partition }) => `${topic}|${partition}`\n  const getAssignedFetcher = batch => partitionAssignments.get(assignmentKey(batch))\n  const assignTopicPartition = batch => partitionAssignments.set(assignmentKey(batch), nodeId)\n  const unassignTopicPartition = batch => partitionAssignments.delete(assignmentKey(batch))\n  const filterUnassignedBatches = batches =>\n    batches.filter(batch => {\n      const assignedFetcher = getAssignedFetcher(batch)\n      if (assignedFetcher != null && assignedFetcher !== nodeId) {\n        logger.info(\n          'Filtering out batch due to partition already being processed by another fetcher',\n          {\n            topic: batch.topic,\n            partition: batch.partition,\n            assignedFetcher: assignedFetcher,\n            fetcher: nodeId,\n          }\n        )\n        return false\n      }\n\n      return true\n    })\n\n  const start = async () => {\n    if (isRunning) return\n    isRunning = true\n\n    while (isRunning) {\n      try {\n        const batches = await fetch(nodeId)\n        if (isRunning) {\n          const availableBatches = filterUnassignedBatches(batches)\n\n          if (availableBatches.length > 0) {\n            availableBatches.forEach(assignTopicPartition)\n            try {\n              await workerQueue.push(...availableBatches)\n            } finally {\n              availableBatches.forEach(unassignTopicPartition)\n            }\n          }\n        }\n      } catch (error) {\n        isRunning = false\n        emitter.emit('end')\n        throw error\n      }\n    }\n    emitter.emit('end')\n  }\n\n  const stop = async () => {\n    if (!isRunning) return\n    isRunning = false\n    await new Promise(resolve => emitter.once('end', () => resolve()))\n  }\n\n  return { start, stop, getWorkerQueue }\n}\n\nmodule.exports = createFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}