{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst BrokerPool = require('./brokerPool');\nconst Lock = require('../utils/lock');\nconst sharedPromiseTo = require('../utils/sharedPromiseTo');\nconst createRetry = require('../retry');\nconst connectionPoolBuilder = require('./connectionPoolBuilder');\nconst {\n  EARLIEST_OFFSET,\n  LATEST_OFFSET\n} = require('../constants');\nconst {\n  KafkaJSError,\n  KafkaJSBrokerNotFound,\n  KafkaJSMetadataNotLoaded,\n  KafkaJSTopicMetadataNotLoaded,\n  KafkaJSGroupCoordinatorNotFound\n} = require('../errors');\nconst COORDINATOR_TYPES = require('../protocol/coordinatorTypes');\nconst {\n  keys\n} = Object;\nconst mergeTopics = (obj, {\n  topic,\n  partitions\n}) => ({\n  ...obj,\n  [topic]: [...(obj[topic] || []), ...partitions]\n});\nconst PRIVATE = {\n  CONNECT: Symbol('private:Cluster:connect'),\n  REFRESH_METADATA: Symbol('private:Cluster:refreshMetadata'),\n  REFRESH_METADATA_IF_NECESSARY: Symbol('private:Cluster:refreshMetadataIfNecessary'),\n  FIND_CONTROLLER_BROKER: Symbol('private:Cluster:findControllerBroker')\n};\nmodule.exports = class Cluster {\n  /**\n   * @param {Object} options\n   * @param {Array<string>} options.brokers example: ['127.0.0.1:9092', '127.0.0.1:9094']\n   * @param {Object} options.ssl\n   * @param {Object} options.sasl\n   * @param {string} options.clientId\n   * @param {number} options.connectionTimeout - in milliseconds\n   * @param {number} options.authenticationTimeout - in milliseconds\n   * @param {number} options.reauthenticationThreshold - in milliseconds\n   * @param {number} [options.requestTimeout=30000] - in milliseconds\n   * @param {boolean} [options.enforceRequestTimeout]\n   * @param {number} options.metadataMaxAge - in milliseconds\n   * @param {boolean} options.allowAutoTopicCreation\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.isolationLevel\n   * @param {import(\"../../types\").RetryOptions} options.retry\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").ISocketFactory} options.socketFactory\n   * @param {Map} [options.offsets]\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    logger: rootLogger,\n    socketFactory,\n    brokers,\n    ssl,\n    sasl,\n    clientId,\n    connectionTimeout,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    requestTimeout = 30000,\n    enforceRequestTimeout,\n    metadataMaxAge,\n    retry,\n    allowAutoTopicCreation,\n    maxInFlightRequests,\n    isolationLevel,\n    instrumentationEmitter = null,\n    offsets = new Map()\n  }) {\n    var _this = this;\n    this.rootLogger = rootLogger;\n    this.logger = rootLogger.namespace('Cluster');\n    this.retrier = createRetry(retry);\n    this.connectionPoolBuilder = connectionPoolBuilder({\n      logger: rootLogger,\n      instrumentationEmitter,\n      socketFactory,\n      brokers,\n      ssl,\n      sasl,\n      clientId,\n      connectionTimeout,\n      requestTimeout,\n      enforceRequestTimeout,\n      maxInFlightRequests,\n      reauthenticationThreshold\n    });\n    this.targetTopics = new Set();\n    this.mutatingTargetTopics = new Lock({\n      description: `updating target topics`,\n      timeout: requestTimeout\n    });\n    this.isolationLevel = isolationLevel;\n    this.brokerPool = new BrokerPool({\n      connectionPoolBuilder: this.connectionPoolBuilder,\n      logger: this.rootLogger,\n      retry,\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      metadataMaxAge\n    });\n    this.committedOffsetsByGroup = offsets;\n    this[PRIVATE.CONNECT] = sharedPromiseTo( /*#__PURE__*/_asyncToGenerator(function* () {\n      return yield _this.brokerPool.connect();\n    }));\n    this[PRIVATE.REFRESH_METADATA] = sharedPromiseTo( /*#__PURE__*/_asyncToGenerator(function* () {\n      return yield _this.brokerPool.refreshMetadata(Array.from(_this.targetTopics));\n    }));\n    this[PRIVATE.REFRESH_METADATA_IF_NECESSARY] = sharedPromiseTo( /*#__PURE__*/_asyncToGenerator(function* () {\n      return yield _this.brokerPool.refreshMetadataIfNecessary(Array.from(_this.targetTopics));\n    }));\n    this[PRIVATE.FIND_CONTROLLER_BROKER] = sharedPromiseTo( /*#__PURE__*/_asyncToGenerator(function* () {\n      const {\n        metadata\n      } = _this.brokerPool;\n      if (!metadata || metadata.controllerId == null) {\n        throw new KafkaJSMetadataNotLoaded('Topic metadata not loaded');\n      }\n      const broker = yield _this.findBroker({\n        nodeId: metadata.controllerId\n      });\n      if (!broker) {\n        throw new KafkaJSBrokerNotFound(`Controller broker with id ${metadata.controllerId} not found in the cached metadata`);\n      }\n      return broker;\n    }));\n  }\n  isConnected() {\n    return this.brokerPool.hasConnectedBrokers();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  connect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2[PRIVATE.CONNECT]();\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  disconnect() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3.brokerPool.disconnect();\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} destination\n   * @param {String} destination.host\n   * @param {Number} destination.port\n   */\n  removeBroker({\n    host,\n    port\n  }) {\n    this.brokerPool.removeBroker({\n      host,\n      port\n    });\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  refreshMetadata() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4[PRIVATE.REFRESH_METADATA]();\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  refreshMetadataIfNecessary() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5[PRIVATE.REFRESH_METADATA_IF_NECESSARY]();\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").BrokerMetadata>}\n   */\n  metadata({\n    topics = []\n  } = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return _this6.retrier( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            yield _this6.brokerPool.refreshMetadataIfNecessary(topics);\n            return _this6.brokerPool.withBroker( /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator(function* ({\n                broker\n              }) {\n                return broker.metadata(topics);\n              });\n              return function (_x4) {\n                return _ref6.apply(this, arguments);\n              };\n            }());\n          } catch (e) {\n            if (e.type === 'LEADER_NOT_AVAILABLE') {\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x, _x2, _x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @return {Promise}\n   */\n  addTargetTopic(topic) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.addMultipleTargetTopics([topic]);\n    })();\n  }\n\n  /**\n   * @public\n   * @param {string[]} topics\n   * @return {Promise}\n   */\n  addMultipleTargetTopics(topics) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      yield _this8.mutatingTargetTopics.acquire();\n      try {\n        const previousSize = _this8.targetTopics.size;\n        const previousTopics = new Set(_this8.targetTopics);\n        for (const topic of topics) {\n          _this8.targetTopics.add(topic);\n        }\n        const hasChanged = previousSize !== _this8.targetTopics.size || !_this8.brokerPool.metadata;\n        if (hasChanged) {\n          try {\n            yield _this8.refreshMetadata();\n          } catch (e) {\n            if (e.type === 'INVALID_TOPIC_EXCEPTION' || e.type === 'UNKNOWN_TOPIC_OR_PARTITION' || e.type === 'TOPIC_AUTHORIZATION_FAILED') {\n              _this8.targetTopics = previousTopics;\n            }\n            throw e;\n          }\n        }\n      } finally {\n        yield _this8.mutatingTargetTopics.release();\n      }\n    })();\n  }\n\n  /** @type {() => string[]} */\n  getNodeIds() {\n    return this.brokerPool.getNodeIds();\n  }\n\n  /**\n   * @public\n   * @param {object} options\n   * @param {string} options.nodeId\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  findBroker({\n    nodeId\n  }) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this9.brokerPool.findBroker({\n          nodeId\n        });\n      } catch (e) {\n        // The client probably has stale metadata\n        if (e.name === 'KafkaJSBrokerNotFound' || e.name === 'KafkaJSLockTimeout' || e.name === 'KafkaJSConnectionError') {\n          yield _this9.refreshMetadata();\n        }\n        throw e;\n      }\n    })();\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  findControllerBroker() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this10[PRIVATE.FIND_CONTROLLER_BROKER]();\n    })();\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @returns {import(\"../../types\").PartitionMetadata[]} Example:\n   *                   [{\n   *                     isr: [2],\n   *                     leader: 2,\n   *                     partitionErrorCode: 0,\n   *                     partitionId: 0,\n   *                     replicas: [2],\n   *                   }]\n   */\n  findTopicPartitionMetadata(topic) {\n    const {\n      metadata\n    } = this.brokerPool;\n    if (!metadata || !metadata.topicMetadata) {\n      throw new KafkaJSTopicMetadataNotLoaded('Topic metadata not loaded', {\n        topic\n      });\n    }\n    const topicMetadata = metadata.topicMetadata.find(t => t.topic === topic);\n    return topicMetadata ? topicMetadata.partitionMetadata : [];\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @param {(number|string)[]} partitions\n   * @returns {Object} Object with leader and partitions. For partitions 0 and 5\n   *                   the result could be:\n   *                     { '0': [0], '2': [5] }\n   *\n   *                   where the key is the nodeId.\n   */\n  findLeaderForPartitions(topic, partitions) {\n    const partitionMetadata = this.findTopicPartitionMetadata(topic);\n    return partitions.reduce((result, id) => {\n      const partitionId = parseInt(id, 10);\n      const metadata = partitionMetadata.find(p => p.partitionId === partitionId);\n      if (!metadata) {\n        return result;\n      }\n      if (metadata.leader === null || metadata.leader === undefined) {\n        throw new KafkaJSError('Invalid partition metadata', {\n          topic,\n          partitionId,\n          metadata\n        });\n      }\n      const {\n        leader\n      } = metadata;\n      const current = result[leader] || [];\n      return {\n        ...result,\n        [leader]: [...current, partitionId]\n      };\n    }, {});\n  }\n\n  /**\n   * @public\n   * @param {object} params\n   * @param {string} params.groupId\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} [params.coordinatorType=0]\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  findGroupCoordinator({\n    groupId,\n    coordinatorType = COORDINATOR_TYPES.GROUP\n  }) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      return _this11.retrier( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n          try {\n            const {\n              coordinator\n            } = yield _this11.findGroupCoordinatorMetadata({\n              groupId,\n              coordinatorType\n            });\n            return yield _this11.findBroker({\n              nodeId: coordinator.nodeId\n            });\n          } catch (e) {\n            // A new broker can join the cluster before we have the chance\n            // to refresh metadata\n            if (e.name === 'KafkaJSBrokerNotFound' || e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n              _this11.logger.debug(`${e.message}, refreshing metadata and trying again...`, {\n                groupId,\n                retryCount,\n                retryTime\n              });\n              yield _this11.refreshMetadata();\n              throw e;\n            }\n            if (e.code === 'ECONNREFUSED') {\n              // During maintenance the current coordinator can go down; findBroker will\n              // refresh metadata and re-throw the error. findGroupCoordinator has to re-throw\n              // the error to go through the retry cycle.\n              throw e;\n            }\n            bail(e);\n          }\n        });\n        return function (_x5, _x6, _x7) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  /**\n   * @public\n   * @param {object} params\n   * @param {string} params.groupId\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} [params.coordinatorType=0]\n   * @returns {Promise<Object>}\n   */\n  findGroupCoordinatorMetadata({\n    groupId,\n    coordinatorType\n  }) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const brokerMetadata = yield _this12.brokerPool.withBroker( /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator(function* ({\n          nodeId,\n          broker\n        }) {\n          return yield _this12.retrier( /*#__PURE__*/function () {\n            var _ref9 = _asyncToGenerator(function* (bail, retryCount, retryTime) {\n              try {\n                const brokerMetadata = yield broker.findGroupCoordinator({\n                  groupId,\n                  coordinatorType\n                });\n                _this12.logger.debug('Found group coordinator', {\n                  broker: brokerMetadata.host,\n                  nodeId: brokerMetadata.coordinator.nodeId\n                });\n                return brokerMetadata;\n              } catch (e) {\n                _this12.logger.debug('Tried to find group coordinator', {\n                  nodeId,\n                  groupId,\n                  error: e\n                });\n                if (e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n                  _this12.logger.debug('Group coordinator not available, retrying...', {\n                    nodeId,\n                    retryCount,\n                    retryTime\n                  });\n                  throw e;\n                }\n                bail(e);\n              }\n            });\n            return function (_x9, _x10, _x11) {\n              return _ref9.apply(this, arguments);\n            };\n          }());\n        });\n        return function (_x8) {\n          return _ref8.apply(this, arguments);\n        };\n      }());\n      if (brokerMetadata) {\n        return brokerMetadata;\n      }\n      throw new KafkaJSGroupCoordinatorNotFound('Failed to find group coordinator');\n    })();\n  }\n\n  /**\n   * @param {object} topicConfiguration\n   * @returns {number}\n   */\n  defaultOffset({\n    fromBeginning\n  }) {\n    return fromBeginning ? EARLIEST_OFFSET : LATEST_OFFSET;\n  }\n\n  /**\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [{ partition: 0 }],\n   *                              fromBeginning: false\n   *                            }\n   *                          ]\n   * @returns {Promise<import(\"../../types\").TopicOffsets[]>} example:\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset: '1' },\n   *                                { partition: 1, offset: '2' },\n   *                                { partition: 2, offset: '1' },\n   *                              ],\n   *                            },\n   *                          ]\n   */\n  fetchTopicsOffset(topics) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const partitionsPerBroker = {};\n      const topicConfigurations = {};\n      const addDefaultOffset = topic => partition => {\n        const {\n          timestamp\n        } = topicConfigurations[topic];\n        return {\n          ...partition,\n          timestamp\n        };\n      };\n\n      // Index all topics and partitions per leader (nodeId)\n      for (const topicData of topics) {\n        const {\n          topic,\n          partitions,\n          fromBeginning,\n          fromTimestamp\n        } = topicData;\n        const partitionsPerLeader = _this13.findLeaderForPartitions(topic, partitions.map(p => p.partition));\n        const timestamp = fromTimestamp != null ? fromTimestamp : _this13.defaultOffset({\n          fromBeginning\n        });\n        topicConfigurations[topic] = {\n          timestamp\n        };\n        keys(partitionsPerLeader).forEach(nodeId => {\n          partitionsPerBroker[nodeId] = partitionsPerBroker[nodeId] || {};\n          partitionsPerBroker[nodeId][topic] = partitions.filter(p => partitionsPerLeader[nodeId].includes(p.partition));\n        });\n      }\n\n      // Create a list of requests to fetch the offset of all partitions\n      const requests = keys(partitionsPerBroker).map( /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator(function* (nodeId) {\n          const broker = yield _this13.findBroker({\n            nodeId\n          });\n          const partitions = partitionsPerBroker[nodeId];\n          const {\n            responses: topicOffsets\n          } = yield broker.listOffsets({\n            isolationLevel: _this13.isolationLevel,\n            topics: keys(partitions).map(topic => ({\n              topic,\n              partitions: partitions[topic].map(addDefaultOffset(topic))\n            }))\n          });\n          return topicOffsets;\n        });\n        return function (_x12) {\n          return _ref10.apply(this, arguments);\n        };\n      }());\n\n      // Execute all requests, merge and normalize the responses\n      const responses = yield Promise.all(requests);\n      const partitionsPerTopic = responses.flat().reduce(mergeTopics, {});\n      return keys(partitionsPerTopic).map(topic => ({\n        topic,\n        partitions: partitionsPerTopic[topic].map(({\n          partition,\n          offset\n        }) => ({\n          partition,\n          offset\n        }))\n      }));\n    })();\n  }\n\n  /**\n   * Retrieve the object mapping for committed offsets for a single consumer group\n   * @param {object} options\n   * @param {string} options.groupId\n   * @returns {Object}\n   */\n  committedOffsets({\n    groupId\n  }) {\n    if (!this.committedOffsetsByGroup.has(groupId)) {\n      this.committedOffsetsByGroup.set(groupId, {});\n    }\n    return this.committedOffsetsByGroup.get(groupId);\n  }\n\n  /**\n   * Mark offset as committed for a single consumer group's topic-partition\n   * @param {object} options\n   * @param {string} options.groupId\n   * @param {string} options.topic\n   * @param {string|number} options.partition\n   * @param {string} options.offset\n   */\n  markOffsetAsCommitted({\n    groupId,\n    topic,\n    partition,\n    offset\n  }) {\n    const committedOffsets = this.committedOffsets({\n      groupId\n    });\n    committedOffsets[topic] = committedOffsets[topic] || {};\n    committedOffsets[topic][partition] = offset;\n  }\n};","map":{"version":3,"names":["BrokerPool","require","Lock","sharedPromiseTo","createRetry","connectionPoolBuilder","EARLIEST_OFFSET","LATEST_OFFSET","KafkaJSError","KafkaJSBrokerNotFound","KafkaJSMetadataNotLoaded","KafkaJSTopicMetadataNotLoaded","KafkaJSGroupCoordinatorNotFound","COORDINATOR_TYPES","keys","Object","mergeTopics","obj","topic","partitions","PRIVATE","CONNECT","Symbol","REFRESH_METADATA","REFRESH_METADATA_IF_NECESSARY","FIND_CONTROLLER_BROKER","module","exports","Cluster","constructor","logger","rootLogger","socketFactory","brokers","ssl","sasl","clientId","connectionTimeout","authenticationTimeout","reauthenticationThreshold","requestTimeout","enforceRequestTimeout","metadataMaxAge","retry","allowAutoTopicCreation","maxInFlightRequests","isolationLevel","instrumentationEmitter","offsets","Map","namespace","retrier","targetTopics","Set","mutatingTargetTopics","description","timeout","brokerPool","committedOffsetsByGroup","connect","refreshMetadata","Array","from","refreshMetadataIfNecessary","metadata","controllerId","broker","findBroker","nodeId","isConnected","hasConnectedBrokers","disconnect","removeBroker","host","port","topics","bail","retryCount","retryTime","withBroker","e","type","addTargetTopic","addMultipleTargetTopics","acquire","previousSize","size","previousTopics","add","hasChanged","release","getNodeIds","name","findControllerBroker","findTopicPartitionMetadata","topicMetadata","find","t","partitionMetadata","findLeaderForPartitions","reduce","result","id","partitionId","parseInt","p","leader","undefined","current","findGroupCoordinator","groupId","coordinatorType","GROUP","coordinator","findGroupCoordinatorMetadata","debug","message","code","brokerMetadata","error","defaultOffset","fromBeginning","fetchTopicsOffset","partitionsPerBroker","topicConfigurations","addDefaultOffset","partition","timestamp","topicData","fromTimestamp","partitionsPerLeader","map","forEach","filter","includes","requests","responses","topicOffsets","listOffsets","Promise","all","partitionsPerTopic","flat","offset","committedOffsets","has","set","get","markOffsetAsCommitted"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/cluster/index.js"],"sourcesContent":["const BrokerPool = require('./brokerPool')\nconst Lock = require('../utils/lock')\nconst sharedPromiseTo = require('../utils/sharedPromiseTo')\nconst createRetry = require('../retry')\nconst connectionPoolBuilder = require('./connectionPoolBuilder')\nconst { EARLIEST_OFFSET, LATEST_OFFSET } = require('../constants')\nconst {\n  KafkaJSError,\n  KafkaJSBrokerNotFound,\n  KafkaJSMetadataNotLoaded,\n  KafkaJSTopicMetadataNotLoaded,\n  KafkaJSGroupCoordinatorNotFound,\n} = require('../errors')\nconst COORDINATOR_TYPES = require('../protocol/coordinatorTypes')\n\nconst { keys } = Object\n\nconst mergeTopics = (obj, { topic, partitions }) => ({\n  ...obj,\n  [topic]: [...(obj[topic] || []), ...partitions],\n})\n\nconst PRIVATE = {\n  CONNECT: Symbol('private:Cluster:connect'),\n  REFRESH_METADATA: Symbol('private:Cluster:refreshMetadata'),\n  REFRESH_METADATA_IF_NECESSARY: Symbol('private:Cluster:refreshMetadataIfNecessary'),\n  FIND_CONTROLLER_BROKER: Symbol('private:Cluster:findControllerBroker'),\n}\n\nmodule.exports = class Cluster {\n  /**\n   * @param {Object} options\n   * @param {Array<string>} options.brokers example: ['127.0.0.1:9092', '127.0.0.1:9094']\n   * @param {Object} options.ssl\n   * @param {Object} options.sasl\n   * @param {string} options.clientId\n   * @param {number} options.connectionTimeout - in milliseconds\n   * @param {number} options.authenticationTimeout - in milliseconds\n   * @param {number} options.reauthenticationThreshold - in milliseconds\n   * @param {number} [options.requestTimeout=30000] - in milliseconds\n   * @param {boolean} [options.enforceRequestTimeout]\n   * @param {number} options.metadataMaxAge - in milliseconds\n   * @param {boolean} options.allowAutoTopicCreation\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.isolationLevel\n   * @param {import(\"../../types\").RetryOptions} options.retry\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {import(\"../../types\").ISocketFactory} options.socketFactory\n   * @param {Map} [options.offsets]\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    logger: rootLogger,\n    socketFactory,\n    brokers,\n    ssl,\n    sasl,\n    clientId,\n    connectionTimeout,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    requestTimeout = 30000,\n    enforceRequestTimeout,\n    metadataMaxAge,\n    retry,\n    allowAutoTopicCreation,\n    maxInFlightRequests,\n    isolationLevel,\n    instrumentationEmitter = null,\n    offsets = new Map(),\n  }) {\n    this.rootLogger = rootLogger\n    this.logger = rootLogger.namespace('Cluster')\n    this.retrier = createRetry(retry)\n    this.connectionPoolBuilder = connectionPoolBuilder({\n      logger: rootLogger,\n      instrumentationEmitter,\n      socketFactory,\n      brokers,\n      ssl,\n      sasl,\n      clientId,\n      connectionTimeout,\n      requestTimeout,\n      enforceRequestTimeout,\n      maxInFlightRequests,\n      reauthenticationThreshold,\n    })\n\n    this.targetTopics = new Set()\n    this.mutatingTargetTopics = new Lock({\n      description: `updating target topics`,\n      timeout: requestTimeout,\n    })\n    this.isolationLevel = isolationLevel\n    this.brokerPool = new BrokerPool({\n      connectionPoolBuilder: this.connectionPoolBuilder,\n      logger: this.rootLogger,\n      retry,\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      metadataMaxAge,\n    })\n    this.committedOffsetsByGroup = offsets\n\n    this[PRIVATE.CONNECT] = sharedPromiseTo(async () => {\n      return await this.brokerPool.connect()\n    })\n\n    this[PRIVATE.REFRESH_METADATA] = sharedPromiseTo(async () => {\n      return await this.brokerPool.refreshMetadata(Array.from(this.targetTopics))\n    })\n\n    this[PRIVATE.REFRESH_METADATA_IF_NECESSARY] = sharedPromiseTo(async () => {\n      return await this.brokerPool.refreshMetadataIfNecessary(Array.from(this.targetTopics))\n    })\n\n    this[PRIVATE.FIND_CONTROLLER_BROKER] = sharedPromiseTo(async () => {\n      const { metadata } = this.brokerPool\n\n      if (!metadata || metadata.controllerId == null) {\n        throw new KafkaJSMetadataNotLoaded('Topic metadata not loaded')\n      }\n\n      const broker = await this.findBroker({ nodeId: metadata.controllerId })\n\n      if (!broker) {\n        throw new KafkaJSBrokerNotFound(\n          `Controller broker with id ${metadata.controllerId} not found in the cached metadata`\n        )\n      }\n\n      return broker\n    })\n  }\n\n  isConnected() {\n    return this.brokerPool.hasConnectedBrokers()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  async connect() {\n    await this[PRIVATE.CONNECT]()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  async disconnect() {\n    await this.brokerPool.disconnect()\n  }\n\n  /**\n   * @public\n   * @param {object} destination\n   * @param {String} destination.host\n   * @param {Number} destination.port\n   */\n  removeBroker({ host, port }) {\n    this.brokerPool.removeBroker({ host, port })\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  async refreshMetadata() {\n    await this[PRIVATE.REFRESH_METADATA]()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<void>}\n   */\n  async refreshMetadataIfNecessary() {\n    await this[PRIVATE.REFRESH_METADATA_IF_NECESSARY]()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").BrokerMetadata>}\n   */\n  async metadata({ topics = [] } = {}) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.brokerPool.refreshMetadataIfNecessary(topics)\n        return this.brokerPool.withBroker(async ({ broker }) => broker.metadata(topics))\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @return {Promise}\n   */\n  async addTargetTopic(topic) {\n    return this.addMultipleTargetTopics([topic])\n  }\n\n  /**\n   * @public\n   * @param {string[]} topics\n   * @return {Promise}\n   */\n  async addMultipleTargetTopics(topics) {\n    await this.mutatingTargetTopics.acquire()\n\n    try {\n      const previousSize = this.targetTopics.size\n      const previousTopics = new Set(this.targetTopics)\n      for (const topic of topics) {\n        this.targetTopics.add(topic)\n      }\n\n      const hasChanged = previousSize !== this.targetTopics.size || !this.brokerPool.metadata\n\n      if (hasChanged) {\n        try {\n          await this.refreshMetadata()\n        } catch (e) {\n          if (\n            e.type === 'INVALID_TOPIC_EXCEPTION' ||\n            e.type === 'UNKNOWN_TOPIC_OR_PARTITION' ||\n            e.type === 'TOPIC_AUTHORIZATION_FAILED'\n          ) {\n            this.targetTopics = previousTopics\n          }\n\n          throw e\n        }\n      }\n    } finally {\n      await this.mutatingTargetTopics.release()\n    }\n  }\n\n  /** @type {() => string[]} */\n  getNodeIds() {\n    return this.brokerPool.getNodeIds()\n  }\n\n  /**\n   * @public\n   * @param {object} options\n   * @param {string} options.nodeId\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  async findBroker({ nodeId }) {\n    try {\n      return await this.brokerPool.findBroker({ nodeId })\n    } catch (e) {\n      // The client probably has stale metadata\n      if (\n        e.name === 'KafkaJSBrokerNotFound' ||\n        e.name === 'KafkaJSLockTimeout' ||\n        e.name === 'KafkaJSConnectionError'\n      ) {\n        await this.refreshMetadata()\n      }\n\n      throw e\n    }\n  }\n\n  /**\n   * @public\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  async findControllerBroker() {\n    return await this[PRIVATE.FIND_CONTROLLER_BROKER]()\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @returns {import(\"../../types\").PartitionMetadata[]} Example:\n   *                   [{\n   *                     isr: [2],\n   *                     leader: 2,\n   *                     partitionErrorCode: 0,\n   *                     partitionId: 0,\n   *                     replicas: [2],\n   *                   }]\n   */\n  findTopicPartitionMetadata(topic) {\n    const { metadata } = this.brokerPool\n    if (!metadata || !metadata.topicMetadata) {\n      throw new KafkaJSTopicMetadataNotLoaded('Topic metadata not loaded', { topic })\n    }\n\n    const topicMetadata = metadata.topicMetadata.find(t => t.topic === topic)\n    return topicMetadata ? topicMetadata.partitionMetadata : []\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @param {(number|string)[]} partitions\n   * @returns {Object} Object with leader and partitions. For partitions 0 and 5\n   *                   the result could be:\n   *                     { '0': [0], '2': [5] }\n   *\n   *                   where the key is the nodeId.\n   */\n  findLeaderForPartitions(topic, partitions) {\n    const partitionMetadata = this.findTopicPartitionMetadata(topic)\n    return partitions.reduce((result, id) => {\n      const partitionId = parseInt(id, 10)\n      const metadata = partitionMetadata.find(p => p.partitionId === partitionId)\n\n      if (!metadata) {\n        return result\n      }\n\n      if (metadata.leader === null || metadata.leader === undefined) {\n        throw new KafkaJSError('Invalid partition metadata', { topic, partitionId, metadata })\n      }\n\n      const { leader } = metadata\n      const current = result[leader] || []\n      return { ...result, [leader]: [...current, partitionId] }\n    }, {})\n  }\n\n  /**\n   * @public\n   * @param {object} params\n   * @param {string} params.groupId\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} [params.coordinatorType=0]\n   * @returns {Promise<import(\"../../types\").Broker>}\n   */\n  async findGroupCoordinator({ groupId, coordinatorType = COORDINATOR_TYPES.GROUP }) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        const { coordinator } = await this.findGroupCoordinatorMetadata({\n          groupId,\n          coordinatorType,\n        })\n        return await this.findBroker({ nodeId: coordinator.nodeId })\n      } catch (e) {\n        // A new broker can join the cluster before we have the chance\n        // to refresh metadata\n        if (e.name === 'KafkaJSBrokerNotFound' || e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n          this.logger.debug(`${e.message}, refreshing metadata and trying again...`, {\n            groupId,\n            retryCount,\n            retryTime,\n          })\n\n          await this.refreshMetadata()\n          throw e\n        }\n\n        if (e.code === 'ECONNREFUSED') {\n          // During maintenance the current coordinator can go down; findBroker will\n          // refresh metadata and re-throw the error. findGroupCoordinator has to re-throw\n          // the error to go through the retry cycle.\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {object} params\n   * @param {string} params.groupId\n   * @param {import(\"../protocol/coordinatorTypes\").CoordinatorType} [params.coordinatorType=0]\n   * @returns {Promise<Object>}\n   */\n  async findGroupCoordinatorMetadata({ groupId, coordinatorType }) {\n    const brokerMetadata = await this.brokerPool.withBroker(async ({ nodeId, broker }) => {\n      return await this.retrier(async (bail, retryCount, retryTime) => {\n        try {\n          const brokerMetadata = await broker.findGroupCoordinator({ groupId, coordinatorType })\n          this.logger.debug('Found group coordinator', {\n            broker: brokerMetadata.host,\n            nodeId: brokerMetadata.coordinator.nodeId,\n          })\n          return brokerMetadata\n        } catch (e) {\n          this.logger.debug('Tried to find group coordinator', {\n            nodeId,\n            groupId,\n            error: e,\n          })\n\n          if (e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n            this.logger.debug('Group coordinator not available, retrying...', {\n              nodeId,\n              retryCount,\n              retryTime,\n            })\n\n            throw e\n          }\n\n          bail(e)\n        }\n      })\n    })\n\n    if (brokerMetadata) {\n      return brokerMetadata\n    }\n\n    throw new KafkaJSGroupCoordinatorNotFound('Failed to find group coordinator')\n  }\n\n  /**\n   * @param {object} topicConfiguration\n   * @returns {number}\n   */\n  defaultOffset({ fromBeginning }) {\n    return fromBeginning ? EARLIEST_OFFSET : LATEST_OFFSET\n  }\n\n  /**\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [{ partition: 0 }],\n   *                              fromBeginning: false\n   *                            }\n   *                          ]\n   * @returns {Promise<import(\"../../types\").TopicOffsets[]>} example:\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset: '1' },\n   *                                { partition: 1, offset: '2' },\n   *                                { partition: 2, offset: '1' },\n   *                              ],\n   *                            },\n   *                          ]\n   */\n  async fetchTopicsOffset(topics) {\n    const partitionsPerBroker = {}\n    const topicConfigurations = {}\n\n    const addDefaultOffset = topic => partition => {\n      const { timestamp } = topicConfigurations[topic]\n      return { ...partition, timestamp }\n    }\n\n    // Index all topics and partitions per leader (nodeId)\n    for (const topicData of topics) {\n      const { topic, partitions, fromBeginning, fromTimestamp } = topicData\n      const partitionsPerLeader = this.findLeaderForPartitions(\n        topic,\n        partitions.map(p => p.partition)\n      )\n      const timestamp =\n        fromTimestamp != null ? fromTimestamp : this.defaultOffset({ fromBeginning })\n\n      topicConfigurations[topic] = { timestamp }\n\n      keys(partitionsPerLeader).forEach(nodeId => {\n        partitionsPerBroker[nodeId] = partitionsPerBroker[nodeId] || {}\n        partitionsPerBroker[nodeId][topic] = partitions.filter(p =>\n          partitionsPerLeader[nodeId].includes(p.partition)\n        )\n      })\n    }\n\n    // Create a list of requests to fetch the offset of all partitions\n    const requests = keys(partitionsPerBroker).map(async nodeId => {\n      const broker = await this.findBroker({ nodeId })\n      const partitions = partitionsPerBroker[nodeId]\n\n      const { responses: topicOffsets } = await broker.listOffsets({\n        isolationLevel: this.isolationLevel,\n        topics: keys(partitions).map(topic => ({\n          topic,\n          partitions: partitions[topic].map(addDefaultOffset(topic)),\n        })),\n      })\n\n      return topicOffsets\n    })\n\n    // Execute all requests, merge and normalize the responses\n    const responses = await Promise.all(requests)\n    const partitionsPerTopic = responses.flat().reduce(mergeTopics, {})\n\n    return keys(partitionsPerTopic).map(topic => ({\n      topic,\n      partitions: partitionsPerTopic[topic].map(({ partition, offset }) => ({\n        partition,\n        offset,\n      })),\n    }))\n  }\n\n  /**\n   * Retrieve the object mapping for committed offsets for a single consumer group\n   * @param {object} options\n   * @param {string} options.groupId\n   * @returns {Object}\n   */\n  committedOffsets({ groupId }) {\n    if (!this.committedOffsetsByGroup.has(groupId)) {\n      this.committedOffsetsByGroup.set(groupId, {})\n    }\n\n    return this.committedOffsetsByGroup.get(groupId)\n  }\n\n  /**\n   * Mark offset as committed for a single consumer group's topic-partition\n   * @param {object} options\n   * @param {string} options.groupId\n   * @param {string} options.topic\n   * @param {string|number} options.partition\n   * @param {string} options.offset\n   */\n  markOffsetAsCommitted({ groupId, topic, partition, offset }) {\n    const committedOffsets = this.committedOffsets({ groupId })\n\n    committedOffsets[topic] = committedOffsets[topic] || {}\n    committedOffsets[topic][partition] = offset\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}