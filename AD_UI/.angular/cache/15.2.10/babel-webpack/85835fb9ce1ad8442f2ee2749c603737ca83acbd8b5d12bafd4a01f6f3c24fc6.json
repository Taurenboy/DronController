{"ast":null,"code":"const Encoder = require('../encoder');\nconst MessageProtocol = require('../message');\nconst {\n  Types\n} = require('../message/compression');\n\n/**\n * MessageSet => [Offset MessageSize Message]\n *  Offset => int64\n *  MessageSize => int32\n *  Message => Bytes\n */\n\n/**\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n */\nmodule.exports = ({\n  messageVersion = 0,\n  compression,\n  entries\n}) => {\n  const isCompressed = compression !== Types.None;\n  const Message = MessageProtocol({\n    version: messageVersion\n  });\n  const encoder = new Encoder();\n\n  // Messages in a message set are __not__ encoded as an array.\n  // They are written in sequence.\n  // https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets\n\n  entries.forEach((entry, i) => {\n    const message = Message(entry);\n\n    // This is the offset used in kafka as the log sequence number.\n    // When the producer is sending non compressed messages, it can set the offsets to anything\n    // When the producer is sending compressed messages, to avoid server side recompression, each compressed message\n    // should have offset starting from 0 and increasing by one for each inner message in the compressed message\n    encoder.writeInt64(isCompressed ? i : -1);\n    encoder.writeInt32(message.size());\n    encoder.writeEncoder(message);\n  });\n  return encoder;\n};","map":{"version":3,"names":["Encoder","require","MessageProtocol","Types","module","exports","messageVersion","compression","entries","isCompressed","None","Message","version","encoder","forEach","entry","i","message","writeInt64","writeInt32","size","writeEncoder"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/messageSet/index.js"],"sourcesContent":["const Encoder = require('../encoder')\nconst MessageProtocol = require('../message')\nconst { Types } = require('../message/compression')\n\n/**\n * MessageSet => [Offset MessageSize Message]\n *  Offset => int64\n *  MessageSize => int32\n *  Message => Bytes\n */\n\n/**\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n */\nmodule.exports = ({ messageVersion = 0, compression, entries }) => {\n  const isCompressed = compression !== Types.None\n  const Message = MessageProtocol({ version: messageVersion })\n  const encoder = new Encoder()\n\n  // Messages in a message set are __not__ encoded as an array.\n  // They are written in sequence.\n  // https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets\n\n  entries.forEach((entry, i) => {\n    const message = Message(entry)\n\n    // This is the offset used in kafka as the log sequence number.\n    // When the producer is sending non compressed messages, it can set the offsets to anything\n    // When the producer is sending compressed messages, to avoid server side recompression, each compressed message\n    // should have offset starting from 0 and increasing by one for each inner message in the compressed message\n    encoder.writeInt64(isCompressed ? i : -1)\n    encoder.writeInt32(message.size())\n\n    encoder.writeEncoder(message)\n  })\n\n  return encoder\n}\n"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,YAAY,CAAC;AACrC,MAAMC,eAAe,GAAGD,OAAO,CAAC,YAAY,CAAC;AAC7C,MAAM;EAAEE;AAAM,CAAC,GAAGF,OAAO,CAAC,wBAAwB,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAG,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEC,cAAc,GAAG,CAAC;EAAEC,WAAW;EAAEC;AAAQ,CAAC,KAAK;EACjE,MAAMC,YAAY,GAAGF,WAAW,KAAKJ,KAAK,CAACO,IAAI;EAC/C,MAAMC,OAAO,GAAGT,eAAe,CAAC;IAAEU,OAAO,EAAEN;EAAe,CAAC,CAAC;EAC5D,MAAMO,OAAO,GAAG,IAAIb,OAAO,EAAE;;EAE7B;EACA;EACA;;EAEAQ,OAAO,CAACM,OAAO,CAAC,CAACC,KAAK,EAAEC,CAAC,KAAK;IAC5B,MAAMC,OAAO,GAAGN,OAAO,CAACI,KAAK,CAAC;;IAE9B;IACA;IACA;IACA;IACAF,OAAO,CAACK,UAAU,CAACT,YAAY,GAAGO,CAAC,GAAG,CAAC,CAAC,CAAC;IACzCH,OAAO,CAACM,UAAU,CAACF,OAAO,CAACG,IAAI,EAAE,CAAC;IAElCP,OAAO,CAACQ,YAAY,CAACJ,OAAO,CAAC;EAC/B,CAAC,CAAC;EAEF,OAAOJ,OAAO;AAChB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}