{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Long = require('../../../utils/long');\nconst Encoder = require('../../encoder');\nconst crc32C = require('../crc32C');\nconst {\n  Types: Compression,\n  lookupCodec,\n  COMPRESSION_CODEC_MASK\n} = require('../../message/compression');\nconst MAGIC_BYTE = 2;\nconst TIMESTAMP_MASK = 0; // The fourth lowest bit, always set this bit to 0 (since 0.10.0)\nconst TRANSACTIONAL_MASK = 16; // The fifth lowest bit\n\n/**\n * v0\n * RecordBatch =>\n *  FirstOffset => int64\n *  Length => int32\n *  PartitionLeaderEpoch => int32\n *  Magic => int8\n *  CRC => int32\n *  Attributes => int16\n *  LastOffsetDelta => int32\n *  FirstTimestamp => int64\n *  MaxTimestamp => int64\n *  ProducerId => int64\n *  ProducerEpoch => int16\n *  FirstSequence => int32\n *  Records => [Record]\n */\n\nconst RecordBatch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    compression = Compression.None,\n    firstOffset = Long.fromInt(0),\n    firstTimestamp = Date.now(),\n    maxTimestamp = Date.now(),\n    partitionLeaderEpoch = 0,\n    lastOffsetDelta = 0,\n    transactional = false,\n    producerId = Long.fromValue(-1),\n    // for idempotent messages\n    producerEpoch = 0,\n    // for idempotent messages\n    firstSequence = 0,\n    // for idempotent messages\n    records = []\n  }) {\n    const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK;\n    const IN_TRANSACTION = transactional ? TRANSACTIONAL_MASK : 0;\n    const attributes = COMPRESSION_CODEC | TIMESTAMP_MASK | IN_TRANSACTION;\n    const batchBody = new Encoder().writeInt16(attributes).writeInt32(lastOffsetDelta).writeInt64(firstTimestamp).writeInt64(maxTimestamp).writeInt64(producerId).writeInt16(producerEpoch).writeInt32(firstSequence);\n    if (compression === Compression.None) {\n      if (records.every(v => typeof v === typeof records[0])) {\n        batchBody.writeArray(records, typeof records[0]);\n      } else {\n        batchBody.writeArray(records);\n      }\n    } else {\n      const compressedRecords = yield compressRecords(compression, records);\n      batchBody.writeInt32(records.length).writeBuffer(compressedRecords);\n    }\n\n    // CRC32C validation is happening here:\n    // https://github.com/apache/kafka/blob/0.11.0.1/clients/src/main/java/org/apache/kafka/common/record/DefaultRecordBatch.java#L148\n\n    const batch = new Encoder().writeInt32(partitionLeaderEpoch).writeInt8(MAGIC_BYTE).writeUInt32(crc32C(batchBody.buffer)).writeEncoder(batchBody);\n    return new Encoder().writeInt64(firstOffset).writeBytes(batch.buffer);\n  });\n  return function RecordBatch(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst compressRecords = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (compression, records) {\n    const codec = lookupCodec(compression);\n    const recordsEncoder = new Encoder();\n    recordsEncoder.writeEncoderArray(records);\n    return codec.compress(recordsEncoder);\n  });\n  return function compressRecords(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nmodule.exports = {\n  RecordBatch,\n  MAGIC_BYTE\n};","map":{"version":3,"names":["Long","require","Encoder","crc32C","Types","Compression","lookupCodec","COMPRESSION_CODEC_MASK","MAGIC_BYTE","TIMESTAMP_MASK","TRANSACTIONAL_MASK","RecordBatch","compression","None","firstOffset","fromInt","firstTimestamp","Date","now","maxTimestamp","partitionLeaderEpoch","lastOffsetDelta","transactional","producerId","fromValue","producerEpoch","firstSequence","records","COMPRESSION_CODEC","IN_TRANSACTION","attributes","batchBody","writeInt16","writeInt32","writeInt64","every","v","writeArray","compressedRecords","compressRecords","length","writeBuffer","batch","writeInt8","writeUInt32","buffer","writeEncoder","writeBytes","codec","recordsEncoder","writeEncoderArray","compress","module","exports"],"sources":["C:/Users/ingev/Documents/Desarrollo/Luna/DronController/AD_UI/node_modules/kafkajs/src/protocol/recordBatch/v0/index.js"],"sourcesContent":["const Long = require('../../../utils/long')\nconst Encoder = require('../../encoder')\nconst crc32C = require('../crc32C')\nconst {\n  Types: Compression,\n  lookupCodec,\n  COMPRESSION_CODEC_MASK,\n} = require('../../message/compression')\n\nconst MAGIC_BYTE = 2\nconst TIMESTAMP_MASK = 0 // The fourth lowest bit, always set this bit to 0 (since 0.10.0)\nconst TRANSACTIONAL_MASK = 16 // The fifth lowest bit\n\n/**\n * v0\n * RecordBatch =>\n *  FirstOffset => int64\n *  Length => int32\n *  PartitionLeaderEpoch => int32\n *  Magic => int8\n *  CRC => int32\n *  Attributes => int16\n *  LastOffsetDelta => int32\n *  FirstTimestamp => int64\n *  MaxTimestamp => int64\n *  ProducerId => int64\n *  ProducerEpoch => int16\n *  FirstSequence => int32\n *  Records => [Record]\n */\n\nconst RecordBatch = async ({\n  compression = Compression.None,\n  firstOffset = Long.fromInt(0),\n  firstTimestamp = Date.now(),\n  maxTimestamp = Date.now(),\n  partitionLeaderEpoch = 0,\n  lastOffsetDelta = 0,\n  transactional = false,\n  producerId = Long.fromValue(-1), // for idempotent messages\n  producerEpoch = 0, // for idempotent messages\n  firstSequence = 0, // for idempotent messages\n  records = [],\n}) => {\n  const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK\n  const IN_TRANSACTION = transactional ? TRANSACTIONAL_MASK : 0\n  const attributes = COMPRESSION_CODEC | TIMESTAMP_MASK | IN_TRANSACTION\n\n  const batchBody = new Encoder()\n    .writeInt16(attributes)\n    .writeInt32(lastOffsetDelta)\n    .writeInt64(firstTimestamp)\n    .writeInt64(maxTimestamp)\n    .writeInt64(producerId)\n    .writeInt16(producerEpoch)\n    .writeInt32(firstSequence)\n\n  if (compression === Compression.None) {\n    if (records.every(v => typeof v === typeof records[0])) {\n      batchBody.writeArray(records, typeof records[0])\n    } else {\n      batchBody.writeArray(records)\n    }\n  } else {\n    const compressedRecords = await compressRecords(compression, records)\n    batchBody.writeInt32(records.length).writeBuffer(compressedRecords)\n  }\n\n  // CRC32C validation is happening here:\n  // https://github.com/apache/kafka/blob/0.11.0.1/clients/src/main/java/org/apache/kafka/common/record/DefaultRecordBatch.java#L148\n\n  const batch = new Encoder()\n    .writeInt32(partitionLeaderEpoch)\n    .writeInt8(MAGIC_BYTE)\n    .writeUInt32(crc32C(batchBody.buffer))\n    .writeEncoder(batchBody)\n\n  return new Encoder().writeInt64(firstOffset).writeBytes(batch.buffer)\n}\n\nconst compressRecords = async (compression, records) => {\n  const codec = lookupCodec(compression)\n  const recordsEncoder = new Encoder()\n\n  recordsEncoder.writeEncoderArray(records)\n\n  return codec.compress(recordsEncoder)\n}\n\nmodule.exports = {\n  RecordBatch,\n  MAGIC_BYTE,\n}\n"],"mappings":";AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC3C,MAAMC,OAAO,GAAGD,OAAO,CAAC,eAAe,CAAC;AACxC,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAW,CAAC;AACnC,MAAM;EACJG,KAAK,EAAEC,WAAW;EAClBC,WAAW;EACXC;AACF,CAAC,GAAGN,OAAO,CAAC,2BAA2B,CAAC;AAExC,MAAMO,UAAU,GAAG,CAAC;AACpB,MAAMC,cAAc,GAAG,CAAC,EAAC;AACzB,MAAMC,kBAAkB,GAAG,EAAE,EAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,WAAW;EAAA,6BAAG,WAAO;IACzBC,WAAW,GAAGP,WAAW,CAACQ,IAAI;IAC9BC,WAAW,GAAGd,IAAI,CAACe,OAAO,CAAC,CAAC,CAAC;IAC7BC,cAAc,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC3BC,YAAY,GAAGF,IAAI,CAACC,GAAG,EAAE;IACzBE,oBAAoB,GAAG,CAAC;IACxBC,eAAe,GAAG,CAAC;IACnBC,aAAa,GAAG,KAAK;IACrBC,UAAU,GAAGvB,IAAI,CAACwB,SAAS,CAAC,CAAC,CAAC,CAAC;IAAE;IACjCC,aAAa,GAAG,CAAC;IAAE;IACnBC,aAAa,GAAG,CAAC;IAAE;IACnBC,OAAO,GAAG;EACZ,CAAC,EAAK;IACJ,MAAMC,iBAAiB,GAAGhB,WAAW,GAAGL,sBAAsB;IAC9D,MAAMsB,cAAc,GAAGP,aAAa,GAAGZ,kBAAkB,GAAG,CAAC;IAC7D,MAAMoB,UAAU,GAAGF,iBAAiB,GAAGnB,cAAc,GAAGoB,cAAc;IAEtE,MAAME,SAAS,GAAG,IAAI7B,OAAO,EAAE,CAC5B8B,UAAU,CAACF,UAAU,CAAC,CACtBG,UAAU,CAACZ,eAAe,CAAC,CAC3Ba,UAAU,CAAClB,cAAc,CAAC,CAC1BkB,UAAU,CAACf,YAAY,CAAC,CACxBe,UAAU,CAACX,UAAU,CAAC,CACtBS,UAAU,CAACP,aAAa,CAAC,CACzBQ,UAAU,CAACP,aAAa,CAAC;IAE5B,IAAId,WAAW,KAAKP,WAAW,CAACQ,IAAI,EAAE;MACpC,IAAIc,OAAO,CAACQ,KAAK,CAACC,CAAC,IAAI,OAAOA,CAAC,KAAK,OAAOT,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;QACtDI,SAAS,CAACM,UAAU,CAACV,OAAO,EAAE,OAAOA,OAAO,CAAC,CAAC,CAAC,CAAC;MAClD,CAAC,MAAM;QACLI,SAAS,CAACM,UAAU,CAACV,OAAO,CAAC;MAC/B;IACF,CAAC,MAAM;MACL,MAAMW,iBAAiB,SAASC,eAAe,CAAC3B,WAAW,EAAEe,OAAO,CAAC;MACrEI,SAAS,CAACE,UAAU,CAACN,OAAO,CAACa,MAAM,CAAC,CAACC,WAAW,CAACH,iBAAiB,CAAC;IACrE;;IAEA;IACA;;IAEA,MAAMI,KAAK,GAAG,IAAIxC,OAAO,EAAE,CACxB+B,UAAU,CAACb,oBAAoB,CAAC,CAChCuB,SAAS,CAACnC,UAAU,CAAC,CACrBoC,WAAW,CAACzC,MAAM,CAAC4B,SAAS,CAACc,MAAM,CAAC,CAAC,CACrCC,YAAY,CAACf,SAAS,CAAC;IAE1B,OAAO,IAAI7B,OAAO,EAAE,CAACgC,UAAU,CAACpB,WAAW,CAAC,CAACiC,UAAU,CAACL,KAAK,CAACG,MAAM,CAAC;EACvE,CAAC;EAAA,gBA/CKlC,WAAW;IAAA;EAAA;AAAA,GA+ChB;AAED,MAAM4B,eAAe;EAAA,8BAAG,WAAO3B,WAAW,EAAEe,OAAO,EAAK;IACtD,MAAMqB,KAAK,GAAG1C,WAAW,CAACM,WAAW,CAAC;IACtC,MAAMqC,cAAc,GAAG,IAAI/C,OAAO,EAAE;IAEpC+C,cAAc,CAACC,iBAAiB,CAACvB,OAAO,CAAC;IAEzC,OAAOqB,KAAK,CAACG,QAAQ,CAACF,cAAc,CAAC;EACvC,CAAC;EAAA,gBAPKV,eAAe;IAAA;EAAA;AAAA,GAOpB;AAEDa,MAAM,CAACC,OAAO,GAAG;EACf1C,WAAW;EACXH;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}